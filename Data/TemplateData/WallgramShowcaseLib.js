(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap";*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:currentColor}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}.wg-fixed{position:fixed}.wg-absolute{position:absolute}.wg-relative{position:relative}.-wg-right-1{right:-.25rem}.-wg-top-1{top:-.25rem}.wg-right-4{right:1rem}.wg-top-0{top:0}.wg-top-\\[-500px\\]{top:-500px}.wg-mb-\\[6px\\]{margin-bottom:6px}.wg-mr-\\[4px\\]{margin-right:4px}.wg-mt-\\[16px\\]{margin-top:16px}.wg-mt-\\[24px\\]{margin-top:24px}.wg-mt-\\[8px\\]{margin-top:8px}.wg-flex{display:flex}.wg-hidden{display:none}.wg-size-\\[14px\\]{width:14px;height:14px}.wg-size-\\[24px\\]{width:24px;height:24px}.wg-size-\\[44px\\]{width:44px;height:44px}.wg-size-\\[64px\\]{width:64px;height:64px}.\\!wg-h-\\[40px\\]{height:40px!important}.wg-h-\\[12px\\]{height:12px}.wg-h-\\[52px\\]{height:52px}.wg-max-h-\\[110px\\]{max-height:110px}.wg-max-h-\\[190px\\]{max-height:190px}.wg-w-8{width:2rem}.wg-w-\\[12px\\]{width:12px}.wg-w-full{width:100%}.wg-shrink-0{flex-shrink:0}.wg-grow{flex-grow:1}.wg-rotate-45{--tw-rotate: 45deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.wg-cursor-pointer{cursor:pointer}.wg-flex-col{flex-direction:column}.wg-flex-wrap{flex-wrap:wrap}.wg-items-center{align-items:center}.wg-justify-end{justify-content:flex-end}.wg-justify-center{justify-content:center}.wg-justify-between{justify-content:space-between}.wg-gap-\\[12px\\]{gap:12px}.wg-gap-\\[16px\\]{gap:16px}.wg-gap-\\[24px\\]{gap:24px}.wg-gap-\\[4px\\]{gap:4px}.wg-gap-\\[6px\\]{gap:6px}.wg-gap-\\[8px\\]{gap:8px}.wg-gap-y-1{row-gap:.25rem}.wg-overflow-y-scroll{overflow-y:scroll}.wg-whitespace-break-spaces{white-space:break-spaces}.wg-rounded-full{border-radius:9999px}.wg-bg-black{--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.wg-bg-red{--tw-bg-opacity: 1;background-color:rgb(241 81 81 / var(--tw-bg-opacity))}.wg-bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.wg-bg-opacity-50{--tw-bg-opacity: .5}.wg-fill-gray-900{fill:#171717}.wg-px-\\[16px\\]{padding-left:16px;padding-right:16px}.wg-py-\\[16px\\]{padding-top:16px;padding-bottom:16px}.\\!wg-pr-10{padding-right:2.5rem!important}.wg-pb-\\[32px\\]{padding-bottom:32px}.wg-pb-\\[40px\\]{padding-bottom:40px}.wg-pb-\\[5px\\]{padding-bottom:5px}.wg-pt-\\[16px\\]{padding-top:16px}.wg-text-left{text-align:left}.wg-text-center{text-align:center}.wg-text-13-medium{font-size:13px;line-height:17px;letter-spacing:-.065px;font-weight:500}.wg-text-13-reg{font-size:13px;line-height:16px;letter-spacing:-.13px}.wg-text-14-reg{font-size:14px;line-height:20px;letter-spacing:-.07px}.wg-text-16{font-size:16px;line-height:24px;letter-spacing:-.48px}.wg-text-16-reg{font-size:16px;line-height:24px}.wg-text-17{font-size:17px;line-height:24px;letter-spacing:-1%}.wg-text-20{font-size:20px;line-height:26px;letter-spacing:.6px}.wg-text-\\[10px\\]{font-size:10px}.wg-text-h2{font-size:22px;line-height:26px;letter-spacing:-.33px;font-weight:700}.wg-font-bold{font-weight:700}.wg-font-medium{font-weight:500}.wg-font-semibold{font-weight:600}.wg-leading-\\[20px\\]{line-height:20px}.wg-text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.wg-text-gray-700{--tw-text-opacity: 1;color:rgb(114 114 114 / var(--tw-text-opacity))}.wg-text-gray-900{--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity))}.wg-text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#WGS_top_alert_wrapper{height:180px;width:100%;background:linear-gradient(180deg,#000305,#00030500);z-index:9999;padding:14px 16px;left:0;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.5s}#WGS_top_alert_wrapper .alert{padding:16px;border-radius:14px}#WGS_top_alert_wrapper .alert-success{--tw-bg-opacity: 1;background-color:rgb(90 189 54 / var(--tw-bg-opacity))}#WGS_top_alert_wrapper .alert-error{--tw-bg-opacity: 1;background-color:rgb(241 81 81 / var(--tw-bg-opacity))}#WGS,.WGS_BS{--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity))}@font-face{font-family:Druk Cyr;src:local("Druk Cyr Heavy"),local("Druk-Cyr-Heavy"),url(/src/assets/fonts/DrukCyr-Heavy.woff2) format("woff2"),url(/src/assets/fonts/DrukCyr-Heavy.woff) format("woff"),url(/src/assets/fonts/DrukCyr-Heavy.ttf) format("truetype");font-weight:900;font-style:normal;font-display:swap}#WGS .btn-wgs,.WGS_BS .btn-wgs{display:flex;height:40px;cursor:pointer;align-items:center;justify-content:center;border-radius:8px;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.3s}#WGS .btn-wgs:disabled,.WGS_BS .btn-wgs:disabled{opacity:.5}#WGS .btn-wgs-lg,.WGS_BS .btn-wgs-lg{height:52px;border-radius:12px;font-size:16px;line-height:24px;font-weight:600}#WGS .btn-wgs-gray,.WGS_BS .btn-wgs-gray{--tw-bg-opacity: 1;background-color:rgb(237 237 237 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity))}#WGS .btn-wgs-gray:where(.wg-dark,.wg-dark *),.WGS_BS .btn-wgs-gray:where(.wg-dark,.wg-dark *){--tw-bg-opacity: 1;background-color:rgb(46 46 46 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(192 192 192 / var(--tw-text-opacity))}#WGS .btn-wgs-gray:hover:not(:disabled),.WGS_BS .btn-wgs-gray:hover:not(:disabled){--tw-bg-opacity: 1;background-color:rgb(224 224 224 / var(--tw-bg-opacity))}#WGS .btn-wgs-gray:hover:not(:disabled):where(.wg-dark,.wg-dark *),.WGS_BS .btn-wgs-gray:hover:not(:disabled):where(.wg-dark,.wg-dark *){--tw-bg-opacity: 1;background-color:rgb(70 70 70 / var(--tw-bg-opacity))}#WGS .btn-wgs-black,.WGS_BS .btn-wgs-black{--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#WGS .btn-wgs-black:where(.wg-dark,.wg-dark *),.WGS_BS .btn-wgs-black:where(.wg-dark,.wg-dark *){--tw-bg-opacity: 1;background-color:rgb(246 246 246 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}#WGS .btn-wgs-black:hover:not(:disabled),.WGS_BS .btn-wgs-black:hover:not(:disabled){--tw-bg-opacity: 1;background-color:rgb(70 70 70 / var(--tw-bg-opacity));--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}#WGS .bordered-bottom,.WGS_BS .bordered-bottom{border-bottom-width:1px;--tw-border-opacity: 1;border-color:rgb(246 246 246 / var(--tw-border-opacity))}#WGS .bordered-bottom:where(.wg-dark,.wg-dark *),.WGS_BS .bordered-bottom:where(.wg-dark,.wg-dark *){--tw-border-opacity: 1;border-color:rgb(28 28 28 / var(--tw-border-opacity))}#WGS .custom-wgs-bottom-sheet>.wgs-bottom-sheet__content,.WGS_BS .custom-wgs-bottom-sheet>.wgs-bottom-sheet__content{max-width:100%;border-top-left-radius:24px;border-top-right-radius:24px;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}#WGS .custom-wgs-bottom-sheet>.wgs-bottom-sheet__content:where(.wg-dark,.wg-dark *),.WGS_BS .custom-wgs-bottom-sheet>.wgs-bottom-sheet__content:where(.wg-dark,.wg-dark *){border-color:rgb(255 255 255 / var(--tw-border-opacity));--tw-border-opacity: .2;--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}#WGS .custom-wgs-bottom-sheet-full>.wgs-bottom-sheet__content,.WGS_BS .custom-wgs-bottom-sheet-full>.wgs-bottom-sheet__content{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}#WGS .custom-wgs-bottom-sheet-full>.wgs-bottom-sheet__content:where(.wg-dark,.wg-dark *),.WGS_BS .custom-wgs-bottom-sheet-full>.wgs-bottom-sheet__content:where(.wg-dark,.wg-dark *){--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}#WGS .custom-wgs-bottom-sheet-full>.wgs-bottom-sheet__content,.WGS_BS .custom-wgs-bottom-sheet-full>.wgs-bottom-sheet__content{max-height:100vh!important;height:100vh!important;border-radius:0!important}#WGS .h1,.WGS_BS .h1{font-size:26px;font-style:normal;font-weight:800;line-height:30px;letter-spacing:.26px;text-transform:uppercase}#WGS .h2,.WGS_BS .h2{font-size:22px;font-style:normal;font-weight:700;line-height:26px;letter-spacing:-.33px}#WGS .wg-input,.WGS_BS .wg-input{height:52px;border-radius:10px;border-width:1px;--tw-border-opacity: 1;border-color:rgb(246 246 246 / var(--tw-border-opacity));--tw-bg-opacity: 1;background-color:rgb(246 246 246 / var(--tw-bg-opacity));padding:.75rem 1rem;font-size:16px;line-height:24px;font-weight:500;--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity))}#WGS .wg-input:focus-visible,.WGS_BS .wg-input:focus-visible{outline:2px solid transparent;outline-offset:2px}#WGS .wg-input:focus,.WGS_BS .wg-input:focus{--tw-border-opacity: 1;border-color:rgb(255 255 255 / var(--tw-border-opacity));outline:2px solid transparent;outline-offset:2px}#WGS .wg-input input.input::-moz-placeholder,#WGS .wg-input .input input::-moz-placeholder,.WGS_BS .wg-input input.input::-moz-placeholder,.WGS_BS .wg-input .input input::-moz-placeholder{wg-font-weight:400!important;color:wg-text-gray-900}#WGS .wg-input input.input::placeholder,#WGS .wg-input .input input::placeholder,.WGS_BS .wg-input input.input::placeholder,.WGS_BS .wg-input .input input::placeholder{wg-font-weight:400!important;color:wg-text-gray-900}#WGS .wg-fix-ios-bs,.WGS_BS .wg-fix-ios-bs{max-height:calc(var(--tg-viewport-stable-height, 100%) + 1px)}#WGS .wg-fix-ios-bs .wgs-bottom-sheet__content,.WGS_BS .wg-fix-ios-bs .wgs-bottom-sheet__content{max-height:calc(var(--tg-viewport-stable-height, 100vh) * .9)}.wg-body-lock{max-height:calc(var(--tg-viewport-stable-height, 100vh))!important;overflow:hidden}.dark\\:\\!wg-bg-black:where(.wg-dark,.wg-dark *){--tw-bg-opacity: 1 !important;background-color:rgb(0 0 0 / var(--tw-bg-opacity))!important}.dark\\:wg-fill-gray-500:where(.wg-dark,.wg-dark *){fill:#acacac}.dark\\:\\!wg-text-white:where(.wg-dark,.wg-dark *){--tw-text-opacity: 1 !important;color:rgb(255 255 255 / var(--tw-text-opacity))!important}.dark\\:wg-text-gray-300:where(.wg-dark,.wg-dark *){--tw-text-opacity: 1;color:rgb(141 141 141 / var(--tw-text-opacity))}.dark\\:wg-text-gray-500:where(.wg-dark,.wg-dark *){--tw-text-opacity: 1;color:rgb(172 172 172 / var(--tw-text-opacity))}.dark\\:wg-text-white:where(.wg-dark,.wg-dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.wgs-bottom-sheet[data-v-b01d37cb]{z-index:1000;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;position:fixed;top:0;left:0;right:0;bottom:0;transition:visibility var(--247448d8);will-change:transform}.wgs-bottom-sheet[data-v-b01d37cb] *{box-sizing:border-box}.wgs-bottom-sheet[aria-hidden=false][data-v-b01d37cb]{visibility:visible}.wgs-bottom-sheet[aria-hidden=true][data-v-b01d37cb]{visibility:hidden;pointer-events:none}.wgs-bottom-sheet__overlay[data-v-b01d37cb]{position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1;background-color:rgb(0 0 0 / var(--tw-bg-opacity));--tw-bg-opacity: .5}.wgs-bottom-sheet__overlay[data-v-b01d37cb]:where(.wg-dark,.wg-dark *){--tw-bg-opacity: .8}.wgs-bottom-sheet__content[data-v-b01d37cb]{display:flex;flex-direction:column;border-radius:24px 24px 0 0;--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.wgs-bottom-sheet__content[data-v-b01d37cb]:where(.wg-dark,.wg-dark *){--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.wgs-bottom-sheet__content[data-v-b01d37cb]{padding:var(--313bdcb7);overflow-y:hidden;transform:translate3d(0,var(--10f7dbce),0);height:var(--0071483d);max-width:var(--85c8fbe6);width:100%;box-sizing:border-box;pointer-events:all;max-height:90vh}.wgs-bottom-sheet__content--fullscreen[data-v-b01d37cb]{border-radius:0}.wgs-bottom-sheet__content[data-v-b01d37cb]:not(.wgs-bottom-sheet__content--dragging){transition:var(--247448d8) ease}.wgs-bottom-sheet__draggable-area[data-v-b01d37cb]{width:100%;margin:auto;padding:16px;cursor:grab}.wgs-bottom-sheet__draggable-thumb[data-v-b01d37cb]{width:40px;height:4px;background:#333;border-radius:8px;margin:0 auto}.wgs-bottom-sheet__main[data-v-b01d37cb]{display:flex;flex-direction:column;overflow-y:scroll;box-sizing:border-box;-webkit-overflow-scrolling:touch;touch-action:auto!important}.wgs-bottom-sheet__main[data-v-b01d37cb]::-webkit-scrollbar{height:8px;width:0px}.wgs-bottom-sheet__main[data-v-b01d37cb]::-webkit-scrollbar-corner{display:none}.wgs-bottom-sheet__main[data-v-b01d37cb]:hover::-webkit-scrollbar-thumb{background-color:#0003;border-radius:8px}.wgs-bottom-sheet__main[data-v-b01d37cb]::-webkit-scrollbar-thumb{background-color:#0000}.wgs-bottom-sheet__footer[data-v-b01d37cb]:empty{display:none}.wgs-bottom-sheet .wgs-bottom-sheet[data-v-b01d37cb]{z-index:1001}.v-enter-active[data-v-b01d37cb],.v-leave-active[data-v-b01d37cb]{transition:opacity var(--247448d8) ease}.v-enter-from[data-v-b01d37cb],.v-leave-to[data-v-b01d37cb]{opacity:0}svg.white path[data-v-479a6fc7]{fill:#fff!important}.loader[data-v-88f0cbdc]{width:32px;height:32px;border:3px solid #FFF;border-bottom-color:transparent;border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation-88f0cbdc 1s linear infinite}@keyframes rotation-88f0cbdc{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
var li = (e) => {
  throw TypeError(e);
};
var ai = (e, t, n) => t.has(e) || li("Cannot " + n);
var wn = (e, t, n) => (ai(e, t, "read from private field"), n ? n.call(e) : t.get(e)), wr = (e, t, n) => t.has(e) ? li("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), yr = (e, t, n, s) => (ai(e, t, "write to private field"), s ? s.call(e, n) : t.set(e, n), n);
/**
* @vue/shared v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function So(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e.split(",")) t[n] = 1;
  return (n) => n in t;
}
const oe = {}, Ln = [], gt = () => {
}, Qc = () => !1, zs = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), vo = (e) => e.startsWith("onUpdate:"), Ee = Object.assign, Co = (e, t) => {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}, eu = Object.prototype.hasOwnProperty, ce = (e, t) => eu.call(e, t), G = Array.isArray, kn = (e) => Zs(e) === "[object Map]", Wl = (e) => Zs(e) === "[object Set]", J = (e) => typeof e == "function", ye = (e) => typeof e == "string", Ot = (e) => typeof e == "symbol", me = (e) => e !== null && typeof e == "object", Bl = (e) => (me(e) || J(e)) && J(e.then) && J(e.catch), jl = Object.prototype.toString, Zs = (e) => jl.call(e), tu = (e) => Zs(e).slice(8, -1), Kl = (e) => Zs(e) === "[object Object]", Lo = (e) => ye(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Gn = /* @__PURE__ */ So(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Qs = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, nu = /-(\w)/g, tt = Qs(
  (e) => e.replace(nu, (t, n) => n ? n.toUpperCase() : "")
), su = /\B([A-Z])/g, Gt = Qs(
  (e) => e.replace(su, "-$1").toLowerCase()
), er = Qs((e) => e.charAt(0).toUpperCase() + e.slice(1)), Er = Qs(
  (e) => e ? `on${er(e)}` : ""
), je = (e, t) => !Object.is(e, t), As = (e, ...t) => {
  for (let n = 0; n < e.length; n++)
    e[n](...t);
}, Gl = (e, t, n, s = !1) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: n
  });
}, Vr = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}, ru = (e) => {
  const t = ye(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let ci;
const tr = () => ci || (ci = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ko(e) {
  if (G(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const s = e[n], r = ye(s) ? au(s) : ko(s);
      if (r)
        for (const o in r)
          t[o] = r[o];
    }
    return t;
  } else if (ye(e) || me(e))
    return e;
}
const ou = /;(?![^(]*\))/g, iu = /:([^]+)/, lu = /\/\*[^]*?\*\//g;
function au(e) {
  const t = {};
  return e.replace(lu, "").split(ou).forEach((n) => {
    if (n) {
      const s = n.split(iu);
      s.length > 1 && (t[s[0].trim()] = s[1].trim());
    }
  }), t;
}
function He(e) {
  let t = "";
  if (ye(e))
    t = e;
  else if (G(e))
    for (let n = 0; n < e.length; n++) {
      const s = He(e[n]);
      s && (t += s + " ");
    }
  else if (me(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim();
}
const cu = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", uu = /* @__PURE__ */ So(cu);
function ql(e) {
  return !!e || e === "";
}
const Yl = (e) => !!(e && e.__v_isRef === !0), Ce = (e) => ye(e) ? e : e == null ? "" : G(e) || me(e) && (e.toString === jl || !J(e.toString)) ? Yl(e) ? Ce(e.value) : JSON.stringify(e, Jl, 2) : String(e), Jl = (e, t) => Yl(t) ? Jl(e, t.value) : kn(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (n, [s, r], o) => (n[Tr(s, o) + " =>"] = r, n),
    {}
  )
} : Wl(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((n) => Tr(n))
} : Ot(t) ? Tr(t) : me(t) && !G(t) && !Kl(t) ? String(t) : t, Tr = (e, t = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Ot(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  );
};
/**
* @vue/reactivity v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let De;
class Xl {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = De, !t && De && (this.index = (De.scopes || (De.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const n = De;
      try {
        return De = this, t();
      } finally {
        De = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    De = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    De = this.parent;
  }
  stop(t) {
    if (this._active) {
      let n, s;
      for (n = 0, s = this.effects.length; n < s; n++)
        this.effects[n].stop();
      for (n = 0, s = this.cleanups.length; n < s; n++)
        this.cleanups[n]();
      if (this.scopes)
        for (n = 0, s = this.scopes.length; n < s; n++)
          this.scopes[n].stop(!0);
      if (!this.detached && this.parent && !t) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function Ao(e) {
  return new Xl(e);
}
function zl() {
  return De;
}
function fu(e, t = !1) {
  De && De.cleanups.push(e);
}
let he;
const Sr = /* @__PURE__ */ new WeakSet();
class Zl {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, De && De.active && De.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Sr.has(this) && (Sr.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || ea(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, ui(this), ta(this);
    const t = he, n = at;
    he = this, at = !0;
    try {
      return this.fn();
    } finally {
      na(this), he = t, at = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        Ro(t);
      this.deps = this.depsTail = void 0, ui(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Sr.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Wr(this) && this.run();
  }
  get dirty() {
    return Wr(this);
  }
}
let Ql = 0, qn, Yn;
function ea(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = Yn, Yn = e;
    return;
  }
  e.next = qn, qn = e;
}
function Oo() {
  Ql++;
}
function Io() {
  if (--Ql > 0)
    return;
  if (Yn) {
    let t = Yn;
    for (Yn = void 0; t; ) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n;
    }
  }
  let e;
  for (; qn; ) {
    let t = qn;
    for (qn = void 0; t; ) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (s) {
          e || (e = s);
        }
      t = n;
    }
  }
  if (e) throw e;
}
function ta(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function na(e) {
  let t, n = e.depsTail, s = n;
  for (; s; ) {
    const r = s.prevDep;
    s.version === -1 ? (s === n && (n = r), Ro(s), du(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r;
  }
  e.deps = t, e.depsTail = n;
}
function Wr(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (sa(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function sa(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Qn))
    return;
  e.globalVersion = Qn;
  const t = e.dep;
  if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !Wr(e)) {
    e.flags &= -3;
    return;
  }
  const n = he, s = at;
  he = e, at = !0;
  try {
    ta(e);
    const r = e.fn(e._value);
    (t.version === 0 || je(r, e._value)) && (e._value = r, t.version++);
  } catch (r) {
    throw t.version++, r;
  } finally {
    he = n, at = s, na(e), e.flags &= -3;
  }
}
function Ro(e, t = !1) {
  const { dep: n, prevSub: s, nextSub: r } = e;
  if (s && (s.nextSub = r, e.prevSub = void 0), r && (r.prevSub = s, e.nextSub = void 0), n.subs === e && (n.subs = s, !s && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      Ro(o, !0);
  }
  !t && !--n.sc && n.map && n.map.delete(n.key);
}
function du(e) {
  const { prevDep: t, nextDep: n } = e;
  t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0);
}
let at = !0;
const ra = [];
function qt() {
  ra.push(at), at = !1;
}
function Yt() {
  const e = ra.pop();
  at = e === void 0 ? !0 : e;
}
function ui(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const n = he;
    he = void 0;
    try {
      t();
    } finally {
      he = n;
    }
  }
}
let Qn = 0;
class hu {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class nr {
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0;
  }
  track(t) {
    if (!he || !at || he === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== he)
      n = this.activeLink = new hu(he, this), he.deps ? (n.prevDep = he.depsTail, he.depsTail.nextDep = n, he.depsTail = n) : he.deps = he.depsTail = n, oa(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const s = n.nextDep;
      s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = he.depsTail, n.nextDep = void 0, he.depsTail.nextDep = n, he.depsTail = n, he.deps === n && (he.deps = s);
    }
    return n;
  }
  trigger(t) {
    this.version++, Qn++, this.notify(t);
  }
  notify(t) {
    Oo();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      Io();
    }
  }
}
function oa(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let s = t.deps; s; s = s.nextDep)
        oa(s);
    }
    const n = e.dep.subs;
    n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e;
  }
}
const Ms = /* @__PURE__ */ new WeakMap(), un = Symbol(
  ""
), Br = Symbol(
  ""
), es = Symbol(
  ""
);
function Ne(e, t, n) {
  if (at && he) {
    let s = Ms.get(e);
    s || Ms.set(e, s = /* @__PURE__ */ new Map());
    let r = s.get(n);
    r || (s.set(n, r = new nr()), r.map = s, r.key = n), r.track();
  }
}
function vt(e, t, n, s, r, o) {
  const i = Ms.get(e);
  if (!i) {
    Qn++;
    return;
  }
  const l = (a) => {
    a && a.trigger();
  };
  if (Oo(), t === "clear")
    i.forEach(l);
  else {
    const a = G(e), c = a && Lo(n);
    if (a && n === "length") {
      const u = Number(s);
      i.forEach((f, p) => {
        (p === "length" || p === es || !Ot(p) && p >= u) && l(f);
      });
    } else
      switch ((n !== void 0 || i.has(void 0)) && l(i.get(n)), c && l(i.get(es)), t) {
        case "add":
          a ? c && l(i.get("length")) : (l(i.get(un)), kn(e) && l(i.get(Br)));
          break;
        case "delete":
          a || (l(i.get(un)), kn(e) && l(i.get(Br)));
          break;
        case "set":
          kn(e) && l(i.get(un));
          break;
      }
  }
  Io();
}
function pu(e, t) {
  const n = Ms.get(e);
  return n && n.get(t);
}
function yn(e) {
  const t = re(e);
  return t === e ? t : (Ne(t, "iterate", es), it(e) ? t : t.map(xe));
}
function sr(e) {
  return Ne(e = re(e), "iterate", es), e;
}
const mu = {
  __proto__: null,
  [Symbol.iterator]() {
    return vr(this, Symbol.iterator, xe);
  },
  concat(...e) {
    return yn(this).concat(
      ...e.map((t) => G(t) ? yn(t) : t)
    );
  },
  entries() {
    return vr(this, "entries", (e) => (e[1] = xe(e[1]), e));
  },
  every(e, t) {
    return yt(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return yt(this, "filter", e, t, (n) => n.map(xe), arguments);
  },
  find(e, t) {
    return yt(this, "find", e, t, xe, arguments);
  },
  findIndex(e, t) {
    return yt(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return yt(this, "findLast", e, t, xe, arguments);
  },
  findLastIndex(e, t) {
    return yt(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return yt(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return Cr(this, "includes", e);
  },
  indexOf(...e) {
    return Cr(this, "indexOf", e);
  },
  join(e) {
    return yn(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return Cr(this, "lastIndexOf", e);
  },
  map(e, t) {
    return yt(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return Hn(this, "pop");
  },
  push(...e) {
    return Hn(this, "push", e);
  },
  reduce(e, ...t) {
    return fi(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return fi(this, "reduceRight", e, t);
  },
  shift() {
    return Hn(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return yt(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return Hn(this, "splice", e);
  },
  toReversed() {
    return yn(this).toReversed();
  },
  toSorted(e) {
    return yn(this).toSorted(e);
  },
  toSpliced(...e) {
    return yn(this).toSpliced(...e);
  },
  unshift(...e) {
    return Hn(this, "unshift", e);
  },
  values() {
    return vr(this, "values", xe);
  }
};
function vr(e, t, n) {
  const s = sr(e), r = s[t]();
  return s !== e && !it(e) && (r._next = r.next, r.next = () => {
    const o = r._next();
    return o.value && (o.value = n(o.value)), o;
  }), r;
}
const gu = Array.prototype;
function yt(e, t, n, s, r, o) {
  const i = sr(e), l = i !== e && !it(e), a = i[t];
  if (a !== gu[t]) {
    const f = a.apply(e, o);
    return l ? xe(f) : f;
  }
  let c = n;
  i !== e && (l ? c = function(f, p) {
    return n.call(this, xe(f), p, e);
  } : n.length > 2 && (c = function(f, p) {
    return n.call(this, f, p, e);
  }));
  const u = a.call(i, c, s);
  return l && r ? r(u) : u;
}
function fi(e, t, n, s) {
  const r = sr(e);
  let o = n;
  return r !== e && (it(e) ? n.length > 3 && (o = function(i, l, a) {
    return n.call(this, i, l, a, e);
  }) : o = function(i, l, a) {
    return n.call(this, i, xe(l), a, e);
  }), r[t](o, ...s);
}
function Cr(e, t, n) {
  const s = re(e);
  Ne(s, "iterate", es);
  const r = s[t](...n);
  return (r === -1 || r === !1) && Po(n[0]) ? (n[0] = re(n[0]), s[t](...n)) : r;
}
function Hn(e, t, n = []) {
  qt(), Oo();
  const s = re(e)[t].apply(e, n);
  return Io(), Yt(), s;
}
const _u = /* @__PURE__ */ So("__proto__,__v_isRef,__isVue"), ia = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Ot)
);
function bu(e) {
  Ot(e) || (e = String(e));
  const t = re(this);
  return Ne(t, "has", e), t.hasOwnProperty(e);
}
class la {
  constructor(t = !1, n = !1) {
    this._isReadonly = t, this._isShallow = n;
  }
  get(t, n, s) {
    const r = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return s === (r ? o ? Au : fa : o ? ua : ca).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0;
    const i = G(t);
    if (!r) {
      let a;
      if (i && (a = mu[n]))
        return a;
      if (n === "hasOwnProperty")
        return bu;
    }
    const l = Reflect.get(
      t,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      we(t) ? t : s
    );
    return (Ot(n) ? ia.has(n) : _u(n)) || (r || Ne(t, "get", n), o) ? l : we(l) ? i && Lo(n) ? l : l.value : me(l) ? r ? da(l) : jt(l) : l;
  }
}
class aa extends la {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, n, s, r) {
    let o = t[n];
    if (!this._isShallow) {
      const a = hn(o);
      if (!it(s) && !hn(s) && (o = re(o), s = re(s)), !G(t) && we(o) && !we(s))
        return a ? !1 : (o.value = s, !0);
    }
    const i = G(t) && Lo(n) ? Number(n) < t.length : ce(t, n), l = Reflect.set(
      t,
      n,
      s,
      we(t) ? t : r
    );
    return t === re(r) && (i ? je(s, o) && vt(t, "set", n, s) : vt(t, "add", n, s)), l;
  }
  deleteProperty(t, n) {
    const s = ce(t, n);
    t[n];
    const r = Reflect.deleteProperty(t, n);
    return r && s && vt(t, "delete", n, void 0), r;
  }
  has(t, n) {
    const s = Reflect.has(t, n);
    return (!Ot(n) || !ia.has(n)) && Ne(t, "has", n), s;
  }
  ownKeys(t) {
    return Ne(
      t,
      "iterate",
      G(t) ? "length" : un
    ), Reflect.ownKeys(t);
  }
}
class wu extends la {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, n) {
    return !0;
  }
  deleteProperty(t, n) {
    return !0;
  }
}
const yu = /* @__PURE__ */ new aa(), Eu = /* @__PURE__ */ new wu(), Tu = /* @__PURE__ */ new aa(!0);
const jr = (e) => e, Es = (e) => Reflect.getPrototypeOf(e);
function Su(e, t, n) {
  return function(...s) {
    const r = this.__v_raw, o = re(r), i = kn(o), l = e === "entries" || e === Symbol.iterator && i, a = e === "keys" && i, c = r[e](...s), u = n ? jr : t ? Kr : xe;
    return !t && Ne(
      o,
      "iterate",
      a ? Br : un
    ), {
      // iterator protocol
      next() {
        const { value: f, done: p } = c.next();
        return p ? { value: f, done: p } : {
          value: l ? [u(f[0]), u(f[1])] : u(f),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ts(e) {
  return function(...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function vu(e, t) {
  const n = {
    get(r) {
      const o = this.__v_raw, i = re(o), l = re(r);
      e || (je(r, l) && Ne(i, "get", r), Ne(i, "get", l));
      const { has: a } = Es(i), c = t ? jr : e ? Kr : xe;
      if (a.call(i, r))
        return c(o.get(r));
      if (a.call(i, l))
        return c(o.get(l));
      o !== i && o.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !e && Ne(re(r), "iterate", un), Reflect.get(r, "size", r);
    },
    has(r) {
      const o = this.__v_raw, i = re(o), l = re(r);
      return e || (je(r, l) && Ne(i, "has", r), Ne(i, "has", l)), r === l ? o.has(r) : o.has(r) || o.has(l);
    },
    forEach(r, o) {
      const i = this, l = i.__v_raw, a = re(l), c = t ? jr : e ? Kr : xe;
      return !e && Ne(a, "iterate", un), l.forEach((u, f) => r.call(o, c(u), c(f), i));
    }
  };
  return Ee(
    n,
    e ? {
      add: Ts("add"),
      set: Ts("set"),
      delete: Ts("delete"),
      clear: Ts("clear")
    } : {
      add(r) {
        !t && !it(r) && !hn(r) && (r = re(r));
        const o = re(this);
        return Es(o).has.call(o, r) || (o.add(r), vt(o, "add", r, r)), this;
      },
      set(r, o) {
        !t && !it(o) && !hn(o) && (o = re(o));
        const i = re(this), { has: l, get: a } = Es(i);
        let c = l.call(i, r);
        c || (r = re(r), c = l.call(i, r));
        const u = a.call(i, r);
        return i.set(r, o), c ? je(o, u) && vt(i, "set", r, o) : vt(i, "add", r, o), this;
      },
      delete(r) {
        const o = re(this), { has: i, get: l } = Es(o);
        let a = i.call(o, r);
        a || (r = re(r), a = i.call(o, r)), l && l.call(o, r);
        const c = o.delete(r);
        return a && vt(o, "delete", r, void 0), c;
      },
      clear() {
        const r = re(this), o = r.size !== 0, i = r.clear();
        return o && vt(
          r,
          "clear",
          void 0,
          void 0
        ), i;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = Su(r, e, t);
  }), n;
}
function No(e, t) {
  const n = vu(e, t);
  return (s, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get(
    ce(n, r) && r in s ? n : s,
    r,
    o
  );
}
const Cu = {
  get: /* @__PURE__ */ No(!1, !1)
}, Lu = {
  get: /* @__PURE__ */ No(!1, !0)
}, ku = {
  get: /* @__PURE__ */ No(!0, !1)
};
const ca = /* @__PURE__ */ new WeakMap(), ua = /* @__PURE__ */ new WeakMap(), fa = /* @__PURE__ */ new WeakMap(), Au = /* @__PURE__ */ new WeakMap();
function Ou(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Iu(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Ou(tu(e));
}
function jt(e) {
  return hn(e) ? e : xo(
    e,
    !1,
    yu,
    Cu,
    ca
  );
}
function Ru(e) {
  return xo(
    e,
    !1,
    Tu,
    Lu,
    ua
  );
}
function da(e) {
  return xo(
    e,
    !0,
    Eu,
    ku,
    fa
  );
}
function xo(e, t, n, s, r) {
  if (!me(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const o = r.get(e);
  if (o)
    return o;
  const i = Iu(e);
  if (i === 0)
    return e;
  const l = new Proxy(
    e,
    i === 2 ? s : n
  );
  return r.set(e, l), l;
}
function Wt(e) {
  return hn(e) ? Wt(e.__v_raw) : !!(e && e.__v_isReactive);
}
function hn(e) {
  return !!(e && e.__v_isReadonly);
}
function it(e) {
  return !!(e && e.__v_isShallow);
}
function Po(e) {
  return e ? !!e.__v_raw : !1;
}
function re(e) {
  const t = e && e.__v_raw;
  return t ? re(t) : e;
}
function Fo(e) {
  return !ce(e, "__v_skip") && Object.isExtensible(e) && Gl(e, "__v_skip", !0), e;
}
const xe = (e) => me(e) ? jt(e) : e, Kr = (e) => me(e) ? da(e) : e;
function we(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function ue(e) {
  return pa(e, !1);
}
function ha(e) {
  return pa(e, !0);
}
function pa(e, t) {
  return we(e) ? e : new Nu(e, t);
}
class Nu {
  constructor(t, n) {
    this.dep = new nr(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : re(t), this._value = n ? t : xe(t), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(t) {
    const n = this._rawValue, s = this.__v_isShallow || it(t) || hn(t);
    t = s ? t : re(t), je(t, n) && (this._rawValue = t, this._value = s ? t : xe(t), this.dep.trigger());
  }
}
function sn(e) {
  return we(e) ? e.value : e;
}
const xu = {
  get: (e, t, n) => t === "__v_raw" ? e : sn(Reflect.get(e, t, n)),
  set: (e, t, n, s) => {
    const r = e[t];
    return we(r) && !we(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s);
  }
};
function ma(e) {
  return Wt(e) ? e : new Proxy(e, xu);
}
class Pu {
  constructor(t) {
    this.__v_isRef = !0, this._value = void 0;
    const n = this.dep = new nr(), { get: s, set: r } = t(n.track.bind(n), n.trigger.bind(n));
    this._get = s, this._set = r;
  }
  get value() {
    return this._value = this._get();
  }
  set value(t) {
    this._set(t);
  }
}
function Fu(e) {
  return new Pu(e);
}
function Du(e) {
  const t = G(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = $u(e, n);
  return t;
}
class Mu {
  constructor(t, n, s) {
    this._object = t, this._key = n, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return pu(re(this._object), this._key);
  }
}
function $u(e, t, n) {
  const s = e[t];
  return we(s) ? s : new Mu(e, t, n);
}
class Uu {
  constructor(t, n, s) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new nr(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Qn - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    he !== this)
      return ea(this, !0), !0;
  }
  get value() {
    const t = this.dep.track();
    return sa(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter && this.setter(t);
  }
}
function Hu(e, t, n = !1) {
  let s, r;
  return J(e) ? s = e : (s = e.get, r = e.set), new Uu(s, r, n);
}
const Ss = {}, $s = /* @__PURE__ */ new WeakMap();
let rn;
function Vu(e, t = !1, n = rn) {
  if (n) {
    let s = $s.get(n);
    s || $s.set(n, s = []), s.push(e);
  }
}
function Wu(e, t, n = oe) {
  const { immediate: s, deep: r, once: o, scheduler: i, augmentJob: l, call: a } = n, c = (E) => r ? E : it(E) || r === !1 || r === 0 ? Ct(E, 1) : Ct(E);
  let u, f, p, b, _ = !1, T = !1;
  if (we(e) ? (f = () => e.value, _ = it(e)) : Wt(e) ? (f = () => c(e), _ = !0) : G(e) ? (T = !0, _ = e.some((E) => Wt(E) || it(E)), f = () => e.map((E) => {
    if (we(E))
      return E.value;
    if (Wt(E))
      return c(E);
    if (J(E))
      return a ? a(E, 2) : E();
  })) : J(e) ? t ? f = a ? () => a(e, 2) : e : f = () => {
    if (p) {
      qt();
      try {
        p();
      } finally {
        Yt();
      }
    }
    const E = rn;
    rn = u;
    try {
      return a ? a(e, 3, [b]) : e(b);
    } finally {
      rn = E;
    }
  } : f = gt, t && r) {
    const E = f, O = r === !0 ? 1 / 0 : r;
    f = () => Ct(E(), O);
  }
  const C = zl(), g = () => {
    u.stop(), C && Co(C.effects, u);
  };
  if (o && t) {
    const E = t;
    t = (...O) => {
      E(...O), g();
    };
  }
  let v = T ? new Array(e.length).fill(Ss) : Ss;
  const L = (E) => {
    if (!(!(u.flags & 1) || !u.dirty && !E))
      if (t) {
        const O = u.run();
        if (r || _ || (T ? O.some((F, N) => je(F, v[N])) : je(O, v))) {
          p && p();
          const F = rn;
          rn = u;
          try {
            const N = [
              O,
              // pass undefined as the old value when it's changed for the first time
              v === Ss ? void 0 : T && v[0] === Ss ? [] : v,
              b
            ];
            a ? a(t, 3, N) : (
              // @ts-expect-error
              t(...N)
            ), v = O;
          } finally {
            rn = F;
          }
        }
      } else
        u.run();
  };
  return l && l(L), u = new Zl(f), u.scheduler = i ? () => i(L, !1) : L, b = (E) => Vu(E, !1, u), p = u.onStop = () => {
    const E = $s.get(u);
    if (E) {
      if (a)
        a(E, 4);
      else
        for (const O of E) O();
      $s.delete(u);
    }
  }, t ? s ? L(!0) : v = u.run() : i ? i(L.bind(null, !0), !0) : u.run(), g.pause = u.pause.bind(u), g.resume = u.resume.bind(u), g.stop = g, g;
}
function Ct(e, t = 1 / 0, n) {
  if (t <= 0 || !me(e) || e.__v_skip || (n = n || /* @__PURE__ */ new Set(), n.has(e)))
    return e;
  if (n.add(e), t--, we(e))
    Ct(e.value, t, n);
  else if (G(e))
    for (let s = 0; s < e.length; s++)
      Ct(e[s], t, n);
  else if (Wl(e) || kn(e))
    e.forEach((s) => {
      Ct(s, t, n);
    });
  else if (Kl(e)) {
    for (const s in e)
      Ct(e[s], t, n);
    for (const s of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, s) && Ct(e[s], t, n);
  }
  return e;
}
/**
* @vue/runtime-core v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ds(e, t, n, s) {
  try {
    return s ? e(...s) : e();
  } catch (r) {
    rr(r, t, n);
  }
}
function ct(e, t, n, s) {
  if (J(e)) {
    const r = ds(e, t, n, s);
    return r && Bl(r) && r.catch((o) => {
      rr(o, t, n);
    }), r;
  }
  if (G(e)) {
    const r = [];
    for (let o = 0; o < e.length; o++)
      r.push(ct(e[o], t, n, s));
    return r;
  }
}
function rr(e, t, n, s = !0) {
  const r = t ? t.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: i } = t && t.appContext.config || oe;
  if (t) {
    let l = t.parent;
    const a = t.proxy, c = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const u = l.ec;
      if (u) {
        for (let f = 0; f < u.length; f++)
          if (u[f](e, a, c) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      qt(), ds(o, null, 10, [
        e,
        a,
        c
      ]), Yt();
      return;
    }
  }
  Bu(e, n, r, s, i);
}
function Bu(e, t, n, s = !0, r = !1) {
  if (r)
    throw e;
  console.error(e);
}
const Me = [];
let pt = -1;
const An = [];
let $t = null, Tn = 0;
const ga = /* @__PURE__ */ Promise.resolve();
let Us = null;
function ln(e) {
  const t = Us || ga;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function ju(e) {
  let t = pt + 1, n = Me.length;
  for (; t < n; ) {
    const s = t + n >>> 1, r = Me[s], o = ts(r);
    o < e || o === e && r.flags & 2 ? t = s + 1 : n = s;
  }
  return t;
}
function Do(e) {
  if (!(e.flags & 1)) {
    const t = ts(e), n = Me[Me.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= ts(n) ? Me.push(e) : Me.splice(ju(t), 0, e), e.flags |= 1, _a();
  }
}
function _a() {
  Us || (Us = ga.then(wa));
}
function Ku(e) {
  G(e) ? An.push(...e) : $t && e.id === -1 ? $t.splice(Tn + 1, 0, e) : e.flags & 1 || (An.push(e), e.flags |= 1), _a();
}
function di(e, t, n = pt + 1) {
  for (; n < Me.length; n++) {
    const s = Me[n];
    if (s && s.flags & 2) {
      if (e && s.id !== e.uid)
        continue;
      Me.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2);
    }
  }
}
function ba(e) {
  if (An.length) {
    const t = [...new Set(An)].sort(
      (n, s) => ts(n) - ts(s)
    );
    if (An.length = 0, $t) {
      $t.push(...t);
      return;
    }
    for ($t = t, Tn = 0; Tn < $t.length; Tn++) {
      const n = $t[Tn];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    $t = null, Tn = 0;
  }
}
const ts = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function wa(e) {
  try {
    for (pt = 0; pt < Me.length; pt++) {
      const t = Me[pt];
      t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), ds(
        t,
        t.i,
        t.i ? 15 : 14
      ), t.flags & 4 || (t.flags &= -2));
    }
  } finally {
    for (; pt < Me.length; pt++) {
      const t = Me[pt];
      t && (t.flags &= -2);
    }
    pt = -1, Me.length = 0, ba(), Us = null, (Me.length || An.length) && wa();
  }
}
let Ae = null, ya = null;
function Hs(e) {
  const t = Ae;
  return Ae = e, ya = e && e.type.__scopeId || null, t;
}
function Ke(e, t = Ae, n) {
  if (!t || e._n)
    return e;
  const s = (...r) => {
    s._d && vi(-1);
    const o = Hs(t);
    let i;
    try {
      i = e(...r);
    } finally {
      Hs(o), s._d && vi(1);
    }
    return i;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function Ea(e, t) {
  if (Ae === null)
    return e;
  const n = cr(Ae), s = e.dirs || (e.dirs = []);
  for (let r = 0; r < t.length; r++) {
    let [o, i, l, a = oe] = t[r];
    o && (J(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Ct(i), s.push({
      dir: o,
      instance: n,
      value: i,
      oldValue: void 0,
      arg: l,
      modifiers: a
    }));
  }
  return e;
}
function Qt(e, t, n, s) {
  const r = e.dirs, o = t && t.dirs;
  for (let i = 0; i < r.length; i++) {
    const l = r[i];
    o && (l.oldValue = o[i].value);
    let a = l.dir[s];
    a && (qt(), ct(a, n, 8, [
      e.el,
      l,
      e,
      t
    ]), Yt());
  }
}
const Ta = Symbol("_vte"), Sa = (e) => e.__isTeleport, Jn = (e) => e && (e.disabled || e.disabled === ""), Gu = (e) => e && (e.defer || e.defer === ""), hi = (e) => typeof SVGElement < "u" && e instanceof SVGElement, pi = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, Gr = (e, t) => {
  const n = e && e.to;
  return ye(n) ? t ? t(n) : null : n;
}, qu = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, t, n, s, r, o, i, l, a, c) {
    const {
      mc: u,
      pc: f,
      pbc: p,
      o: { insert: b, querySelector: _, createText: T, createComment: C }
    } = c, g = Jn(t.props);
    let { shapeFlag: v, children: L, dynamicChildren: E } = t;
    if (e == null) {
      const O = t.el = T(""), F = t.anchor = T("");
      b(O, n, s), b(F, n, s);
      const N = (P, B) => {
        v & 16 && (r && r.isCE && (r.ce._teleportTarget = P), u(
          L,
          P,
          B,
          r,
          o,
          i,
          l,
          a
        ));
      }, H = () => {
        const P = t.target = Gr(t.props, _), B = va(P, t, T, b);
        P && (i !== "svg" && hi(P) ? i = "svg" : i !== "mathml" && pi(P) && (i = "mathml"), g || (N(P, B), Os(t, !1)));
      };
      g && (N(n, F), Os(t, !0)), Gu(t.props) ? Be(H, o) : H();
    } else {
      t.el = e.el, t.targetStart = e.targetStart;
      const O = t.anchor = e.anchor, F = t.target = e.target, N = t.targetAnchor = e.targetAnchor, H = Jn(e.props), P = H ? n : F, B = H ? O : N;
      if (i === "svg" || hi(F) ? i = "svg" : (i === "mathml" || pi(F)) && (i = "mathml"), E ? (p(
        e.dynamicChildren,
        E,
        P,
        r,
        o,
        i,
        l
      ), Ho(e, t, !0)) : a || f(
        e,
        t,
        P,
        B,
        r,
        o,
        i,
        l,
        !1
      ), g)
        H ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : vs(
          t,
          n,
          O,
          c,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const Y = t.target = Gr(
          t.props,
          _
        );
        Y && vs(
          t,
          Y,
          null,
          c,
          0
        );
      } else H && vs(
        t,
        F,
        N,
        c,
        1
      );
      Os(t, g);
    }
  },
  remove(e, t, n, { um: s, o: { remove: r } }, o) {
    const {
      shapeFlag: i,
      children: l,
      anchor: a,
      targetStart: c,
      targetAnchor: u,
      target: f,
      props: p
    } = e;
    if (f && (r(c), r(u)), o && r(a), i & 16) {
      const b = o || !Jn(p);
      for (let _ = 0; _ < l.length; _++) {
        const T = l[_];
        s(
          T,
          t,
          n,
          b,
          !!T.dynamicChildren
        );
      }
    }
  },
  move: vs,
  hydrate: Yu
};
function vs(e, t, n, { o: { insert: s }, m: r }, o = 2) {
  o === 0 && s(e.targetAnchor, t, n);
  const { el: i, anchor: l, shapeFlag: a, children: c, props: u } = e, f = o === 2;
  if (f && s(i, t, n), (!f || Jn(u)) && a & 16)
    for (let p = 0; p < c.length; p++)
      r(
        c[p],
        t,
        n,
        2
      );
  f && s(l, t, n);
}
function Yu(e, t, n, s, r, o, {
  o: { nextSibling: i, parentNode: l, querySelector: a, insert: c, createText: u }
}, f) {
  const p = t.target = Gr(
    t.props,
    a
  );
  if (p) {
    const b = Jn(t.props), _ = p._lpa || p.firstChild;
    if (t.shapeFlag & 16)
      if (b)
        t.anchor = f(
          i(e),
          t,
          l(e),
          n,
          s,
          r,
          o
        ), t.targetStart = _, t.targetAnchor = _ && i(_);
      else {
        t.anchor = i(e);
        let T = _;
        for (; T; ) {
          if (T && T.nodeType === 8) {
            if (T.data === "teleport start anchor")
              t.targetStart = T;
            else if (T.data === "teleport anchor") {
              t.targetAnchor = T, p._lpa = t.targetAnchor && i(t.targetAnchor);
              break;
            }
          }
          T = i(T);
        }
        t.targetAnchor || va(p, t, u, c), f(
          _ && i(_),
          t,
          p,
          n,
          s,
          r,
          o
        );
      }
    Os(t, b);
  }
  return t.anchor && i(t.anchor);
}
const Ju = qu;
function Os(e, t) {
  const n = e.ctx;
  if (n && n.ut) {
    let s, r;
    for (t ? (s = e.el, r = e.anchor) : (s = e.targetStart, r = e.targetAnchor); s && s !== r; )
      s.nodeType === 1 && s.setAttribute("data-v-owner", n.uid), s = s.nextSibling;
    n.ut();
  }
}
function va(e, t, n, s) {
  const r = t.targetStart = n(""), o = t.targetAnchor = n("");
  return r[Ta] = o, e && (s(r, e), s(o, e)), o;
}
const Ut = Symbol("_leaveCb"), Cs = Symbol("_enterCb");
function Xu() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Jt(() => {
    e.isMounted = !0;
  }), Pa(() => {
    e.isUnmounting = !0;
  }), e;
}
const rt = [Function, Array], Ca = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: rt,
  onEnter: rt,
  onAfterEnter: rt,
  onEnterCancelled: rt,
  // leave
  onBeforeLeave: rt,
  onLeave: rt,
  onAfterLeave: rt,
  onLeaveCancelled: rt,
  // appear
  onBeforeAppear: rt,
  onAppear: rt,
  onAfterAppear: rt,
  onAppearCancelled: rt
}, La = (e) => {
  const t = e.subTree;
  return t.component ? La(t.component) : t;
}, zu = {
  name: "BaseTransition",
  props: Ca,
  setup(e, { slots: t }) {
    const n = At(), s = Xu();
    return () => {
      const r = t.default && Oa(t.default(), !0);
      if (!r || !r.length)
        return;
      const o = ka(r), i = re(e), { mode: l } = i;
      if (s.isLeaving)
        return Lr(o);
      const a = mi(o);
      if (!a)
        return Lr(o);
      let c = qr(
        a,
        i,
        s,
        n,
        // #11061, ensure enterHooks is fresh after clone
        (p) => c = p
      );
      a.type !== $e && ns(a, c);
      const u = n.subTree, f = u && mi(u);
      if (f && f.type !== $e && !on(a, f) && La(n).type !== $e) {
        const p = qr(
          f,
          i,
          s,
          n
        );
        if (ns(f, p), l === "out-in" && a.type !== $e)
          return s.isLeaving = !0, p.afterLeave = () => {
            s.isLeaving = !1, n.job.flags & 8 || n.update(), delete p.afterLeave;
          }, Lr(o);
        l === "in-out" && a.type !== $e && (p.delayLeave = (b, _, T) => {
          const C = Aa(
            s,
            f
          );
          C[String(f.key)] = f, b[Ut] = () => {
            _(), b[Ut] = void 0, delete c.delayedLeave;
          }, c.delayedLeave = T;
        });
      }
      return o;
    };
  }
};
function ka(e) {
  let t = e[0];
  if (e.length > 1) {
    for (const n of e)
      if (n.type !== $e) {
        t = n;
        break;
      }
  }
  return t;
}
const Zu = zu;
function Aa(e, t) {
  const { leavingVNodes: n } = e;
  let s = n.get(t.type);
  return s || (s = /* @__PURE__ */ Object.create(null), n.set(t.type, s)), s;
}
function qr(e, t, n, s, r) {
  const {
    appear: o,
    mode: i,
    persisted: l = !1,
    onBeforeEnter: a,
    onEnter: c,
    onAfterEnter: u,
    onEnterCancelled: f,
    onBeforeLeave: p,
    onLeave: b,
    onAfterLeave: _,
    onLeaveCancelled: T,
    onBeforeAppear: C,
    onAppear: g,
    onAfterAppear: v,
    onAppearCancelled: L
  } = t, E = String(e.key), O = Aa(n, e), F = (P, B) => {
    P && ct(
      P,
      s,
      9,
      B
    );
  }, N = (P, B) => {
    const Y = B[1];
    F(P, B), G(P) ? P.every((U) => U.length <= 1) && Y() : P.length <= 1 && Y();
  }, H = {
    mode: i,
    persisted: l,
    beforeEnter(P) {
      let B = a;
      if (!n.isMounted)
        if (o)
          B = C || a;
        else
          return;
      P[Ut] && P[Ut](
        !0
        /* cancelled */
      );
      const Y = O[E];
      Y && on(e, Y) && Y.el[Ut] && Y.el[Ut](), F(B, [P]);
    },
    enter(P) {
      let B = c, Y = u, U = f;
      if (!n.isMounted)
        if (o)
          B = g || c, Y = v || u, U = L || f;
        else
          return;
      let j = !1;
      const ee = P[Cs] = (_e) => {
        j || (j = !0, _e ? F(U, [P]) : F(Y, [P]), H.delayedLeave && H.delayedLeave(), P[Cs] = void 0);
      };
      B ? N(B, [P, ee]) : ee();
    },
    leave(P, B) {
      const Y = String(e.key);
      if (P[Cs] && P[Cs](
        !0
        /* cancelled */
      ), n.isUnmounting)
        return B();
      F(p, [P]);
      let U = !1;
      const j = P[Ut] = (ee) => {
        U || (U = !0, B(), ee ? F(T, [P]) : F(_, [P]), P[Ut] = void 0, O[Y] === e && delete O[Y]);
      };
      O[Y] = e, b ? N(b, [P, j]) : j();
    },
    clone(P) {
      const B = qr(
        P,
        t,
        n,
        s,
        r
      );
      return r && r(B), B;
    }
  };
  return H;
}
function Lr(e) {
  if (or(e))
    return e = Kt(e), e.children = null, e;
}
function mi(e) {
  if (!or(e))
    return Sa(e.type) && e.children ? ka(e.children) : e;
  const { shapeFlag: t, children: n } = e;
  if (n) {
    if (t & 16)
      return n[0];
    if (t & 32 && J(n.default))
      return n.default();
  }
}
function ns(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, ns(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function Oa(e, t = !1, n) {
  let s = [], r = 0;
  for (let o = 0; o < e.length; o++) {
    let i = e[o];
    const l = n == null ? i.key : String(n) + String(i.key != null ? i.key : o);
    i.type === Le ? (i.patchFlag & 128 && r++, s = s.concat(
      Oa(i.children, t, l)
    )) : (t || i.type !== $e) && s.push(l != null ? Kt(i, { key: l }) : i);
  }
  if (r > 1)
    for (let o = 0; o < s.length; o++)
      s[o].patchFlag = -2;
  return s;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function lt(e, t) {
  return J(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Ee({ name: e.name }, t, { setup: e })
  ) : e;
}
function Ia(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function Ra(e) {
  const t = At(), n = ha(null);
  if (t) {
    const r = t.refs === oe ? t.refs = {} : t.refs;
    Object.defineProperty(r, e, {
      enumerable: !0,
      get: () => n.value,
      set: (o) => n.value = o
    });
  }
  return n;
}
function Yr(e, t, n, s, r = !1) {
  if (G(e)) {
    e.forEach(
      (_, T) => Yr(
        _,
        t && (G(t) ? t[T] : t),
        n,
        s,
        r
      )
    );
    return;
  }
  if (On(s) && !r)
    return;
  const o = s.shapeFlag & 4 ? cr(s.component) : s.el, i = r ? null : o, { i: l, r: a } = e, c = t && t.r, u = l.refs === oe ? l.refs = {} : l.refs, f = l.setupState, p = re(f), b = f === oe ? () => !1 : (_) => ce(p, _);
  if (c != null && c !== a && (ye(c) ? (u[c] = null, b(c) && (f[c] = null)) : we(c) && (c.value = null)), J(a))
    ds(a, l, 12, [i, u]);
  else {
    const _ = ye(a), T = we(a);
    if (_ || T) {
      const C = () => {
        if (e.f) {
          const g = _ ? b(a) ? f[a] : u[a] : a.value;
          r ? G(g) && Co(g, o) : G(g) ? g.includes(o) || g.push(o) : _ ? (u[a] = [o], b(a) && (f[a] = u[a])) : (a.value = [o], e.k && (u[e.k] = a.value));
        } else _ ? (u[a] = i, b(a) && (f[a] = i)) : T && (a.value = i, e.k && (u[e.k] = i));
      };
      i ? (C.id = -1, Be(C, n)) : C();
    }
  }
}
tr().requestIdleCallback;
tr().cancelIdleCallback;
const On = (e) => !!e.type.__asyncLoader, or = (e) => e.type.__isKeepAlive;
function Qu(e, t) {
  Na(e, "a", t);
}
function ef(e, t) {
  Na(e, "da", t);
}
function Na(e, t, n = Re) {
  const s = e.__wdc || (e.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return e();
  });
  if (ir(t, s, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      or(r.parent.vnode) && tf(s, t, n, r), r = r.parent;
  }
}
function tf(e, t, n, s) {
  const r = ir(
    t,
    e,
    s,
    !0
    /* prepend */
  );
  Fn(() => {
    Co(s[t], r);
  }, n);
}
function ir(e, t, n = Re, s = !1) {
  if (n) {
    const r = n[e] || (n[e] = []), o = t.__weh || (t.__weh = (...i) => {
      qt();
      const l = ps(n), a = ct(t, n, e, i);
      return l(), Yt(), a;
    });
    return s ? r.unshift(o) : r.push(o), o;
  }
}
const It = (e) => (t, n = Re) => {
  (!os || e === "sp") && ir(e, (...s) => t(...s), n);
}, xa = It("bm"), Jt = It("m"), nf = It(
  "bu"
), sf = It("u"), Pa = It(
  "bum"
), Fn = It("um"), rf = It(
  "sp"
), of = It("rtg"), lf = It("rtc");
function af(e, t = Re) {
  ir("ec", e, t);
}
const cf = "components";
function In(e, t) {
  return ff(cf, e, !0, t) || e;
}
const uf = Symbol.for("v-ndc");
function ff(e, t, n = !0, s = !1) {
  const r = Ae || Re;
  if (r) {
    const o = r.type;
    {
      const l = td(
        o,
        !1
      );
      if (l && (l === t || l === tt(t) || l === er(tt(t))))
        return o;
    }
    const i = (
      // local registration
      // check instance[type] first which is resolved for options API
      gi(r[e] || o[e], t) || // global registration
      gi(r.appContext[e], t)
    );
    return !i && s ? o : i;
  }
}
function gi(e, t) {
  return e && (e[t] || e[tt(t)] || e[er(tt(t))]);
}
function Mo(e, t, n, s) {
  let r;
  const o = n, i = G(e);
  if (i || ye(e)) {
    const l = i && Wt(e);
    let a = !1;
    l && (a = !it(e), e = sr(e)), r = new Array(e.length);
    for (let c = 0, u = e.length; c < u; c++)
      r[c] = t(
        a ? xe(e[c]) : e[c],
        c,
        void 0,
        o
      );
  } else if (typeof e == "number") {
    r = new Array(e);
    for (let l = 0; l < e; l++)
      r[l] = t(l + 1, l, void 0, o);
  } else if (me(e))
    if (e[Symbol.iterator])
      r = Array.from(
        e,
        (l, a) => t(l, a, void 0, o)
      );
    else {
      const l = Object.keys(e);
      r = new Array(l.length);
      for (let a = 0, c = l.length; a < c; a++) {
        const u = l[a];
        r[a] = t(e[u], u, a, o);
      }
    }
  else
    r = [];
  return r;
}
function Is(e, t, n = {}, s, r) {
  if (Ae.ce || Ae.parent && On(Ae.parent) && Ae.parent.ce)
    return t !== "default" && (n.name = t), Q(), qe(
      Le,
      null,
      [de("slot", n, s)],
      64
    );
  let o = e[t];
  o && o._c && (o._d = !1), Q();
  const i = o && Fa(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  i && i.key, a = qe(
    Le,
    {
      key: (l && !Ot(l) ? l : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!i && s ? "_fb" : "")
    },
    i || [],
    i && e._ === 1 ? 64 : -2
  );
  return !r && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), o && o._c && (o._d = !0), a;
}
function Fa(e) {
  return e.some((t) => rs(t) ? !(t.type === $e || t.type === Le && !Fa(t.children)) : !0) ? e : null;
}
const Jr = (e) => e ? ec(e) ? cr(e) : Jr(e.parent) : null, Xn = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ee(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Jr(e.parent),
    $root: (e) => Jr(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => $o(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      Do(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = ln.bind(e.proxy)),
    $watch: (e) => Df.bind(e)
  })
), kr = (e, t) => e !== oe && !e.__isScriptSetup && ce(e, t), df = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return !0;
    const { ctx: n, setupState: s, data: r, props: o, accessCache: i, type: l, appContext: a } = e;
    let c;
    if (t[0] !== "$") {
      const b = i[t];
      if (b !== void 0)
        switch (b) {
          case 1:
            return s[t];
          case 2:
            return r[t];
          case 4:
            return n[t];
          case 3:
            return o[t];
        }
      else {
        if (kr(s, t))
          return i[t] = 1, s[t];
        if (r !== oe && ce(r, t))
          return i[t] = 2, r[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = e.propsOptions[0]) && ce(c, t)
        )
          return i[t] = 3, o[t];
        if (n !== oe && ce(n, t))
          return i[t] = 4, n[t];
        Xr && (i[t] = 0);
      }
    }
    const u = Xn[t];
    let f, p;
    if (u)
      return t === "$attrs" && Ne(e.attrs, "get", ""), u(e);
    if (
      // css module (injected by vue-loader)
      (f = l.__cssModules) && (f = f[t])
    )
      return f;
    if (n !== oe && ce(n, t))
      return i[t] = 4, n[t];
    if (
      // global properties
      p = a.config.globalProperties, ce(p, t)
    )
      return p[t];
  },
  set({ _: e }, t, n) {
    const { data: s, setupState: r, ctx: o } = e;
    return kr(r, t) ? (r[t] = n, !0) : s !== oe && ce(s, t) ? (s[t] = n, !0) : ce(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (o[t] = n, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: r, propsOptions: o }
  }, i) {
    let l;
    return !!n[i] || e !== oe && ce(e, i) || kr(t, i) || (l = o[0]) && ce(l, i) || ce(s, i) || ce(Xn, i) || ce(r.config.globalProperties, i);
  },
  defineProperty(e, t, n) {
    return n.get != null ? e._.accessCache[t] = 0 : ce(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
  }
};
function Vs(e) {
  return G(e) ? e.reduce(
    (t, n) => (t[n] = null, t),
    {}
  ) : e;
}
function _i(e, t) {
  return !e || !t ? e || t : G(e) && G(t) ? e.concat(t) : Ee({}, Vs(e), Vs(t));
}
let Xr = !0;
function hf(e) {
  const t = $o(e), n = e.proxy, s = e.ctx;
  Xr = !1, t.beforeCreate && bi(t.beforeCreate, e, "bc");
  const {
    // state
    data: r,
    computed: o,
    methods: i,
    watch: l,
    provide: a,
    inject: c,
    // lifecycle
    created: u,
    beforeMount: f,
    mounted: p,
    beforeUpdate: b,
    updated: _,
    activated: T,
    deactivated: C,
    beforeDestroy: g,
    beforeUnmount: v,
    destroyed: L,
    unmounted: E,
    render: O,
    renderTracked: F,
    renderTriggered: N,
    errorCaptured: H,
    serverPrefetch: P,
    // public API
    expose: B,
    inheritAttrs: Y,
    // assets
    components: U,
    directives: j,
    filters: ee
  } = t;
  if (c && pf(c, s, null), i)
    for (const X in i) {
      const se = i[X];
      J(se) && (s[X] = se.bind(n));
    }
  if (r) {
    const X = r.call(n, n);
    me(X) && (e.data = jt(X));
  }
  if (Xr = !0, o)
    for (const X in o) {
      const se = o[X], ve = J(se) ? se.bind(n, n) : J(se.get) ? se.get.bind(n, n) : gt, _t = !J(se) && J(se.set) ? se.set.bind(n) : gt, nt = Ge({
        get: ve,
        set: _t
      });
      Object.defineProperty(s, X, {
        enumerable: !0,
        configurable: !0,
        get: () => nt.value,
        set: (We) => nt.value = We
      });
    }
  if (l)
    for (const X in l)
      Da(l[X], s, n, X);
  if (a) {
    const X = J(a) ? a.call(n) : a;
    Reflect.ownKeys(X).forEach((se) => {
      yf(se, X[se]);
    });
  }
  u && bi(u, e, "c");
  function le(X, se) {
    G(se) ? se.forEach((ve) => X(ve.bind(n))) : se && X(se.bind(n));
  }
  if (le(xa, f), le(Jt, p), le(nf, b), le(sf, _), le(Qu, T), le(ef, C), le(af, H), le(lf, F), le(of, N), le(Pa, v), le(Fn, E), le(rf, P), G(B))
    if (B.length) {
      const X = e.exposed || (e.exposed = {});
      B.forEach((se) => {
        Object.defineProperty(X, se, {
          get: () => n[se],
          set: (ve) => n[se] = ve
        });
      });
    } else e.exposed || (e.exposed = {});
  O && e.render === gt && (e.render = O), Y != null && (e.inheritAttrs = Y), U && (e.components = U), j && (e.directives = j), P && Ia(e);
}
function pf(e, t, n = gt) {
  G(e) && (e = zr(e));
  for (const s in e) {
    const r = e[s];
    let o;
    me(r) ? "default" in r ? o = Rn(
      r.from || s,
      r.default,
      !0
    ) : o = Rn(r.from || s) : o = Rn(r), we(o) ? Object.defineProperty(t, s, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (i) => o.value = i
    }) : t[s] = o;
  }
}
function bi(e, t, n) {
  ct(
    G(e) ? e.map((s) => s.bind(t.proxy)) : e.bind(t.proxy),
    t,
    n
  );
}
function Da(e, t, n, s) {
  let r = s.includes(".") ? Ya(n, s) : () => n[s];
  if (ye(e)) {
    const o = t[e];
    J(o) && Bt(r, o);
  } else if (J(e))
    Bt(r, e.bind(n));
  else if (me(e))
    if (G(e))
      e.forEach((o) => Da(o, t, n, s));
    else {
      const o = J(e.handler) ? e.handler.bind(n) : t[e.handler];
      J(o) && Bt(r, o, e);
    }
}
function $o(e) {
  const t = e.type, { mixins: n, extends: s } = t, {
    mixins: r,
    optionsCache: o,
    config: { optionMergeStrategies: i }
  } = e.appContext, l = o.get(t);
  let a;
  return l ? a = l : !r.length && !n && !s ? a = t : (a = {}, r.length && r.forEach(
    (c) => Ws(a, c, i, !0)
  ), Ws(a, t, i)), me(t) && o.set(t, a), a;
}
function Ws(e, t, n, s = !1) {
  const { mixins: r, extends: o } = t;
  o && Ws(e, o, n, !0), r && r.forEach(
    (i) => Ws(e, i, n, !0)
  );
  for (const i in t)
    if (!(s && i === "expose")) {
      const l = mf[i] || n && n[i];
      e[i] = l ? l(e[i], t[i]) : t[i];
    }
  return e;
}
const mf = {
  data: wi,
  props: yi,
  emits: yi,
  // objects
  methods: Kn,
  computed: Kn,
  // lifecycle
  beforeCreate: Pe,
  created: Pe,
  beforeMount: Pe,
  mounted: Pe,
  beforeUpdate: Pe,
  updated: Pe,
  beforeDestroy: Pe,
  beforeUnmount: Pe,
  destroyed: Pe,
  unmounted: Pe,
  activated: Pe,
  deactivated: Pe,
  errorCaptured: Pe,
  serverPrefetch: Pe,
  // assets
  components: Kn,
  directives: Kn,
  // watch
  watch: _f,
  // provide / inject
  provide: wi,
  inject: gf
};
function wi(e, t) {
  return t ? e ? function() {
    return Ee(
      J(e) ? e.call(this, this) : e,
      J(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function gf(e, t) {
  return Kn(zr(e), zr(t));
}
function zr(e) {
  if (G(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t;
  }
  return e;
}
function Pe(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Kn(e, t) {
  return e ? Ee(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function yi(e, t) {
  return e ? G(e) && G(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : Ee(
    /* @__PURE__ */ Object.create(null),
    Vs(e),
    Vs(t ?? {})
  ) : t;
}
function _f(e, t) {
  if (!e) return t;
  if (!t) return e;
  const n = Ee(/* @__PURE__ */ Object.create(null), e);
  for (const s in t)
    n[s] = Pe(e[s], t[s]);
  return n;
}
function Ma() {
  return {
    app: null,
    config: {
      isNativeTag: Qc,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let bf = 0;
function wf(e, t) {
  return function(s, r = null) {
    J(s) || (s = Ee({}, s)), r != null && !me(r) && (r = null);
    const o = Ma(), i = /* @__PURE__ */ new WeakSet(), l = [];
    let a = !1;
    const c = o.app = {
      _uid: bf++,
      _component: s,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: sd,
      get config() {
        return o.config;
      },
      set config(u) {
      },
      use(u, ...f) {
        return i.has(u) || (u && J(u.install) ? (i.add(u), u.install(c, ...f)) : J(u) && (i.add(u), u(c, ...f))), c;
      },
      mixin(u) {
        return o.mixins.includes(u) || o.mixins.push(u), c;
      },
      component(u, f) {
        return f ? (o.components[u] = f, c) : o.components[u];
      },
      directive(u, f) {
        return f ? (o.directives[u] = f, c) : o.directives[u];
      },
      mount(u, f, p) {
        if (!a) {
          const b = c._ceVNode || de(s, r);
          return b.appContext = o, p === !0 ? p = "svg" : p === !1 && (p = void 0), f && t ? t(b, u) : e(b, u, p), a = !0, c._container = u, u.__vue_app__ = c, cr(b.component);
        }
      },
      onUnmount(u) {
        l.push(u);
      },
      unmount() {
        a && (ct(
          l,
          c._instance,
          16
        ), e(null, c._container), delete c._container.__vue_app__);
      },
      provide(u, f) {
        return o.provides[u] = f, c;
      },
      runWithContext(u) {
        const f = fn;
        fn = c;
        try {
          return u();
        } finally {
          fn = f;
        }
      }
    };
    return c;
  };
}
let fn = null;
function yf(e, t) {
  if (Re) {
    let n = Re.provides;
    const s = Re.parent && Re.parent.provides;
    s === n && (n = Re.provides = Object.create(s)), n[e] = t;
  }
}
function Rn(e, t, n = !1) {
  const s = Re || Ae;
  if (s || fn) {
    const r = fn ? fn._context.provides : s ? s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (r && e in r)
      return r[e];
    if (arguments.length > 1)
      return n && J(t) ? t.call(s && s.proxy) : t;
  }
}
function Ef() {
  return !!(Re || Ae || fn);
}
const $a = {}, Ua = () => Object.create($a), Ha = (e) => Object.getPrototypeOf(e) === $a;
function Tf(e, t, n, s = !1) {
  const r = {}, o = Ua();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), Va(e, t, r, o);
  for (const i in e.propsOptions[0])
    i in r || (r[i] = void 0);
  n ? e.props = s ? r : Ru(r) : e.type.props ? e.props = r : e.props = o, e.attrs = o;
}
function Sf(e, t, n, s) {
  const {
    props: r,
    attrs: o,
    vnode: { patchFlag: i }
  } = e, l = re(r), [a] = e.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (s || i > 0) && !(i & 16)
  ) {
    if (i & 8) {
      const u = e.vnode.dynamicProps;
      for (let f = 0; f < u.length; f++) {
        let p = u[f];
        if (ar(e.emitsOptions, p))
          continue;
        const b = t[p];
        if (a)
          if (ce(o, p))
            b !== o[p] && (o[p] = b, c = !0);
          else {
            const _ = tt(p);
            r[_] = Zr(
              a,
              l,
              _,
              b,
              e,
              !1
            );
          }
        else
          b !== o[p] && (o[p] = b, c = !0);
      }
    }
  } else {
    Va(e, t, r, o) && (c = !0);
    let u;
    for (const f in l)
      (!t || // for camelCase
      !ce(t, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Gt(f)) === f || !ce(t, u))) && (a ? n && // for camelCase
      (n[f] !== void 0 || // for kebab-case
      n[u] !== void 0) && (r[f] = Zr(
        a,
        l,
        f,
        void 0,
        e,
        !0
      )) : delete r[f]);
    if (o !== l)
      for (const f in o)
        (!t || !ce(t, f)) && (delete o[f], c = !0);
  }
  c && vt(e.attrs, "set", "");
}
function Va(e, t, n, s) {
  const [r, o] = e.propsOptions;
  let i = !1, l;
  if (t)
    for (let a in t) {
      if (Gn(a))
        continue;
      const c = t[a];
      let u;
      r && ce(r, u = tt(a)) ? !o || !o.includes(u) ? n[u] = c : (l || (l = {}))[u] = c : ar(e.emitsOptions, a) || (!(a in s) || c !== s[a]) && (s[a] = c, i = !0);
    }
  if (o) {
    const a = re(n), c = l || oe;
    for (let u = 0; u < o.length; u++) {
      const f = o[u];
      n[f] = Zr(
        r,
        a,
        f,
        c[f],
        e,
        !ce(c, f)
      );
    }
  }
  return i;
}
function Zr(e, t, n, s, r, o) {
  const i = e[n];
  if (i != null) {
    const l = ce(i, "default");
    if (l && s === void 0) {
      const a = i.default;
      if (i.type !== Function && !i.skipFactory && J(a)) {
        const { propsDefaults: c } = r;
        if (n in c)
          s = c[n];
        else {
          const u = ps(r);
          s = c[n] = a.call(
            null,
            t
          ), u();
        }
      } else
        s = a;
      r.ce && r.ce._setProp(n, s);
    }
    i[
      0
      /* shouldCast */
    ] && (o && !l ? s = !1 : i[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === Gt(n)) && (s = !0));
  }
  return s;
}
const vf = /* @__PURE__ */ new WeakMap();
function Wa(e, t, n = !1) {
  const s = n ? vf : t.propsCache, r = s.get(e);
  if (r)
    return r;
  const o = e.props, i = {}, l = [];
  let a = !1;
  if (!J(e)) {
    const u = (f) => {
      a = !0;
      const [p, b] = Wa(f, t, !0);
      Ee(i, p), b && l.push(...b);
    };
    !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
  }
  if (!o && !a)
    return me(e) && s.set(e, Ln), Ln;
  if (G(o))
    for (let u = 0; u < o.length; u++) {
      const f = tt(o[u]);
      Ei(f) && (i[f] = oe);
    }
  else if (o)
    for (const u in o) {
      const f = tt(u);
      if (Ei(f)) {
        const p = o[u], b = i[f] = G(p) || J(p) ? { type: p } : Ee({}, p), _ = b.type;
        let T = !1, C = !0;
        if (G(_))
          for (let g = 0; g < _.length; ++g) {
            const v = _[g], L = J(v) && v.name;
            if (L === "Boolean") {
              T = !0;
              break;
            } else L === "String" && (C = !1);
          }
        else
          T = J(_) && _.name === "Boolean";
        b[
          0
          /* shouldCast */
        ] = T, b[
          1
          /* shouldCastTrue */
        ] = C, (T || ce(b, "default")) && l.push(f);
      }
    }
  const c = [i, l];
  return me(e) && s.set(e, c), c;
}
function Ei(e) {
  return e[0] !== "$" && !Gn(e);
}
const Ba = (e) => e[0] === "_" || e === "$stable", Uo = (e) => G(e) ? e.map(mt) : [mt(e)], Cf = (e, t, n) => {
  if (t._n)
    return t;
  const s = Ke((...r) => Uo(t(...r)), n);
  return s._c = !1, s;
}, ja = (e, t, n) => {
  const s = e._ctx;
  for (const r in e) {
    if (Ba(r)) continue;
    const o = e[r];
    if (J(o))
      t[r] = Cf(r, o, s);
    else if (o != null) {
      const i = Uo(o);
      t[r] = () => i;
    }
  }
}, Ka = (e, t) => {
  const n = Uo(t);
  e.slots.default = () => n;
}, Ga = (e, t, n) => {
  for (const s in t)
    (n || s !== "_") && (e[s] = t[s]);
}, Lf = (e, t, n) => {
  const s = e.slots = Ua();
  if (e.vnode.shapeFlag & 32) {
    const r = t._;
    r ? (Ga(s, t, n), n && Gl(s, "_", r, !0)) : ja(t, s);
  } else t && Ka(e, t);
}, kf = (e, t, n) => {
  const { vnode: s, slots: r } = e;
  let o = !0, i = oe;
  if (s.shapeFlag & 32) {
    const l = t._;
    l ? n && l === 1 ? o = !1 : Ga(r, t, n) : (o = !t.$stable, ja(t, r)), i = t;
  } else t && (Ka(e, t), i = { default: 1 });
  if (o)
    for (const l in r)
      !Ba(l) && i[l] == null && delete r[l];
}, Be = Bf;
function Af(e) {
  return Of(e);
}
function Of(e, t) {
  const n = tr();
  n.__VUE__ = !0;
  const {
    insert: s,
    remove: r,
    patchProp: o,
    createElement: i,
    createText: l,
    createComment: a,
    setText: c,
    setElementText: u,
    parentNode: f,
    nextSibling: p,
    setScopeId: b = gt,
    insertStaticContent: _
  } = e, T = (m, w, R, M = null, D = null, d = null, h = void 0, S = null, A = !!w.dynamicChildren) => {
    if (m === w)
      return;
    m && !on(m, w) && (M = Rt(m), We(m, D, d, !0), m = null), w.patchFlag === -2 && (A = !1, w.dynamicChildren = null);
    const { type: x, ref: $, shapeFlag: y } = w;
    switch (x) {
      case hs:
        C(m, w, R, M);
        break;
      case $e:
        g(m, w, R, M);
        break;
      case Rs:
        m == null && v(w, R, M, h);
        break;
      case Le:
        U(
          m,
          w,
          R,
          M,
          D,
          d,
          h,
          S,
          A
        );
        break;
      default:
        y & 1 ? O(
          m,
          w,
          R,
          M,
          D,
          d,
          h,
          S,
          A
        ) : y & 6 ? j(
          m,
          w,
          R,
          M,
          D,
          d,
          h,
          S,
          A
        ) : (y & 64 || y & 128) && x.process(
          m,
          w,
          R,
          M,
          D,
          d,
          h,
          S,
          A,
          wt
        );
    }
    $ != null && D && Yr($, m && m.ref, d, w || m, !w);
  }, C = (m, w, R, M) => {
    if (m == null)
      s(
        w.el = l(w.children),
        R,
        M
      );
    else {
      const D = w.el = m.el;
      w.children !== m.children && c(D, w.children);
    }
  }, g = (m, w, R, M) => {
    m == null ? s(
      w.el = a(w.children || ""),
      R,
      M
    ) : w.el = m.el;
  }, v = (m, w, R, M) => {
    [m.el, m.anchor] = _(
      m.children,
      w,
      R,
      M,
      m.el,
      m.anchor
    );
  }, L = ({ el: m, anchor: w }, R, M) => {
    let D;
    for (; m && m !== w; )
      D = p(m), s(m, R, M), m = D;
    s(w, R, M);
  }, E = ({ el: m, anchor: w }) => {
    let R;
    for (; m && m !== w; )
      R = p(m), r(m), m = R;
    r(w);
  }, O = (m, w, R, M, D, d, h, S, A) => {
    w.type === "svg" ? h = "svg" : w.type === "math" && (h = "mathml"), m == null ? F(
      w,
      R,
      M,
      D,
      d,
      h,
      S,
      A
    ) : P(
      m,
      w,
      D,
      d,
      h,
      S,
      A
    );
  }, F = (m, w, R, M, D, d, h, S) => {
    let A, x;
    const { props: $, shapeFlag: y, transition: k, dirs: V } = m;
    if (A = m.el = i(
      m.type,
      d,
      $ && $.is,
      $
    ), y & 8 ? u(A, m.children) : y & 16 && H(
      m.children,
      A,
      null,
      M,
      D,
      Ar(m, d),
      h,
      S
    ), V && Qt(m, null, M, "created"), N(A, m, m.scopeId, h, M), $) {
      for (const te in $)
        te !== "value" && !Gn(te) && o(A, te, null, $[te], d, M);
      "value" in $ && o(A, "value", null, $.value, d), (x = $.onVnodeBeforeMount) && dt(x, M, m);
    }
    V && Qt(m, null, M, "beforeMount");
    const K = If(D, k);
    K && k.beforeEnter(A), s(A, w, R), ((x = $ && $.onVnodeMounted) || K || V) && Be(() => {
      x && dt(x, M, m), K && k.enter(A), V && Qt(m, null, M, "mounted");
    }, D);
  }, N = (m, w, R, M, D) => {
    if (R && b(m, R), M)
      for (let d = 0; d < M.length; d++)
        b(m, M[d]);
    if (D) {
      let d = D.subTree;
      if (w === d || za(d.type) && (d.ssContent === w || d.ssFallback === w)) {
        const h = D.vnode;
        N(
          m,
          h,
          h.scopeId,
          h.slotScopeIds,
          D.parent
        );
      }
    }
  }, H = (m, w, R, M, D, d, h, S, A = 0) => {
    for (let x = A; x < m.length; x++) {
      const $ = m[x] = S ? Ht(m[x]) : mt(m[x]);
      T(
        null,
        $,
        w,
        R,
        M,
        D,
        d,
        h,
        S
      );
    }
  }, P = (m, w, R, M, D, d, h) => {
    const S = w.el = m.el;
    let { patchFlag: A, dynamicChildren: x, dirs: $ } = w;
    A |= m.patchFlag & 16;
    const y = m.props || oe, k = w.props || oe;
    let V;
    if (R && en(R, !1), (V = k.onVnodeBeforeUpdate) && dt(V, R, w, m), $ && Qt(w, m, R, "beforeUpdate"), R && en(R, !0), (y.innerHTML && k.innerHTML == null || y.textContent && k.textContent == null) && u(S, ""), x ? B(
      m.dynamicChildren,
      x,
      S,
      R,
      M,
      Ar(w, D),
      d
    ) : h || se(
      m,
      w,
      S,
      null,
      R,
      M,
      Ar(w, D),
      d,
      !1
    ), A > 0) {
      if (A & 16)
        Y(S, y, k, R, D);
      else if (A & 2 && y.class !== k.class && o(S, "class", null, k.class, D), A & 4 && o(S, "style", y.style, k.style, D), A & 8) {
        const K = w.dynamicProps;
        for (let te = 0; te < K.length; te++) {
          const ne = K[te], Te = y[ne], Ie = k[ne];
          (Ie !== Te || ne === "value") && o(S, ne, Te, Ie, D, R);
        }
      }
      A & 1 && m.children !== w.children && u(S, w.children);
    } else !h && x == null && Y(S, y, k, R, D);
    ((V = k.onVnodeUpdated) || $) && Be(() => {
      V && dt(V, R, w, m), $ && Qt(w, m, R, "updated");
    }, M);
  }, B = (m, w, R, M, D, d, h) => {
    for (let S = 0; S < w.length; S++) {
      const A = m[S], x = w[S], $ = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        A.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (A.type === Le || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !on(A, x) || // - In the case of a component, it could contain anything.
        A.shapeFlag & 70) ? f(A.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          R
        )
      );
      T(
        A,
        x,
        $,
        null,
        M,
        D,
        d,
        h,
        !0
      );
    }
  }, Y = (m, w, R, M, D) => {
    if (w !== R) {
      if (w !== oe)
        for (const d in w)
          !Gn(d) && !(d in R) && o(
            m,
            d,
            w[d],
            null,
            D,
            M
          );
      for (const d in R) {
        if (Gn(d)) continue;
        const h = R[d], S = w[d];
        h !== S && d !== "value" && o(m, d, S, h, D, M);
      }
      "value" in R && o(m, "value", w.value, R.value, D);
    }
  }, U = (m, w, R, M, D, d, h, S, A) => {
    const x = w.el = m ? m.el : l(""), $ = w.anchor = m ? m.anchor : l("");
    let { patchFlag: y, dynamicChildren: k, slotScopeIds: V } = w;
    V && (S = S ? S.concat(V) : V), m == null ? (s(x, R, M), s($, R, M), H(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      w.children || [],
      R,
      $,
      D,
      d,
      h,
      S,
      A
    )) : y > 0 && y & 64 && k && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    m.dynamicChildren ? (B(
      m.dynamicChildren,
      k,
      R,
      D,
      d,
      h,
      S
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (w.key != null || D && w === D.subTree) && Ho(
      m,
      w,
      !0
      /* shallow */
    )) : se(
      m,
      w,
      R,
      $,
      D,
      d,
      h,
      S,
      A
    );
  }, j = (m, w, R, M, D, d, h, S, A) => {
    w.slotScopeIds = S, m == null ? w.shapeFlag & 512 ? D.ctx.activate(
      w,
      R,
      M,
      h,
      A
    ) : ee(
      w,
      R,
      M,
      D,
      d,
      h,
      A
    ) : _e(m, w, A);
  }, ee = (m, w, R, M, D, d, h) => {
    const S = m.component = Xf(
      m,
      M,
      D
    );
    if (or(m) && (S.ctx.renderer = wt), zf(S, !1, h), S.asyncDep) {
      if (D && D.registerDep(S, le, h), !m.el) {
        const A = S.subTree = de($e);
        g(null, A, w, R);
      }
    } else
      le(
        S,
        m,
        w,
        R,
        D,
        d,
        h
      );
  }, _e = (m, w, R) => {
    const M = w.component = m.component;
    if (Vf(m, w, R))
      if (M.asyncDep && !M.asyncResolved) {
        X(M, w, R);
        return;
      } else
        M.next = w, M.update();
    else
      w.el = m.el, M.vnode = w;
  }, le = (m, w, R, M, D, d, h) => {
    const S = () => {
      if (m.isMounted) {
        let { next: y, bu: k, u: V, parent: K, vnode: te } = m;
        {
          const ze = qa(m);
          if (ze) {
            y && (y.el = te.el, X(m, y, h)), ze.asyncDep.then(() => {
              m.isUnmounted || S();
            });
            return;
          }
        }
        let ne = y, Te;
        en(m, !1), y ? (y.el = te.el, X(m, y, h)) : y = te, k && As(k), (Te = y.props && y.props.onVnodeBeforeUpdate) && dt(Te, K, y, te), en(m, !0);
        const Ie = Or(m), st = m.subTree;
        m.subTree = Ie, T(
          st,
          Ie,
          // parent may have changed if it's in a teleport
          f(st.el),
          // anchor may have changed if it's in a fragment
          Rt(st),
          m,
          D,
          d
        ), y.el = Ie.el, ne === null && Wf(m, Ie.el), V && Be(V, D), (Te = y.props && y.props.onVnodeUpdated) && Be(
          () => dt(Te, K, y, te),
          D
        );
      } else {
        let y;
        const { el: k, props: V } = w, { bm: K, m: te, parent: ne, root: Te, type: Ie } = m, st = On(w);
        if (en(m, !1), K && As(K), !st && (y = V && V.onVnodeBeforeMount) && dt(y, ne, w), en(m, !0), k && bn) {
          const ze = () => {
            m.subTree = Or(m), bn(
              k,
              m.subTree,
              m,
              D,
              null
            );
          };
          st && Ie.__asyncHydrate ? Ie.__asyncHydrate(
            k,
            m,
            ze
          ) : ze();
        } else {
          Te.ce && Te.ce._injectChildStyle(Ie);
          const ze = m.subTree = Or(m);
          T(
            null,
            ze,
            R,
            M,
            m,
            D,
            d
          ), w.el = ze.el;
        }
        if (te && Be(te, D), !st && (y = V && V.onVnodeMounted)) {
          const ze = w;
          Be(
            () => dt(y, ne, ze),
            D
          );
        }
        (w.shapeFlag & 256 || ne && On(ne.vnode) && ne.vnode.shapeFlag & 256) && m.a && Be(m.a, D), m.isMounted = !0, w = R = M = null;
      }
    };
    m.scope.on();
    const A = m.effect = new Zl(S);
    m.scope.off();
    const x = m.update = A.run.bind(A), $ = m.job = A.runIfDirty.bind(A);
    $.i = m, $.id = m.uid, A.scheduler = () => Do($), en(m, !0), x();
  }, X = (m, w, R) => {
    w.component = m;
    const M = m.vnode.props;
    m.vnode = w, m.next = null, Sf(m, w.props, M, R), kf(m, w.children, R), qt(), di(m), Yt();
  }, se = (m, w, R, M, D, d, h, S, A = !1) => {
    const x = m && m.children, $ = m ? m.shapeFlag : 0, y = w.children, { patchFlag: k, shapeFlag: V } = w;
    if (k > 0) {
      if (k & 128) {
        _t(
          x,
          y,
          R,
          M,
          D,
          d,
          h,
          S,
          A
        );
        return;
      } else if (k & 256) {
        ve(
          x,
          y,
          R,
          M,
          D,
          d,
          h,
          S,
          A
        );
        return;
      }
    }
    V & 8 ? ($ & 16 && bt(x, D, d), y !== x && u(R, y)) : $ & 16 ? V & 16 ? _t(
      x,
      y,
      R,
      M,
      D,
      d,
      h,
      S,
      A
    ) : bt(x, D, d, !0) : ($ & 8 && u(R, ""), V & 16 && H(
      y,
      R,
      M,
      D,
      d,
      h,
      S,
      A
    ));
  }, ve = (m, w, R, M, D, d, h, S, A) => {
    m = m || Ln, w = w || Ln;
    const x = m.length, $ = w.length, y = Math.min(x, $);
    let k;
    for (k = 0; k < y; k++) {
      const V = w[k] = A ? Ht(w[k]) : mt(w[k]);
      T(
        m[k],
        V,
        R,
        null,
        D,
        d,
        h,
        S,
        A
      );
    }
    x > $ ? bt(
      m,
      D,
      d,
      !0,
      !1,
      y
    ) : H(
      w,
      R,
      M,
      D,
      d,
      h,
      S,
      A,
      y
    );
  }, _t = (m, w, R, M, D, d, h, S, A) => {
    let x = 0;
    const $ = w.length;
    let y = m.length - 1, k = $ - 1;
    for (; x <= y && x <= k; ) {
      const V = m[x], K = w[x] = A ? Ht(w[x]) : mt(w[x]);
      if (on(V, K))
        T(
          V,
          K,
          R,
          null,
          D,
          d,
          h,
          S,
          A
        );
      else
        break;
      x++;
    }
    for (; x <= y && x <= k; ) {
      const V = m[y], K = w[k] = A ? Ht(w[k]) : mt(w[k]);
      if (on(V, K))
        T(
          V,
          K,
          R,
          null,
          D,
          d,
          h,
          S,
          A
        );
      else
        break;
      y--, k--;
    }
    if (x > y) {
      if (x <= k) {
        const V = k + 1, K = V < $ ? w[V].el : M;
        for (; x <= k; )
          T(
            null,
            w[x] = A ? Ht(w[x]) : mt(w[x]),
            R,
            K,
            D,
            d,
            h,
            S,
            A
          ), x++;
      }
    } else if (x > k)
      for (; x <= y; )
        We(m[x], D, d, !0), x++;
    else {
      const V = x, K = x, te = /* @__PURE__ */ new Map();
      for (x = K; x <= k; x++) {
        const Ze = w[x] = A ? Ht(w[x]) : mt(w[x]);
        Ze.key != null && te.set(Ze.key, x);
      }
      let ne, Te = 0;
      const Ie = k - K + 1;
      let st = !1, ze = 0;
      const Un = new Array(Ie);
      for (x = 0; x < Ie; x++) Un[x] = 0;
      for (x = V; x <= y; x++) {
        const Ze = m[x];
        if (Te >= Ie) {
          We(Ze, D, d, !0);
          continue;
        }
        let ft;
        if (Ze.key != null)
          ft = te.get(Ze.key);
        else
          for (ne = K; ne <= k; ne++)
            if (Un[ne - K] === 0 && on(Ze, w[ne])) {
              ft = ne;
              break;
            }
        ft === void 0 ? We(Ze, D, d, !0) : (Un[ft - K] = x + 1, ft >= ze ? ze = ft : st = !0, T(
          Ze,
          w[ft],
          R,
          null,
          D,
          d,
          h,
          S,
          A
        ), Te++);
      }
      const oi = st ? Rf(Un) : Ln;
      for (ne = oi.length - 1, x = Ie - 1; x >= 0; x--) {
        const Ze = K + x, ft = w[Ze], ii = Ze + 1 < $ ? w[Ze + 1].el : M;
        Un[x] === 0 ? T(
          null,
          ft,
          R,
          ii,
          D,
          d,
          h,
          S,
          A
        ) : st && (ne < 0 || x !== oi[ne] ? nt(ft, R, ii, 2) : ne--);
      }
    }
  }, nt = (m, w, R, M, D = null) => {
    const { el: d, type: h, transition: S, children: A, shapeFlag: x } = m;
    if (x & 6) {
      nt(m.component.subTree, w, R, M);
      return;
    }
    if (x & 128) {
      m.suspense.move(w, R, M);
      return;
    }
    if (x & 64) {
      h.move(m, w, R, wt);
      return;
    }
    if (h === Le) {
      s(d, w, R);
      for (let y = 0; y < A.length; y++)
        nt(A[y], w, R, M);
      s(m.anchor, w, R);
      return;
    }
    if (h === Rs) {
      L(m, w, R);
      return;
    }
    if (M !== 2 && x & 1 && S)
      if (M === 0)
        S.beforeEnter(d), s(d, w, R), Be(() => S.enter(d), D);
      else {
        const { leave: y, delayLeave: k, afterLeave: V } = S, K = () => s(d, w, R), te = () => {
          y(d, () => {
            K(), V && V();
          });
        };
        k ? k(d, K, te) : te();
      }
    else
      s(d, w, R);
  }, We = (m, w, R, M = !1, D = !1) => {
    const {
      type: d,
      props: h,
      ref: S,
      children: A,
      dynamicChildren: x,
      shapeFlag: $,
      patchFlag: y,
      dirs: k,
      cacheIndex: V
    } = m;
    if (y === -2 && (D = !1), S != null && Yr(S, null, R, m, !0), V != null && (w.renderCache[V] = void 0), $ & 256) {
      w.ctx.deactivate(m);
      return;
    }
    const K = $ & 1 && k, te = !On(m);
    let ne;
    if (te && (ne = h && h.onVnodeBeforeUnmount) && dt(ne, w, m), $ & 6)
      ys(m.component, R, M);
    else {
      if ($ & 128) {
        m.suspense.unmount(R, M);
        return;
      }
      K && Qt(m, null, w, "beforeUnmount"), $ & 64 ? m.type.remove(
        m,
        w,
        R,
        wt,
        M
      ) : x && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !x.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (d !== Le || y > 0 && y & 64) ? bt(
        x,
        w,
        R,
        !1,
        !0
      ) : (d === Le && y & 384 || !D && $ & 16) && bt(A, w, R), M && mn(m);
    }
    (te && (ne = h && h.onVnodeUnmounted) || K) && Be(() => {
      ne && dt(ne, w, m), K && Qt(m, null, w, "unmounted");
    }, R);
  }, mn = (m) => {
    const { type: w, el: R, anchor: M, transition: D } = m;
    if (w === Le) {
      $n(R, M);
      return;
    }
    if (w === Rs) {
      E(m);
      return;
    }
    const d = () => {
      r(R), D && !D.persisted && D.afterLeave && D.afterLeave();
    };
    if (m.shapeFlag & 1 && D && !D.persisted) {
      const { leave: h, delayLeave: S } = D, A = () => h(R, d);
      S ? S(m.el, d, A) : A();
    } else
      d();
  }, $n = (m, w) => {
    let R;
    for (; m !== w; )
      R = p(m), r(m), m = R;
    r(w);
  }, ys = (m, w, R) => {
    const { bum: M, scope: D, job: d, subTree: h, um: S, m: A, a: x } = m;
    Ti(A), Ti(x), M && As(M), D.stop(), d && (d.flags |= 8, We(h, m, w, R)), S && Be(S, w), Be(() => {
      m.isUnmounted = !0;
    }, w), w && w.pendingBranch && !w.isUnmounted && m.asyncDep && !m.asyncResolved && m.suspenseId === w.pendingId && (w.deps--, w.deps === 0 && w.resolve());
  }, bt = (m, w, R, M = !1, D = !1, d = 0) => {
    for (let h = d; h < m.length; h++)
      We(m[h], w, R, M, D);
  }, Rt = (m) => {
    if (m.shapeFlag & 6)
      return Rt(m.component.subTree);
    if (m.shapeFlag & 128)
      return m.suspense.next();
    const w = p(m.anchor || m.el), R = w && w[Ta];
    return R ? p(R) : w;
  };
  let Nt = !1;
  const gn = (m, w, R) => {
    m == null ? w._vnode && We(w._vnode, null, null, !0) : T(
      w._vnode || null,
      m,
      w,
      null,
      null,
      null,
      R
    ), w._vnode = m, Nt || (Nt = !0, di(), ba(), Nt = !1);
  }, wt = {
    p: T,
    um: We,
    m: nt,
    r: mn,
    mt: ee,
    mc: H,
    pc: se,
    pbc: B,
    n: Rt,
    o: e
  };
  let _n, bn;
  return {
    render: gn,
    hydrate: _n,
    createApp: wf(gn, _n)
  };
}
function Ar({ type: e, props: t }, n) {
  return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
}
function en({ effect: e, job: t }, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function If(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function Ho(e, t, n = !1) {
  const s = e.children, r = t.children;
  if (G(s) && G(r))
    for (let o = 0; o < s.length; o++) {
      const i = s[o];
      let l = r[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = Ht(r[o]), l.el = i.el), !n && l.patchFlag !== -2 && Ho(i, l)), l.type === hs && (l.el = i.el);
    }
}
function Rf(e) {
  const t = e.slice(), n = [0];
  let s, r, o, i, l;
  const a = e.length;
  for (s = 0; s < a; s++) {
    const c = e[s];
    if (c !== 0) {
      if (r = n[n.length - 1], e[r] < c) {
        t[s] = r, n.push(s);
        continue;
      }
      for (o = 0, i = n.length - 1; o < i; )
        l = o + i >> 1, e[n[l]] < c ? o = l + 1 : i = l;
      c < e[n[o]] && (o > 0 && (t[s] = n[o - 1]), n[o] = s);
    }
  }
  for (o = n.length, i = n[o - 1]; o-- > 0; )
    n[o] = i, i = t[i];
  return n;
}
function qa(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : qa(t);
}
function Ti(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
const Nf = Symbol.for("v-scx"), xf = () => Rn(Nf);
function Pf(e, t) {
  return lr(
    e,
    null,
    { flush: "post" }
  );
}
function Ff(e, t) {
  return lr(
    e,
    null,
    { flush: "sync" }
  );
}
function Bt(e, t, n) {
  return lr(e, t, n);
}
function lr(e, t, n = oe) {
  const { immediate: s, deep: r, flush: o, once: i } = n, l = Ee({}, n), a = t && s || !t && o !== "post";
  let c;
  if (os) {
    if (o === "sync") {
      const b = xf();
      c = b.__watcherHandles || (b.__watcherHandles = []);
    } else if (!a) {
      const b = () => {
      };
      return b.stop = gt, b.resume = gt, b.pause = gt, b;
    }
  }
  const u = Re;
  l.call = (b, _, T) => ct(b, u, _, T);
  let f = !1;
  o === "post" ? l.scheduler = (b) => {
    Be(b, u && u.suspense);
  } : o !== "sync" && (f = !0, l.scheduler = (b, _) => {
    _ ? b() : Do(b);
  }), l.augmentJob = (b) => {
    t && (b.flags |= 4), f && (b.flags |= 2, u && (b.id = u.uid, b.i = u));
  };
  const p = Wu(e, t, l);
  return os && (c ? c.push(p) : a && p()), p;
}
function Df(e, t, n) {
  const s = this.proxy, r = ye(e) ? e.includes(".") ? Ya(s, e) : () => s[e] : e.bind(s, s);
  let o;
  J(t) ? o = t : (o = t.handler, n = t);
  const i = ps(this), l = lr(r, o.bind(s), n);
  return i(), l;
}
function Ya(e, t) {
  const n = t.split(".");
  return () => {
    let s = e;
    for (let r = 0; r < n.length && s; r++)
      s = s[n[r]];
    return s;
  };
}
function Mf(e, t, n = oe) {
  const s = At(), r = tt(t), o = Gt(t), i = Ja(e, r), l = Fu((a, c) => {
    let u, f = oe, p;
    return Ff(() => {
      const b = e[r];
      je(u, b) && (u = b, c());
    }), {
      get() {
        return a(), n.get ? n.get(u) : u;
      },
      set(b) {
        const _ = n.set ? n.set(b) : b;
        if (!je(_, u) && !(f !== oe && je(b, f)))
          return;
        const T = s.vnode.props;
        T && // check if parent has passed v-model
        (t in T || r in T || o in T) && (`onUpdate:${t}` in T || `onUpdate:${r}` in T || `onUpdate:${o}` in T) || (u = b, c()), s.emit(`update:${t}`, _), je(b, _) && je(b, f) && !je(_, p) && c(), f = b, p = _;
      }
    };
  });
  return l[Symbol.iterator] = () => {
    let a = 0;
    return {
      next() {
        return a < 2 ? { value: a++ ? i || oe : l, done: !1 } : { done: !0 };
      }
    };
  }, l;
}
const Ja = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${tt(t)}Modifiers`] || e[`${Gt(t)}Modifiers`];
function $f(e, t, ...n) {
  if (e.isUnmounted) return;
  const s = e.vnode.props || oe;
  let r = n;
  const o = t.startsWith("update:"), i = o && Ja(s, t.slice(7));
  i && (i.trim && (r = n.map((u) => ye(u) ? u.trim() : u)), i.number && (r = n.map(Vr)));
  let l, a = s[l = Er(t)] || // also try camelCase event handler (#2249)
  s[l = Er(tt(t))];
  !a && o && (a = s[l = Er(Gt(t))]), a && ct(
    a,
    e,
    6,
    r
  );
  const c = s[l + "Once"];
  if (c) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[l])
      return;
    e.emitted[l] = !0, ct(
      c,
      e,
      6,
      r
    );
  }
}
function Xa(e, t, n = !1) {
  const s = t.emitsCache, r = s.get(e);
  if (r !== void 0)
    return r;
  const o = e.emits;
  let i = {}, l = !1;
  if (!J(e)) {
    const a = (c) => {
      const u = Xa(c, t, !0);
      u && (l = !0, Ee(i, u));
    };
    !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a);
  }
  return !o && !l ? (me(e) && s.set(e, null), null) : (G(o) ? o.forEach((a) => i[a] = null) : Ee(i, o), me(e) && s.set(e, i), i);
}
function ar(e, t) {
  return !e || !zs(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), ce(e, t[0].toLowerCase() + t.slice(1)) || ce(e, Gt(t)) || ce(e, t));
}
function Or(e) {
  const {
    type: t,
    vnode: n,
    proxy: s,
    withProxy: r,
    propsOptions: [o],
    slots: i,
    attrs: l,
    emit: a,
    render: c,
    renderCache: u,
    props: f,
    data: p,
    setupState: b,
    ctx: _,
    inheritAttrs: T
  } = e, C = Hs(e);
  let g, v;
  try {
    if (n.shapeFlag & 4) {
      const E = r || s, O = E;
      g = mt(
        c.call(
          O,
          E,
          u,
          f,
          b,
          p,
          _
        )
      ), v = l;
    } else {
      const E = t;
      g = mt(
        E.length > 1 ? E(
          f,
          { attrs: l, slots: i, emit: a }
        ) : E(
          f,
          null
        )
      ), v = t.props ? l : Uf(l);
    }
  } catch (E) {
    zn.length = 0, rr(E, e, 1), g = de($e);
  }
  let L = g;
  if (v && T !== !1) {
    const E = Object.keys(v), { shapeFlag: O } = L;
    E.length && O & 7 && (o && E.some(vo) && (v = Hf(
      v,
      o
    )), L = Kt(L, v, !1, !0));
  }
  return n.dirs && (L = Kt(L, null, !1, !0), L.dirs = L.dirs ? L.dirs.concat(n.dirs) : n.dirs), n.transition && ns(L, n.transition), g = L, Hs(C), g;
}
const Uf = (e) => {
  let t;
  for (const n in e)
    (n === "class" || n === "style" || zs(n)) && ((t || (t = {}))[n] = e[n]);
  return t;
}, Hf = (e, t) => {
  const n = {};
  for (const s in e)
    (!vo(s) || !(s.slice(9) in t)) && (n[s] = e[s]);
  return n;
};
function Vf(e, t, n) {
  const { props: s, children: r, component: o } = e, { props: i, children: l, patchFlag: a } = t, c = o.emitsOptions;
  if (t.dirs || t.transition)
    return !0;
  if (n && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return s ? Si(s, i, c) : !!i;
    if (a & 8) {
      const u = t.dynamicProps;
      for (let f = 0; f < u.length; f++) {
        const p = u[f];
        if (i[p] !== s[p] && !ar(c, p))
          return !0;
      }
    }
  } else
    return (r || l) && (!l || !l.$stable) ? !0 : s === i ? !1 : s ? i ? Si(s, i, c) : !0 : !!i;
  return !1;
}
function Si(e, t, n) {
  const s = Object.keys(t);
  if (s.length !== Object.keys(e).length)
    return !0;
  for (let r = 0; r < s.length; r++) {
    const o = s[r];
    if (t[o] !== e[o] && !ar(n, o))
      return !0;
  }
  return !1;
}
function Wf({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const s = t.subTree;
    if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e)
      (e = t.vnode).el = n, t = t.parent;
    else
      break;
  }
}
const za = (e) => e.__isSuspense;
function Bf(e, t) {
  t && t.pendingBranch ? G(e) ? t.effects.push(...e) : t.effects.push(e) : Ku(e);
}
const Le = Symbol.for("v-fgt"), hs = Symbol.for("v-txt"), $e = Symbol.for("v-cmt"), Rs = Symbol.for("v-stc"), zn = [];
let Qe = null;
function Q(e = !1) {
  zn.push(Qe = e ? null : []);
}
function jf() {
  zn.pop(), Qe = zn[zn.length - 1] || null;
}
let ss = 1;
function vi(e) {
  ss += e, e < 0 && Qe && (Qe.hasOnce = !0);
}
function Za(e) {
  return e.dynamicChildren = ss > 0 ? Qe || Ln : null, jf(), ss > 0 && Qe && Qe.push(e), e;
}
function ge(e, t, n, s, r, o) {
  return Za(
    q(
      e,
      t,
      n,
      s,
      r,
      o,
      !0
    )
  );
}
function qe(e, t, n, s, r) {
  return Za(
    de(
      e,
      t,
      n,
      s,
      r,
      !0
    )
  );
}
function rs(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function on(e, t) {
  return e.type === t.type && e.key === t.key;
}
const Qa = ({ key: e }) => e ?? null, Ns = ({
  ref: e,
  ref_key: t,
  ref_for: n
}) => (typeof e == "number" && (e = "" + e), e != null ? ye(e) || we(e) || J(e) ? { i: Ae, r: e, k: t, f: !!n } : e : null);
function q(e, t = null, n = null, s = 0, r = null, o = e === Le ? 0 : 1, i = !1, l = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Qa(t),
    ref: t && Ns(t),
    scopeId: ya,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: s,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Ae
  };
  return l ? (Vo(a, n), o & 128 && e.normalize(a)) : n && (a.shapeFlag |= ye(n) ? 8 : 16), ss > 0 && // avoid a block node from tracking itself
  !i && // has current parent block
  Qe && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && Qe.push(a), a;
}
const de = Kf;
function Kf(e, t = null, n = null, s = 0, r = null, o = !1) {
  if ((!e || e === uf) && (e = $e), rs(e)) {
    const l = Kt(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return n && Vo(l, n), ss > 0 && !o && Qe && (l.shapeFlag & 6 ? Qe[Qe.indexOf(e)] = l : Qe.push(l)), l.patchFlag = -2, l;
  }
  if (nd(e) && (e = e.__vccOpts), t) {
    t = Gf(t);
    let { class: l, style: a } = t;
    l && !ye(l) && (t.class = He(l)), me(a) && (Po(a) && !G(a) && (a = Ee({}, a)), t.style = ko(a));
  }
  const i = ye(e) ? 1 : za(e) ? 128 : Sa(e) ? 64 : me(e) ? 4 : J(e) ? 2 : 0;
  return q(
    e,
    t,
    n,
    s,
    r,
    i,
    o,
    !0
  );
}
function Gf(e) {
  return e ? Po(e) || Ha(e) ? Ee({}, e) : e : null;
}
function Kt(e, t, n = !1, s = !1) {
  const { props: r, ref: o, patchFlag: i, children: l, transition: a } = e, c = t ? qf(r || {}, t) : r, u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: c,
    key: c && Qa(c),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? G(o) ? o.concat(Ns(t)) : [o, Ns(t)] : Ns(t)
    ) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: l,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Le ? i === -1 ? 16 : i | 16 : i,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: a,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Kt(e.ssContent),
    ssFallback: e.ssFallback && Kt(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return a && s && ns(
    u,
    a.clone(u)
  ), u;
}
function Cn(e = " ", t = 0) {
  return de(hs, null, e, t);
}
function Ue(e = "", t = !1) {
  return t ? (Q(), qe($e, null, e)) : de($e, null, e);
}
function mt(e) {
  return e == null || typeof e == "boolean" ? de($e) : G(e) ? de(
    Le,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : rs(e) ? Ht(e) : de(hs, null, String(e));
}
function Ht(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Kt(e);
}
function Vo(e, t) {
  let n = 0;
  const { shapeFlag: s } = e;
  if (t == null)
    t = null;
  else if (G(t))
    n = 16;
  else if (typeof t == "object")
    if (s & 65) {
      const r = t.default;
      r && (r._c && (r._d = !1), Vo(e, r()), r._c && (r._d = !0));
      return;
    } else {
      n = 32;
      const r = t._;
      !r && !Ha(t) ? t._ctx = Ae : r === 3 && Ae && (Ae.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else J(t) ? (t = { default: t, _ctx: Ae }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [Cn(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function qf(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    for (const r in s)
      if (r === "class")
        t.class !== s.class && (t.class = He([t.class, s.class]));
      else if (r === "style")
        t.style = ko([t.style, s.style]);
      else if (zs(r)) {
        const o = t[r], i = s[r];
        i && o !== i && !(G(o) && o.includes(i)) && (t[r] = o ? [].concat(o, i) : i);
      } else r !== "" && (t[r] = s[r]);
  }
  return t;
}
function dt(e, t, n, s = null) {
  ct(e, t, 7, [
    n,
    s
  ]);
}
const Yf = Ma();
let Jf = 0;
function Xf(e, t, n) {
  const s = e.type, r = (t ? t.appContext : e.appContext) || Yf, o = {
    uid: Jf++,
    vnode: e,
    type: s,
    parent: t,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Xl(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(r.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Wa(s, r),
    emitsOptions: Xa(s, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: oe,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: oe,
    data: oe,
    props: oe,
    attrs: oe,
    slots: oe,
    refs: oe,
    setupState: oe,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = t ? t.root : o, o.emit = $f.bind(null, o), e.ce && e.ce(o), o;
}
let Re = null;
const At = () => Re || Ae;
let Bs, Qr;
{
  const e = tr(), t = (n, s) => {
    let r;
    return (r = e[n]) || (r = e[n] = []), r.push(s), (o) => {
      r.length > 1 ? r.forEach((i) => i(o)) : r[0](o);
    };
  };
  Bs = t(
    "__VUE_INSTANCE_SETTERS__",
    (n) => Re = n
  ), Qr = t(
    "__VUE_SSR_SETTERS__",
    (n) => os = n
  );
}
const ps = (e) => {
  const t = Re;
  return Bs(e), e.scope.on(), () => {
    e.scope.off(), Bs(t);
  };
}, Ci = () => {
  Re && Re.scope.off(), Bs(null);
};
function ec(e) {
  return e.vnode.shapeFlag & 4;
}
let os = !1;
function zf(e, t = !1, n = !1) {
  t && Qr(t);
  const { props: s, children: r } = e.vnode, o = ec(e);
  Tf(e, s, o, t), Lf(e, r, n);
  const i = o ? Zf(e, t) : void 0;
  return t && Qr(!1), i;
}
function Zf(e, t) {
  const n = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, df);
  const { setup: s } = n;
  if (s) {
    qt();
    const r = e.setupContext = s.length > 1 ? ed(e) : null, o = ps(e), i = ds(
      s,
      e,
      0,
      [
        e.props,
        r
      ]
    ), l = Bl(i);
    if (Yt(), o(), (l || e.sp) && !On(e) && Ia(e), l) {
      if (i.then(Ci, Ci), t)
        return i.then((a) => {
          Li(e, a, t);
        }).catch((a) => {
          rr(a, e, 0);
        });
      e.asyncDep = i;
    } else
      Li(e, i, t);
  } else
    tc(e, t);
}
function Li(e, t, n) {
  J(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : me(t) && (e.setupState = ma(t)), tc(e, n);
}
let ki;
function tc(e, t, n) {
  const s = e.type;
  if (!e.render) {
    if (!t && ki && !s.render) {
      const r = s.template || $o(e).template;
      if (r) {
        const { isCustomElement: o, compilerOptions: i } = e.appContext.config, { delimiters: l, compilerOptions: a } = s, c = Ee(
          Ee(
            {
              isCustomElement: o,
              delimiters: l
            },
            i
          ),
          a
        );
        s.render = ki(r, c);
      }
    }
    e.render = s.render || gt;
  }
  {
    const r = ps(e);
    qt();
    try {
      hf(e);
    } finally {
      Yt(), r();
    }
  }
}
const Qf = {
  get(e, t) {
    return Ne(e, "get", ""), e[t];
  }
};
function ed(e) {
  const t = (n) => {
    e.exposed = n || {};
  };
  return {
    attrs: new Proxy(e.attrs, Qf),
    slots: e.slots,
    emit: e.emit,
    expose: t
  };
}
function cr(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(ma(Fo(e.exposed)), {
    get(t, n) {
      if (n in t)
        return t[n];
      if (n in Xn)
        return Xn[n](e);
    },
    has(t, n) {
      return n in t || n in Xn;
    }
  })) : e.proxy;
}
function td(e, t = !0) {
  return J(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function nd(e) {
  return J(e) && "__vccOpts" in e;
}
const Ge = (e, t) => Hu(e, t, os);
function Wo(e, t, n) {
  const s = arguments.length;
  return s === 2 ? me(t) && !G(t) ? rs(t) ? de(e, null, [t]) : de(e, t) : de(e, null, t) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && rs(n) && (n = [n]), de(e, t, n));
}
const sd = "3.5.12";
/**
* @vue/runtime-dom v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let eo;
const Ai = typeof window < "u" && window.trustedTypes;
if (Ai)
  try {
    eo = /* @__PURE__ */ Ai.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const nc = eo ? (e) => eo.createHTML(e) : (e) => e, rd = "http://www.w3.org/2000/svg", od = "http://www.w3.org/1998/Math/MathML", Tt = typeof document < "u" ? document : null, Oi = Tt && /* @__PURE__ */ Tt.createElement("template"), id = {
  insert: (e, t, n) => {
    t.insertBefore(e, n || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, n, s) => {
    const r = t === "svg" ? Tt.createElementNS(rd, e) : t === "mathml" ? Tt.createElementNS(od, e) : n ? Tt.createElement(e, { is: n }) : Tt.createElement(e);
    return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r;
  },
  createText: (e) => Tt.createTextNode(e),
  createComment: (e) => Tt.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Tt.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, n, s, r, o) {
    const i = n ? n.previousSibling : t.lastChild;
    if (r && (r === o || r.nextSibling))
      for (; t.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling)); )
        ;
    else {
      Oi.innerHTML = nc(
        s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e
      );
      const l = Oi.content;
      if (s === "svg" || s === "mathml") {
        const a = l.firstChild;
        for (; a.firstChild; )
          l.appendChild(a.firstChild);
        l.removeChild(a);
      }
      t.insertBefore(l, n);
    }
    return [
      // first
      i ? i.nextSibling : t.firstChild,
      // last
      n ? n.previousSibling : t.lastChild
    ];
  }
}, xt = "transition", Vn = "animation", is = Symbol("_vtc"), sc = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, ld = /* @__PURE__ */ Ee(
  {},
  Ca,
  sc
), ad = (e) => (e.displayName = "Transition", e.props = ld, e), cd = /* @__PURE__ */ ad(
  (e, { slots: t }) => Wo(Zu, ud(e), t)
), tn = (e, t = []) => {
  G(e) ? e.forEach((n) => n(...t)) : e && e(...t);
}, Ii = (e) => e ? G(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function ud(e) {
  const t = {};
  for (const U in e)
    U in sc || (t[U] = e[U]);
  if (e.css === !1)
    return t;
  const {
    name: n = "v",
    type: s,
    duration: r,
    enterFromClass: o = `${n}-enter-from`,
    enterActiveClass: i = `${n}-enter-active`,
    enterToClass: l = `${n}-enter-to`,
    appearFromClass: a = o,
    appearActiveClass: c = i,
    appearToClass: u = l,
    leaveFromClass: f = `${n}-leave-from`,
    leaveActiveClass: p = `${n}-leave-active`,
    leaveToClass: b = `${n}-leave-to`
  } = e, _ = fd(r), T = _ && _[0], C = _ && _[1], {
    onBeforeEnter: g,
    onEnter: v,
    onEnterCancelled: L,
    onLeave: E,
    onLeaveCancelled: O,
    onBeforeAppear: F = g,
    onAppear: N = v,
    onAppearCancelled: H = L
  } = t, P = (U, j, ee) => {
    nn(U, j ? u : l), nn(U, j ? c : i), ee && ee();
  }, B = (U, j) => {
    U._isLeaving = !1, nn(U, f), nn(U, b), nn(U, p), j && j();
  }, Y = (U) => (j, ee) => {
    const _e = U ? N : v, le = () => P(j, U, ee);
    tn(_e, [j, le]), Ri(() => {
      nn(j, U ? a : o), Pt(j, U ? u : l), Ii(_e) || Ni(j, s, T, le);
    });
  };
  return Ee(t, {
    onBeforeEnter(U) {
      tn(g, [U]), Pt(U, o), Pt(U, i);
    },
    onBeforeAppear(U) {
      tn(F, [U]), Pt(U, a), Pt(U, c);
    },
    onEnter: Y(!1),
    onAppear: Y(!0),
    onLeave(U, j) {
      U._isLeaving = !0;
      const ee = () => B(U, j);
      Pt(U, f), Pt(U, p), pd(), Ri(() => {
        U._isLeaving && (nn(U, f), Pt(U, b), Ii(E) || Ni(U, s, C, ee));
      }), tn(E, [U, ee]);
    },
    onEnterCancelled(U) {
      P(U, !1), tn(L, [U]);
    },
    onAppearCancelled(U) {
      P(U, !0), tn(H, [U]);
    },
    onLeaveCancelled(U) {
      B(U), tn(O, [U]);
    }
  });
}
function fd(e) {
  if (e == null)
    return null;
  if (me(e))
    return [Ir(e.enter), Ir(e.leave)];
  {
    const t = Ir(e);
    return [t, t];
  }
}
function Ir(e) {
  return ru(e);
}
function Pt(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[is] || (e[is] = /* @__PURE__ */ new Set())).add(t);
}
function nn(e, t) {
  t.split(/\s+/).forEach((s) => s && e.classList.remove(s));
  const n = e[is];
  n && (n.delete(t), n.size || (e[is] = void 0));
}
function Ri(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let dd = 0;
function Ni(e, t, n, s) {
  const r = e._endId = ++dd, o = () => {
    r === e._endId && s();
  };
  if (n != null)
    return setTimeout(o, n);
  const { type: i, timeout: l, propCount: a } = hd(e, t);
  if (!i)
    return s();
  const c = i + "end";
  let u = 0;
  const f = () => {
    e.removeEventListener(c, p), o();
  }, p = (b) => {
    b.target === e && ++u >= a && f();
  };
  setTimeout(() => {
    u < a && f();
  }, l + 1), e.addEventListener(c, p);
}
function hd(e, t) {
  const n = window.getComputedStyle(e), s = (_) => (n[_] || "").split(", "), r = s(`${xt}Delay`), o = s(`${xt}Duration`), i = xi(r, o), l = s(`${Vn}Delay`), a = s(`${Vn}Duration`), c = xi(l, a);
  let u = null, f = 0, p = 0;
  t === xt ? i > 0 && (u = xt, f = i, p = o.length) : t === Vn ? c > 0 && (u = Vn, f = c, p = a.length) : (f = Math.max(i, c), u = f > 0 ? i > c ? xt : Vn : null, p = u ? u === xt ? o.length : a.length : 0);
  const b = u === xt && /\b(transform|all)(,|$)/.test(
    s(`${xt}Property`).toString()
  );
  return {
    type: u,
    timeout: f,
    propCount: p,
    hasTransform: b
  };
}
function xi(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((n, s) => Pi(n) + Pi(e[s])));
}
function Pi(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function pd() {
  return document.body.offsetHeight;
}
function md(e, t, n) {
  const s = e[is];
  s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
}
const js = Symbol("_vod"), rc = Symbol("_vsh"), gd = {
  beforeMount(e, { value: t }, { transition: n }) {
    e[js] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Wn(e, t);
  },
  mounted(e, { value: t }, { transition: n }) {
    n && t && n.enter(e);
  },
  updated(e, { value: t, oldValue: n }, { transition: s }) {
    !t != !n && (s ? t ? (s.beforeEnter(e), Wn(e, !0), s.enter(e)) : s.leave(e, () => {
      Wn(e, !1);
    }) : Wn(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Wn(e, t);
  }
};
function Wn(e, t) {
  e.style.display = t ? e[js] : "none", e[rc] = !t;
}
const oc = Symbol("");
function _d(e) {
  const t = At();
  if (!t)
    return;
  const n = t.ut = (r = e(t.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${t.uid}"]`)
    ).forEach((o) => Ks(o, r));
  }, s = () => {
    const r = e(t.proxy);
    t.ce ? Ks(t.ce, r) : to(t.subTree, r), n(r);
  };
  xa(() => {
    Pf(s);
  }), Jt(() => {
    const r = new MutationObserver(s);
    r.observe(t.subTree.el.parentNode, { childList: !0 }), Fn(() => r.disconnect());
  });
}
function to(e, t) {
  if (e.shapeFlag & 128) {
    const n = e.suspense;
    e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
      to(n.activeBranch, t);
    });
  }
  for (; e.component; )
    e = e.component.subTree;
  if (e.shapeFlag & 1 && e.el)
    Ks(e.el, t);
  else if (e.type === Le)
    e.children.forEach((n) => to(n, t));
  else if (e.type === Rs) {
    let { el: n, anchor: s } = e;
    for (; n && (Ks(n, t), n !== s); )
      n = n.nextSibling;
  }
}
function Ks(e, t) {
  if (e.nodeType === 1) {
    const n = e.style;
    let s = "";
    for (const r in t)
      n.setProperty(`--${r}`, t[r]), s += `--${r}: ${t[r]};`;
    n[oc] = s;
  }
}
const bd = /(^|;)\s*display\s*:/;
function wd(e, t, n) {
  const s = e.style, r = ye(n);
  let o = !1;
  if (n && !r) {
    if (t)
      if (ye(t))
        for (const i of t.split(";")) {
          const l = i.slice(0, i.indexOf(":")).trim();
          n[l] == null && xs(s, l, "");
        }
      else
        for (const i in t)
          n[i] == null && xs(s, i, "");
    for (const i in n)
      i === "display" && (o = !0), xs(s, i, n[i]);
  } else if (r) {
    if (t !== n) {
      const i = s[oc];
      i && (n += ";" + i), s.cssText = n, o = bd.test(n);
    }
  } else t && e.removeAttribute("style");
  js in e && (e[js] = o ? s.display : "", e[rc] && (s.display = "none"));
}
const Fi = /\s*!important$/;
function xs(e, t, n) {
  if (G(n))
    n.forEach((s) => xs(e, t, s));
  else if (n == null && (n = ""), t.startsWith("--"))
    e.setProperty(t, n);
  else {
    const s = yd(e, t);
    Fi.test(n) ? e.setProperty(
      Gt(s),
      n.replace(Fi, ""),
      "important"
    ) : e[s] = n;
  }
}
const Di = ["Webkit", "Moz", "ms"], Rr = {};
function yd(e, t) {
  const n = Rr[t];
  if (n)
    return n;
  let s = tt(t);
  if (s !== "filter" && s in e)
    return Rr[t] = s;
  s = er(s);
  for (let r = 0; r < Di.length; r++) {
    const o = Di[r] + s;
    if (o in e)
      return Rr[t] = o;
  }
  return t;
}
const Mi = "http://www.w3.org/1999/xlink";
function $i(e, t, n, s, r, o = uu(t)) {
  s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Mi, t.slice(6, t.length)) : e.setAttributeNS(Mi, t, n) : n == null || o && !ql(n) ? e.removeAttribute(t) : e.setAttribute(
    t,
    o ? "" : Ot(n) ? String(n) : n
  );
}
function Ui(e, t, n, s, r) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e[t] = t === "innerHTML" ? nc(n) : n);
    return;
  }
  const o = e.tagName;
  if (t === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? e.getAttribute("value") || "" : e.value, a = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== a || !("_value" in e)) && (e.value = a), n == null && e.removeAttribute(t), e._value = n;
    return;
  }
  let i = !1;
  if (n === "" || n == null) {
    const l = typeof e[t];
    l === "boolean" ? n = ql(n) : n == null && l === "string" ? (n = "", i = !0) : l === "number" && (n = 0, i = !0);
  }
  try {
    e[t] = n;
  } catch {
  }
  i && e.removeAttribute(r || t);
}
function Sn(e, t, n, s) {
  e.addEventListener(t, n, s);
}
function Ed(e, t, n, s) {
  e.removeEventListener(t, n, s);
}
const Hi = Symbol("_vei");
function Td(e, t, n, s, r = null) {
  const o = e[Hi] || (e[Hi] = {}), i = o[t];
  if (s && i)
    i.value = s;
  else {
    const [l, a] = Sd(t);
    if (s) {
      const c = o[t] = Ld(
        s,
        r
      );
      Sn(e, l, c, a);
    } else i && (Ed(e, l, i, a), o[t] = void 0);
  }
}
const Vi = /(?:Once|Passive|Capture)$/;
function Sd(e) {
  let t;
  if (Vi.test(e)) {
    t = {};
    let s;
    for (; s = e.match(Vi); )
      e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : Gt(e.slice(2)), t];
}
let Nr = 0;
const vd = /* @__PURE__ */ Promise.resolve(), Cd = () => Nr || (vd.then(() => Nr = 0), Nr = Date.now());
function Ld(e, t) {
  const n = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= n.attached)
      return;
    ct(
      kd(s, n.value),
      t,
      5,
      [s]
    );
  };
  return n.value = e, n.attached = Cd(), n;
}
function kd(e, t) {
  if (G(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = !0;
    }, t.map(
      (s) => (r) => !r._stopped && s && s(r)
    );
  } else
    return t;
}
const Wi = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Ad = (e, t, n, s, r, o) => {
  const i = r === "svg";
  t === "class" ? md(e, s, i) : t === "style" ? wd(e, n, s) : zs(t) ? vo(t) || Td(e, t, n, s, o) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Od(e, t, s, i)) ? (Ui(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && $i(e, t, s, i, o, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !ye(s)) ? Ui(e, tt(t), s, o, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), $i(e, t, s, i));
};
function Od(e, t, n, s) {
  if (s)
    return !!(t === "innerHTML" || t === "textContent" || t in e && Wi(t) && J(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (t === "width" || t === "height") {
    const r = e.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return !1;
  }
  return Wi(t) && ye(n) ? !1 : t in e;
}
const Bi = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return G(t) ? (n) => As(t, n) : t;
};
function Id(e) {
  e.target.composing = !0;
}
function ji(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const xr = Symbol("_assign"), Rd = {
  created(e, { modifiers: { lazy: t, trim: n, number: s } }, r) {
    e[xr] = Bi(r);
    const o = s || r.props && r.props.type === "number";
    Sn(e, t ? "change" : "input", (i) => {
      if (i.target.composing) return;
      let l = e.value;
      n && (l = l.trim()), o && (l = Vr(l)), e[xr](l);
    }), n && Sn(e, "change", () => {
      e.value = e.value.trim();
    }), t || (Sn(e, "compositionstart", Id), Sn(e, "compositionend", ji), Sn(e, "change", ji));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: s, trim: r, number: o } }, i) {
    if (e[xr] = Bi(i), e.composing) return;
    const l = (o || e.type === "number") && !/^0\d/.test(e.value) ? Vr(e.value) : e.value, a = t ?? "";
    l !== a && (document.activeElement === e && e.type !== "range" && (s && t === n || r && e.value.trim() === a) || (e.value = a));
  }
}, Nd = /* @__PURE__ */ Ee({ patchProp: Ad }, id);
let Ki;
function xd() {
  return Ki || (Ki = Af(Nd));
}
const Pd = (...e) => {
  const t = xd().createApp(...e), { mount: n } = t;
  return t.mount = (s) => {
    const r = Dd(s);
    if (!r) return;
    const o = t._component;
    !J(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const i = n(r, !1, Fd(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), i;
  }, t;
};
function Fd(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function Dd(e) {
  return ye(e) ? document.querySelector(e) : e;
}
var Md = !1;
/*!
 * pinia v2.2.4
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let ic;
const ur = (e) => ic = e, lc = (
  /* istanbul ignore next */
  Symbol()
);
function no(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var Zn;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(Zn || (Zn = {}));
function $d() {
  const e = Ao(!0), t = e.run(() => ue({}));
  let n = [], s = [];
  const r = Fo({
    install(o) {
      ur(r), r._a = o, o.provide(lc, r), o.config.globalProperties.$pinia = r, s.forEach((i) => n.push(i)), s = [];
    },
    use(o) {
      return !this._a && !Md ? s.push(o) : n.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: t
  });
  return r;
}
const ac = () => {
};
function Gi(e, t, n, s = ac) {
  e.push(t);
  const r = () => {
    const o = e.indexOf(t);
    o > -1 && (e.splice(o, 1), s());
  };
  return !n && zl() && fu(r), r;
}
function En(e, ...t) {
  e.slice().forEach((n) => {
    n(...t);
  });
}
const Ud = (e) => e(), qi = Symbol(), Pr = Symbol();
function so(e, t) {
  e instanceof Map && t instanceof Map ? t.forEach((n, s) => e.set(s, n)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
  for (const n in t) {
    if (!t.hasOwnProperty(n))
      continue;
    const s = t[n], r = e[n];
    no(r) && no(s) && e.hasOwnProperty(n) && !we(s) && !Wt(s) ? e[n] = so(r, s) : e[n] = s;
  }
  return e;
}
const Hd = (
  /* istanbul ignore next */
  Symbol()
);
function Vd(e) {
  return !no(e) || !e.hasOwnProperty(Hd);
}
const { assign: Mt } = Object;
function Wd(e) {
  return !!(we(e) && e.effect);
}
function Bd(e, t, n, s) {
  const { state: r, actions: o, getters: i } = t, l = n.state.value[e];
  let a;
  function c() {
    l || (n.state.value[e] = r ? r() : {});
    const u = Du(n.state.value[e]);
    return Mt(u, o, Object.keys(i || {}).reduce((f, p) => (f[p] = Fo(Ge(() => {
      ur(n);
      const b = n._s.get(e);
      return i[p].call(b, b);
    })), f), {}));
  }
  return a = cc(e, c, t, n, s, !0), a;
}
function cc(e, t, n = {}, s, r, o) {
  let i;
  const l = Mt({ actions: {} }, n), a = { deep: !0 };
  let c, u, f = [], p = [], b;
  const _ = s.state.value[e];
  !o && !_ && (s.state.value[e] = {}), ue({});
  let T;
  function C(H) {
    let P;
    c = u = !1, typeof H == "function" ? (H(s.state.value[e]), P = {
      type: Zn.patchFunction,
      storeId: e,
      events: b
    }) : (so(s.state.value[e], H), P = {
      type: Zn.patchObject,
      payload: H,
      storeId: e,
      events: b
    });
    const B = T = Symbol();
    ln().then(() => {
      T === B && (c = !0);
    }), u = !0, En(f, P, s.state.value[e]);
  }
  const g = o ? function() {
    const { state: P } = n, B = P ? P() : {};
    this.$patch((Y) => {
      Mt(Y, B);
    });
  } : (
    /* istanbul ignore next */
    ac
  );
  function v() {
    i.stop(), f = [], p = [], s._s.delete(e);
  }
  const L = (H, P = "") => {
    if (qi in H)
      return H[Pr] = P, H;
    const B = function() {
      ur(s);
      const Y = Array.from(arguments), U = [], j = [];
      function ee(X) {
        U.push(X);
      }
      function _e(X) {
        j.push(X);
      }
      En(p, {
        args: Y,
        name: B[Pr],
        store: O,
        after: ee,
        onError: _e
      });
      let le;
      try {
        le = H.apply(this && this.$id === e ? this : O, Y);
      } catch (X) {
        throw En(j, X), X;
      }
      return le instanceof Promise ? le.then((X) => (En(U, X), X)).catch((X) => (En(j, X), Promise.reject(X))) : (En(U, le), le);
    };
    return B[qi] = !0, B[Pr] = P, B;
  }, E = {
    _p: s,
    // _s: scope,
    $id: e,
    $onAction: Gi.bind(null, p),
    $patch: C,
    $reset: g,
    $subscribe(H, P = {}) {
      const B = Gi(f, H, P.detached, () => Y()), Y = i.run(() => Bt(() => s.state.value[e], (U) => {
        (P.flush === "sync" ? u : c) && H({
          storeId: e,
          type: Zn.direct,
          events: b
        }, U);
      }, Mt({}, a, P)));
      return B;
    },
    $dispose: v
  }, O = jt(E);
  s._s.set(e, O);
  const N = (s._a && s._a.runWithContext || Ud)(() => s._e.run(() => (i = Ao()).run(() => t({ action: L }))));
  for (const H in N) {
    const P = N[H];
    if (we(P) && !Wd(P) || Wt(P))
      o || (_ && Vd(P) && (we(P) ? P.value = _[H] : so(P, _[H])), s.state.value[e][H] = P);
    else if (typeof P == "function") {
      const B = L(P, H);
      N[H] = B, l.actions[H] = P;
    }
  }
  return Mt(O, N), Mt(re(O), N), Object.defineProperty(O, "$state", {
    get: () => s.state.value[e],
    set: (H) => {
      C((P) => {
        Mt(P, H);
      });
    }
  }), s._p.forEach((H) => {
    Mt(O, i.run(() => H({
      store: O,
      app: s._a,
      pinia: s,
      options: l
    })));
  }), _ && o && n.hydrate && n.hydrate(O.$state, _), c = !0, u = !0, O;
}
// @__NO_SIDE_EFFECTS__
function jd(e, t, n) {
  let s, r;
  const o = typeof t == "function";
  s = e, r = o ? n : t;
  function i(l, a) {
    const c = Ef();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (c ? Rn(lc, null) : null), l && ur(l), l = ic, l._s.has(s) || (o ? cc(s, t, r, l) : Bd(s, r, l)), l._s.get(s);
  }
  return i.$id = s, i;
}
const ms = /* @__PURE__ */ jd("showcase", {
  state: () => ({
    state: "WAIT",
    platformId: null,
    settings: [],
    tasks: [],
    showLoader: !1,
    platform: null
  }),
  getters: {
    tgId: (e) => {
      var t, n, s, r;
      return (r = (s = (n = (t = window == null ? void 0 : window.Telegram) == null ? void 0 : t.WebApp) == null ? void 0 : n.initDataUnsafe) == null ? void 0 : s.user) != null && r.id ? window.Telegram.WebApp.initDataUnsafe.user.id : "60";
    },
    //todo заменить,
    isPremium: (e) => {
      var t, n, s, r;
      return (r = (s = (n = (t = window == null ? void 0 : window.Telegram) == null ? void 0 : t.WebApp) == null ? void 0 : n.initDataUnsafe) == null ? void 0 : s.user) != null && r.is_premium ? !!window.Telegram.WebApp.initDataUnsafe.user.is_premium : !1;
    },
    languageCode: (e) => {
      var t, n, s, r;
      return (r = (s = (n = (t = window == null ? void 0 : window.Telegram) == null ? void 0 : t.WebApp) == null ? void 0 : n.initDataUnsafe) == null ? void 0 : s.user) != null && r.language_code ? window.Telegram.WebApp.initDataUnsafe.user.language_code : "ru";
    },
    userPlatform: (e) => {
      var t, n, s, r;
      return (n = (t = window == null ? void 0 : window.Telegram) == null ? void 0 : t.WebApp) != null && n.platform ? (r = (s = window == null ? void 0 : window.Telegram) == null ? void 0 : s.WebApp) == null ? void 0 : r.platform : "";
    },
    isDarkTheme: (e) => {
      var t;
      return ((t = e.platform) == null ? void 0 : t.isDarkTheme) ?? !0;
    }
  },
  actions: {
    setPlatformId(e) {
      this.platformId = e;
    },
    async init() {
      await this.loadPlatformAndTasks(), window.WallgramShowcase.onLoad(), window.dispatchEvent(new CustomEvent("WallgramShowcase_init"));
    },
    async startTask(e, t) {
      var o;
      const n = this.tasks.find((i) => i.id == e);
      if ((o = n.status) != null && o.createdAt)
        return !0;
      const { value: s, error: r } = await this.repo.CS.ShowcaseActions.startTask({
        taskId: e,
        campaignId: t,
        tgId: this.tgId,
        platformId: this.platform.id,
        language: this.languageCode
      });
      if (r)
        throw r;
      return n.status = {
        createdAt: /* @__PURE__ */ new Date(),
        expiredAt: new Date(s.expiredAt),
        hasReceivedReport: s.hasReceivedReport
      }, window.dispatchEvent(new CustomEvent("WallgramShowcase_startTask", { detail: e })), window.WallgramShowcase.onStartTask(s), !0;
    },
    async finishTask(e, t) {
      const { value: n, error: s } = await this.repo.CS.ShowcaseActions.finishTask({
        taskId: e,
        campaignId: t,
        tgId: this.tgId,
        platformId: this.platformId,
        language: this.languageCode
      });
      if (s)
        throw s;
      return window.dispatchEvent(new CustomEvent("WallgramShowcase_finishTask", { detail: e })), window.WallgramShowcase.onFinishTask(n), this.loadPlatformAndTasks(), !0;
    },
    async sendReport(e, t) {
      var o;
      const n = this.tasks.find((i) => i.id == e);
      if ((o = n.status) != null && o.hasReceivedReport)
        return !0;
      const { value: s, error: r } = await this.repo.CS.ShowcaseActions.sendReport({
        taskId: e,
        tgId: this.tgId,
        platformId: this.platformId,
        language: this.languageCode,
        ...t
      });
      if (r) throw r;
      return n.status.hasReceivedReport = !0, s;
    },
    async loadPlatformAndTasks() {
      this.showLoader = !0;
      const { value: e, error: t } = await this.repo.CS.ShowcaseActions.getPlatformAndTasks({
        tgId: this.tgId,
        platformId: this.platformId,
        isPremium: this.isPremium,
        language: this.languageCode,
        platform: this.userPlatform
      });
      this.showLoader = !1, !t && (this.platform = e.platform, this.tasks = e.tasks);
    }
  }
}), Xt = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [s, r] of t)
    n[s] = r;
  return n;
}, Kd = /* @__PURE__ */ lt({
  name: "CustomButtonFlat",
  props: {
    class: {
      type: [String, Array],
      default: ""
    },
    vibration: {
      default: "soft"
    },
    disabled: {
      default: !1
    },
    clickDuration: {
      default: 150
    },
    circle: {
      default: !1
    }
  },
  emits: ["click"],
  setup: (e, { emit: t }) => {
    let n = ue(null), s = function() {
      r(e.vibration), n.value && n.value.classList.add("active"), setTimeout(() => {
        n.value && n.value.classList.remove("active");
      }, e.clickDuration), t("click");
    };
    const r = function(o) {
      var i, l;
      (l = (i = window == null ? void 0 : window.Telegram) == null ? void 0 : i.WebApp) != null && l.HapticFeedback && window.Telegram.WebApp.HapticFeedback.impactOccurred(o);
    };
    return {
      clickHandler: s,
      btnRef: n
    };
  }
}), Gd = ["disabled"];
function qd(e, t, n, s, r, o) {
  return Q(), ge("div", {
    class: He(["wg-w-full button-wrapper", { "button-wrapper-disabled": e.$props.disabled }])
  }, [
    q("button", {
      class: He(["btn-wgs flex gap-[4px] items-center", e.$props.class]),
      ref: "btnRef",
      disabled: e.$props.disabled,
      onClick: t[0] || (t[0] = (...i) => e.clickHandler && e.clickHandler(...i))
    }, [
      Is(e.$slots, "default")
    ], 10, Gd)
  ], 2);
}
const Bo = /* @__PURE__ */ Xt(Kd, [["render", qd]]);
class Yd {
  constructor() {
    this.timerInstance = null, this.seconds = 0, this.timestampEnd = 0;
  }
  start(t, n = null) {
    console.log("start"), t !== null && (this.seconds = +t.toFixed()), clearInterval(this.timerInstance);
    let s = (/* @__PURE__ */ new Date()).getTime();
    this.timestampEnd = s + this.seconds * 1e3, this.timerInstance = setInterval(() => {
      let r = (/* @__PURE__ */ new Date()).getTime();
      this.seconds = Math.ceil(Math.max(this.timestampEnd - r, 0) / 1e3), this.seconds <= 0 && (clearInterval(this.timerInstance), typeof n == "function" && n());
    }, 1e3);
  }
}
/*!
  * shared v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const Gs = typeof window < "u", zt = (e, t = !1) => t ? Symbol.for(e) : Symbol(e), Jd = (e, t, n) => Xd({ l: e, k: t, s: n }), Xd = (e) => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), ke = (e) => typeof e == "number" && isFinite(e), zd = (e) => jo(e) === "[object Date]", Nn = (e) => jo(e) === "[object RegExp]", fr = (e) => Z(e) && Object.keys(e).length === 0, Oe = Object.assign;
let Yi;
const an = () => Yi || (Yi = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Ji(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const Zd = Object.prototype.hasOwnProperty;
function qs(e, t) {
  return Zd.call(e, t);
}
const be = Array.isArray, pe = (e) => typeof e == "function", W = (e) => typeof e == "string", ie = (e) => typeof e == "boolean", ae = (e) => e !== null && typeof e == "object", Qd = (e) => ae(e) && pe(e.then) && pe(e.catch), uc = Object.prototype.toString, jo = (e) => uc.call(e), Z = (e) => jo(e) === "[object Object]", eh = (e) => e == null ? "" : be(e) || Z(e) && e.toString === uc ? JSON.stringify(e, null, 2) : String(e);
function Ko(e, t = "") {
  return e.reduce((n, s, r) => r === 0 ? n + s : n + t + s, "");
}
function th(e, t) {
  typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack));
}
const Ls = (e) => !ae(e) || be(e);
function Ps(e, t) {
  if (Ls(e) || Ls(t))
    throw new Error("Invalid value");
  const n = [{ src: e, des: t }];
  for (; n.length; ) {
    const { src: s, des: r } = n.pop();
    Object.keys(s).forEach((o) => {
      ae(s[o]) && !ae(r[o]) && (r[o] = Array.isArray(s[o]) ? [] : {}), Ls(r[o]) || Ls(s[o]) ? r[o] = s[o] : n.push({ src: s[o], des: r[o] });
    });
  }
}
/*!
  * message-compiler v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function nh(e, t, n) {
  return { line: e, column: t, offset: n };
}
function ro(e, t, n) {
  return { start: e, end: t };
}
const fe = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16
}, sh = 17;
function dr(e, t, n = {}) {
  const { domain: s, messages: r, args: o } = n, i = e, l = new SyntaxError(String(i));
  return l.code = e, t && (l.location = t), l.domain = s, l;
}
function rh(e) {
  throw e;
}
const Et = " ", oh = "\r", Fe = `
`, ih = "\u2028", lh = "\u2029";
function ah(e) {
  const t = e;
  let n = 0, s = 1, r = 1, o = 0;
  const i = (N) => t[N] === oh && t[N + 1] === Fe, l = (N) => t[N] === Fe, a = (N) => t[N] === lh, c = (N) => t[N] === ih, u = (N) => i(N) || l(N) || a(N) || c(N), f = () => n, p = () => s, b = () => r, _ = () => o, T = (N) => i(N) || a(N) || c(N) ? Fe : t[N], C = () => T(n), g = () => T(n + o);
  function v() {
    return o = 0, u(n) && (s++, r = 0), i(n) && n++, n++, r++, t[n];
  }
  function L() {
    return i(n + o) && o++, o++, t[n + o];
  }
  function E() {
    n = 0, s = 1, r = 1, o = 0;
  }
  function O(N = 0) {
    o = N;
  }
  function F() {
    const N = n + o;
    for (; N !== n; )
      v();
    o = 0;
  }
  return {
    index: f,
    line: p,
    column: b,
    peekOffset: _,
    charAt: T,
    currentChar: C,
    currentPeek: g,
    next: v,
    peek: L,
    reset: E,
    resetPeek: O,
    skipToPeek: F
  };
}
const Ft = void 0, ch = ".", Xi = "'", uh = "tokenizer";
function fh(e, t = {}) {
  const n = t.location !== !1, s = ah(e), r = () => s.index(), o = () => nh(s.line(), s.column(), s.index()), i = o(), l = r(), a = {
    currentType: 13,
    offset: l,
    startLoc: i,
    endLoc: i,
    lastType: 13,
    lastOffset: l,
    lastStartLoc: i,
    lastEndLoc: i,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, c = () => a, { onError: u } = t;
  function f(d, h, S, ...A) {
    const x = c();
    if (h.column += S, h.offset += S, u) {
      const $ = n ? ro(x.startLoc, h) : null, y = dr(d, $, {
        domain: uh,
        args: A
      });
      u(y);
    }
  }
  function p(d, h, S) {
    d.endLoc = o(), d.currentType = h;
    const A = { type: h };
    return n && (A.loc = ro(d.startLoc, d.endLoc)), S != null && (A.value = S), A;
  }
  const b = (d) => p(
    d,
    13
    /* TokenTypes.EOF */
  );
  function _(d, h) {
    return d.currentChar() === h ? (d.next(), h) : (f(fe.EXPECTED_TOKEN, o(), 0, h), "");
  }
  function T(d) {
    let h = "";
    for (; d.currentPeek() === Et || d.currentPeek() === Fe; )
      h += d.currentPeek(), d.peek();
    return h;
  }
  function C(d) {
    const h = T(d);
    return d.skipToPeek(), h;
  }
  function g(d) {
    if (d === Ft)
      return !1;
    const h = d.charCodeAt(0);
    return h >= 97 && h <= 122 || // a-z
    h >= 65 && h <= 90 || // A-Z
    h === 95;
  }
  function v(d) {
    if (d === Ft)
      return !1;
    const h = d.charCodeAt(0);
    return h >= 48 && h <= 57;
  }
  function L(d, h) {
    const { currentType: S } = h;
    if (S !== 2)
      return !1;
    T(d);
    const A = g(d.currentPeek());
    return d.resetPeek(), A;
  }
  function E(d, h) {
    const { currentType: S } = h;
    if (S !== 2)
      return !1;
    T(d);
    const A = d.currentPeek() === "-" ? d.peek() : d.currentPeek(), x = v(A);
    return d.resetPeek(), x;
  }
  function O(d, h) {
    const { currentType: S } = h;
    if (S !== 2)
      return !1;
    T(d);
    const A = d.currentPeek() === Xi;
    return d.resetPeek(), A;
  }
  function F(d, h) {
    const { currentType: S } = h;
    if (S !== 7)
      return !1;
    T(d);
    const A = d.currentPeek() === ".";
    return d.resetPeek(), A;
  }
  function N(d, h) {
    const { currentType: S } = h;
    if (S !== 8)
      return !1;
    T(d);
    const A = g(d.currentPeek());
    return d.resetPeek(), A;
  }
  function H(d, h) {
    const { currentType: S } = h;
    if (!(S === 7 || S === 11))
      return !1;
    T(d);
    const A = d.currentPeek() === ":";
    return d.resetPeek(), A;
  }
  function P(d, h) {
    const { currentType: S } = h;
    if (S !== 9)
      return !1;
    const A = () => {
      const $ = d.currentPeek();
      return $ === "{" ? g(d.peek()) : $ === "@" || $ === "|" || $ === ":" || $ === "." || $ === Et || !$ ? !1 : $ === Fe ? (d.peek(), A()) : Y(d, !1);
    }, x = A();
    return d.resetPeek(), x;
  }
  function B(d) {
    T(d);
    const h = d.currentPeek() === "|";
    return d.resetPeek(), h;
  }
  function Y(d, h = !0) {
    const S = (x = !1, $ = "") => {
      const y = d.currentPeek();
      return y === "{" || y === "@" || !y ? x : y === "|" ? !($ === Et || $ === Fe) : y === Et ? (d.peek(), S(!0, Et)) : y === Fe ? (d.peek(), S(!0, Fe)) : !0;
    }, A = S();
    return h && d.resetPeek(), A;
  }
  function U(d, h) {
    const S = d.currentChar();
    return S === Ft ? Ft : h(S) ? (d.next(), S) : null;
  }
  function j(d) {
    const h = d.charCodeAt(0);
    return h >= 97 && h <= 122 || // a-z
    h >= 65 && h <= 90 || // A-Z
    h >= 48 && h <= 57 || // 0-9
    h === 95 || // _
    h === 36;
  }
  function ee(d) {
    return U(d, j);
  }
  function _e(d) {
    const h = d.charCodeAt(0);
    return h >= 97 && h <= 122 || // a-z
    h >= 65 && h <= 90 || // A-Z
    h >= 48 && h <= 57 || // 0-9
    h === 95 || // _
    h === 36 || // $
    h === 45;
  }
  function le(d) {
    return U(d, _e);
  }
  function X(d) {
    const h = d.charCodeAt(0);
    return h >= 48 && h <= 57;
  }
  function se(d) {
    return U(d, X);
  }
  function ve(d) {
    const h = d.charCodeAt(0);
    return h >= 48 && h <= 57 || // 0-9
    h >= 65 && h <= 70 || // A-F
    h >= 97 && h <= 102;
  }
  function _t(d) {
    return U(d, ve);
  }
  function nt(d) {
    let h = "", S = "";
    for (; h = se(d); )
      S += h;
    return S;
  }
  function We(d) {
    let h = "";
    for (; ; ) {
      const S = d.currentChar();
      if (S === "{" || S === "}" || S === "@" || S === "|" || !S)
        break;
      if (S === Et || S === Fe)
        if (Y(d))
          h += S, d.next();
        else {
          if (B(d))
            break;
          h += S, d.next();
        }
      else
        h += S, d.next();
    }
    return h;
  }
  function mn(d) {
    C(d);
    let h = "", S = "";
    for (; h = le(d); )
      S += h;
    return d.currentChar() === Ft && f(fe.UNTERMINATED_CLOSING_BRACE, o(), 0), S;
  }
  function $n(d) {
    C(d);
    let h = "";
    return d.currentChar() === "-" ? (d.next(), h += `-${nt(d)}`) : h += nt(d), d.currentChar() === Ft && f(fe.UNTERMINATED_CLOSING_BRACE, o(), 0), h;
  }
  function ys(d) {
    return d !== Xi && d !== Fe;
  }
  function bt(d) {
    C(d), _(d, "'");
    let h = "", S = "";
    for (; h = U(d, ys); )
      h === "\\" ? S += Rt(d) : S += h;
    const A = d.currentChar();
    return A === Fe || A === Ft ? (f(fe.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, o(), 0), A === Fe && (d.next(), _(d, "'")), S) : (_(d, "'"), S);
  }
  function Rt(d) {
    const h = d.currentChar();
    switch (h) {
      case "\\":
      case "'":
        return d.next(), `\\${h}`;
      case "u":
        return Nt(d, h, 4);
      case "U":
        return Nt(d, h, 6);
      default:
        return f(fe.UNKNOWN_ESCAPE_SEQUENCE, o(), 0, h), "";
    }
  }
  function Nt(d, h, S) {
    _(d, h);
    let A = "";
    for (let x = 0; x < S; x++) {
      const $ = _t(d);
      if (!$) {
        f(fe.INVALID_UNICODE_ESCAPE_SEQUENCE, o(), 0, `\\${h}${A}${d.currentChar()}`);
        break;
      }
      A += $;
    }
    return `\\${h}${A}`;
  }
  function gn(d) {
    return d !== "{" && d !== "}" && d !== Et && d !== Fe;
  }
  function wt(d) {
    C(d);
    let h = "", S = "";
    for (; h = U(d, gn); )
      S += h;
    return S;
  }
  function _n(d) {
    let h = "", S = "";
    for (; h = ee(d); )
      S += h;
    return S;
  }
  function bn(d) {
    const h = (S) => {
      const A = d.currentChar();
      return A === "{" || A === "@" || A === "|" || A === "(" || A === ")" || !A || A === Et ? S : (S += A, d.next(), h(S));
    };
    return h("");
  }
  function m(d) {
    C(d);
    const h = _(
      d,
      "|"
      /* TokenChars.Pipe */
    );
    return C(d), h;
  }
  function w(d, h) {
    let S = null;
    switch (d.currentChar()) {
      case "{":
        return h.braceNest >= 1 && f(fe.NOT_ALLOW_NEST_PLACEHOLDER, o(), 0), d.next(), S = p(
          h,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), C(d), h.braceNest++, S;
      case "}":
        return h.braceNest > 0 && h.currentType === 2 && f(fe.EMPTY_PLACEHOLDER, o(), 0), d.next(), S = p(
          h,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), h.braceNest--, h.braceNest > 0 && C(d), h.inLinked && h.braceNest === 0 && (h.inLinked = !1), S;
      case "@":
        return h.braceNest > 0 && f(fe.UNTERMINATED_CLOSING_BRACE, o(), 0), S = R(d, h) || b(h), h.braceNest = 0, S;
      default: {
        let x = !0, $ = !0, y = !0;
        if (B(d))
          return h.braceNest > 0 && f(fe.UNTERMINATED_CLOSING_BRACE, o(), 0), S = p(h, 1, m(d)), h.braceNest = 0, h.inLinked = !1, S;
        if (h.braceNest > 0 && (h.currentType === 4 || h.currentType === 5 || h.currentType === 6))
          return f(fe.UNTERMINATED_CLOSING_BRACE, o(), 0), h.braceNest = 0, M(d, h);
        if (x = L(d, h))
          return S = p(h, 4, mn(d)), C(d), S;
        if ($ = E(d, h))
          return S = p(h, 5, $n(d)), C(d), S;
        if (y = O(d, h))
          return S = p(h, 6, bt(d)), C(d), S;
        if (!x && !$ && !y)
          return S = p(h, 12, wt(d)), f(fe.INVALID_TOKEN_IN_PLACEHOLDER, o(), 0, S.value), C(d), S;
        break;
      }
    }
    return S;
  }
  function R(d, h) {
    const { currentType: S } = h;
    let A = null;
    const x = d.currentChar();
    switch ((S === 7 || S === 8 || S === 11 || S === 9) && (x === Fe || x === Et) && f(fe.INVALID_LINKED_FORMAT, o(), 0), x) {
      case "@":
        return d.next(), A = p(
          h,
          7,
          "@"
          /* TokenChars.LinkedAlias */
        ), h.inLinked = !0, A;
      case ".":
        return C(d), d.next(), p(
          h,
          8,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return C(d), d.next(), p(
          h,
          9,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return B(d) ? (A = p(h, 1, m(d)), h.braceNest = 0, h.inLinked = !1, A) : F(d, h) || H(d, h) ? (C(d), R(d, h)) : N(d, h) ? (C(d), p(h, 11, _n(d))) : P(d, h) ? (C(d), x === "{" ? w(d, h) || A : p(h, 10, bn(d))) : (S === 7 && f(fe.INVALID_LINKED_FORMAT, o(), 0), h.braceNest = 0, h.inLinked = !1, M(d, h));
    }
  }
  function M(d, h) {
    let S = {
      type: 13
      /* TokenTypes.EOF */
    };
    if (h.braceNest > 0)
      return w(d, h) || b(h);
    if (h.inLinked)
      return R(d, h) || b(h);
    switch (d.currentChar()) {
      case "{":
        return w(d, h) || b(h);
      case "}":
        return f(fe.UNBALANCED_CLOSING_BRACE, o(), 0), d.next(), p(
          h,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return R(d, h) || b(h);
      default: {
        if (B(d))
          return S = p(h, 1, m(d)), h.braceNest = 0, h.inLinked = !1, S;
        if (Y(d))
          return p(h, 0, We(d));
        break;
      }
    }
    return S;
  }
  function D() {
    const { currentType: d, offset: h, startLoc: S, endLoc: A } = a;
    return a.lastType = d, a.lastOffset = h, a.lastStartLoc = S, a.lastEndLoc = A, a.offset = r(), a.startLoc = o(), s.currentChar() === Ft ? p(
      a,
      13
      /* TokenTypes.EOF */
    ) : M(s, a);
  }
  return {
    nextToken: D,
    currentOffset: r,
    currentPosition: o,
    context: c
  };
}
const dh = "parser", hh = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function ph(e, t, n) {
  switch (e) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const s = parseInt(t || n, 16);
      return s <= 55295 || s >= 57344 ? String.fromCodePoint(s) : "�";
    }
  }
}
function mh(e = {}) {
  const t = e.location !== !1, { onError: n } = e;
  function s(g, v, L, E, ...O) {
    const F = g.currentPosition();
    if (F.offset += E, F.column += E, n) {
      const N = t ? ro(L, F) : null, H = dr(v, N, {
        domain: dh,
        args: O
      });
      n(H);
    }
  }
  function r(g, v, L) {
    const E = { type: g };
    return t && (E.start = v, E.end = v, E.loc = { start: L, end: L }), E;
  }
  function o(g, v, L, E) {
    t && (g.end = v, g.loc && (g.loc.end = L));
  }
  function i(g, v) {
    const L = g.context(), E = r(3, L.offset, L.startLoc);
    return E.value = v, o(E, g.currentOffset(), g.currentPosition()), E;
  }
  function l(g, v) {
    const L = g.context(), { lastOffset: E, lastStartLoc: O } = L, F = r(5, E, O);
    return F.index = parseInt(v, 10), g.nextToken(), o(F, g.currentOffset(), g.currentPosition()), F;
  }
  function a(g, v) {
    const L = g.context(), { lastOffset: E, lastStartLoc: O } = L, F = r(4, E, O);
    return F.key = v, g.nextToken(), o(F, g.currentOffset(), g.currentPosition()), F;
  }
  function c(g, v) {
    const L = g.context(), { lastOffset: E, lastStartLoc: O } = L, F = r(9, E, O);
    return F.value = v.replace(hh, ph), g.nextToken(), o(F, g.currentOffset(), g.currentPosition()), F;
  }
  function u(g) {
    const v = g.nextToken(), L = g.context(), { lastOffset: E, lastStartLoc: O } = L, F = r(8, E, O);
    return v.type !== 11 ? (s(g, fe.UNEXPECTED_EMPTY_LINKED_MODIFIER, L.lastStartLoc, 0), F.value = "", o(F, E, O), {
      nextConsumeToken: v,
      node: F
    }) : (v.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, L.lastStartLoc, 0, ht(v)), F.value = v.value || "", o(F, g.currentOffset(), g.currentPosition()), {
      node: F
    });
  }
  function f(g, v) {
    const L = g.context(), E = r(7, L.offset, L.startLoc);
    return E.value = v, o(E, g.currentOffset(), g.currentPosition()), E;
  }
  function p(g) {
    const v = g.context(), L = r(6, v.offset, v.startLoc);
    let E = g.nextToken();
    if (E.type === 8) {
      const O = u(g);
      L.modifier = O.node, E = O.nextConsumeToken || g.nextToken();
    }
    switch (E.type !== 9 && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(E)), E = g.nextToken(), E.type === 2 && (E = g.nextToken()), E.type) {
      case 10:
        E.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(E)), L.key = f(g, E.value || "");
        break;
      case 4:
        E.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(E)), L.key = a(g, E.value || "");
        break;
      case 5:
        E.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(E)), L.key = l(g, E.value || "");
        break;
      case 6:
        E.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(E)), L.key = c(g, E.value || "");
        break;
      default: {
        s(g, fe.UNEXPECTED_EMPTY_LINKED_KEY, v.lastStartLoc, 0);
        const O = g.context(), F = r(7, O.offset, O.startLoc);
        return F.value = "", o(F, O.offset, O.startLoc), L.key = F, o(L, O.offset, O.startLoc), {
          nextConsumeToken: E,
          node: L
        };
      }
    }
    return o(L, g.currentOffset(), g.currentPosition()), {
      node: L
    };
  }
  function b(g) {
    const v = g.context(), L = v.currentType === 1 ? g.currentOffset() : v.offset, E = v.currentType === 1 ? v.endLoc : v.startLoc, O = r(2, L, E);
    O.items = [];
    let F = null;
    do {
      const P = F || g.nextToken();
      switch (F = null, P.type) {
        case 0:
          P.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(P)), O.items.push(i(g, P.value || ""));
          break;
        case 5:
          P.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(P)), O.items.push(l(g, P.value || ""));
          break;
        case 4:
          P.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(P)), O.items.push(a(g, P.value || ""));
          break;
        case 6:
          P.value == null && s(g, fe.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, ht(P)), O.items.push(c(g, P.value || ""));
          break;
        case 7: {
          const B = p(g);
          O.items.push(B.node), F = B.nextConsumeToken || null;
          break;
        }
      }
    } while (v.currentType !== 13 && v.currentType !== 1);
    const N = v.currentType === 1 ? v.lastOffset : g.currentOffset(), H = v.currentType === 1 ? v.lastEndLoc : g.currentPosition();
    return o(O, N, H), O;
  }
  function _(g, v, L, E) {
    const O = g.context();
    let F = E.items.length === 0;
    const N = r(1, v, L);
    N.cases = [], N.cases.push(E);
    do {
      const H = b(g);
      F || (F = H.items.length === 0), N.cases.push(H);
    } while (O.currentType !== 13);
    return F && s(g, fe.MUST_HAVE_MESSAGES_IN_PLURAL, L, 0), o(N, g.currentOffset(), g.currentPosition()), N;
  }
  function T(g) {
    const v = g.context(), { offset: L, startLoc: E } = v, O = b(g);
    return v.currentType === 13 ? O : _(g, L, E, O);
  }
  function C(g) {
    const v = fh(g, Oe({}, e)), L = v.context(), E = r(0, L.offset, L.startLoc);
    return t && E.loc && (E.loc.source = g), E.body = T(v), e.onCacheKey && (E.cacheKey = e.onCacheKey(g)), L.currentType !== 13 && s(v, fe.UNEXPECTED_LEXICAL_ANALYSIS, L.lastStartLoc, 0, g[L.offset] || ""), o(E, v.currentOffset(), v.currentPosition()), E;
  }
  return { parse: C };
}
function ht(e) {
  if (e.type === 13)
    return "EOF";
  const t = (e.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "…" : t;
}
function gh(e, t = {}) {
  const n = {
    ast: e,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (o) => (n.helpers.add(o), o) };
}
function zi(e, t) {
  for (let n = 0; n < e.length; n++)
    Go(e[n], t);
}
function Go(e, t) {
  switch (e.type) {
    case 1:
      zi(e.cases, t), t.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      zi(e.items, t);
      break;
    case 6: {
      Go(e.key, t), t.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), t.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function _h(e, t = {}) {
  const n = gh(e);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), e.body && Go(e.body, n);
  const s = n.context();
  e.helpers = Array.from(s.helpers);
}
function bh(e) {
  const t = e.body;
  return t.type === 2 ? Zi(t) : t.cases.forEach((n) => Zi(n)), e;
}
function Zi(e) {
  if (e.items.length === 1) {
    const t = e.items[0];
    (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value);
  } else {
    const t = [];
    for (let n = 0; n < e.items.length; n++) {
      const s = e.items[n];
      if (!(s.type === 3 || s.type === 9) || s.value == null)
        break;
      t.push(s.value);
    }
    if (t.length === e.items.length) {
      e.static = Ko(t);
      for (let n = 0; n < e.items.length; n++) {
        const s = e.items[n];
        (s.type === 3 || s.type === 9) && delete s.value;
      }
    }
  }
}
function vn(e) {
  switch (e.t = e.type, e.type) {
    case 0: {
      const t = e;
      vn(t.body), t.b = t.body, delete t.body;
      break;
    }
    case 1: {
      const t = e, n = t.cases;
      for (let s = 0; s < n.length; s++)
        vn(n[s]);
      t.c = n, delete t.cases;
      break;
    }
    case 2: {
      const t = e, n = t.items;
      for (let s = 0; s < n.length; s++)
        vn(n[s]);
      t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e;
      t.value && (t.v = t.value, delete t.value);
      break;
    }
    case 6: {
      const t = e;
      vn(t.key), t.k = t.key, delete t.key, t.modifier && (vn(t.modifier), t.m = t.modifier, delete t.modifier);
      break;
    }
    case 5: {
      const t = e;
      t.i = t.index, delete t.index;
      break;
    }
    case 4: {
      const t = e;
      t.k = t.key, delete t.key;
      break;
    }
  }
  delete e.type;
}
function wh(e, t) {
  const { sourceMap: n, filename: s, breakLineCode: r, needIndent: o } = t, i = t.location !== !1, l = {
    filename: s,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: r,
    needIndent: o,
    indentLevel: 0
  };
  i && e.loc && (l.source = e.loc.source);
  const a = () => l;
  function c(C, g) {
    l.code += C;
  }
  function u(C, g = !0) {
    const v = g ? r : "";
    c(o ? v + "  ".repeat(C) : v);
  }
  function f(C = !0) {
    const g = ++l.indentLevel;
    C && u(g);
  }
  function p(C = !0) {
    const g = --l.indentLevel;
    C && u(g);
  }
  function b() {
    u(l.indentLevel);
  }
  return {
    context: a,
    push: c,
    indent: f,
    deindent: p,
    newline: b,
    helper: (C) => `_${C}`,
    needIndent: () => l.needIndent
  };
}
function yh(e, t) {
  const { helper: n } = e;
  e.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), xn(e, t.key), t.modifier ? (e.push(", "), xn(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")");
}
function Eh(e, t) {
  const { helper: n, needIndent: s } = e;
  e.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), e.indent(s());
  const r = t.items.length;
  for (let o = 0; o < r && (xn(e, t.items[o]), o !== r - 1); o++)
    e.push(", ");
  e.deindent(s()), e.push("])");
}
function Th(e, t) {
  const { helper: n, needIndent: s } = e;
  if (t.cases.length > 1) {
    e.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), e.indent(s());
    const r = t.cases.length;
    for (let o = 0; o < r && (xn(e, t.cases[o]), o !== r - 1); o++)
      e.push(", ");
    e.deindent(s()), e.push("])");
  }
}
function Sh(e, t) {
  t.body ? xn(e, t.body) : e.push("null");
}
function xn(e, t) {
  const { helper: n } = e;
  switch (t.type) {
    case 0:
      Sh(e, t);
      break;
    case 1:
      Th(e, t);
      break;
    case 2:
      Eh(e, t);
      break;
    case 6:
      yh(e, t);
      break;
    case 8:
      e.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${t.index}))`, t);
      break;
    case 4:
      e.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e.push(JSON.stringify(t.value), t);
      break;
  }
}
const vh = (e, t = {}) => {
  const n = W(t.mode) ? t.mode : "normal", s = W(t.filename) ? t.filename : "message.intl", r = !!t.sourceMap, o = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`, i = t.needIndent ? t.needIndent : n !== "arrow", l = e.helpers || [], a = wh(e, {
    mode: n,
    filename: s,
    sourceMap: r,
    breakLineCode: o,
    needIndent: i
  });
  a.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), a.indent(i), l.length > 0 && (a.push(`const { ${Ko(l.map((f) => `${f}: _${f}`), ", ")} } = ctx`), a.newline()), a.push("return "), xn(a, e), a.deindent(i), a.push("}"), delete e.helpers;
  const { code: c, map: u } = a.context();
  return {
    ast: e,
    code: c,
    map: u ? u.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function Ch(e, t = {}) {
  const n = Oe({}, t), s = !!n.jit, r = !!n.minify, o = n.optimize == null ? !0 : n.optimize, l = mh(n).parse(e);
  return s ? (o && bh(l), r && vn(l), { ast: l, code: "" }) : (_h(l, n), vh(l, n));
}
/*!
  * core-base v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function Lh() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (an().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (an().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
function Fr(e) {
  return (n) => kh(n, e);
}
function kh(e, t) {
  const n = t.b || t.body;
  if ((n.t || n.type) === 1) {
    const s = n, r = s.c || s.cases;
    return e.plural(r.reduce((o, i) => [
      ...o,
      Qi(e, i)
    ], []));
  } else
    return Qi(e, n);
}
function Qi(e, t) {
  const n = t.s || t.static;
  if (n != null)
    return e.type === "text" ? n : e.normalize([n]);
  {
    const s = (t.i || t.items).reduce((r, o) => [...r, oo(e, o)], []);
    return e.normalize(s);
  }
}
function oo(e, t) {
  const n = t.t || t.type;
  switch (n) {
    case 3: {
      const s = t;
      return s.v || s.value;
    }
    case 9: {
      const s = t;
      return s.v || s.value;
    }
    case 4: {
      const s = t;
      return e.interpolate(e.named(s.k || s.key));
    }
    case 5: {
      const s = t;
      return e.interpolate(e.list(s.i != null ? s.i : s.index));
    }
    case 6: {
      const s = t, r = s.m || s.modifier;
      return e.linked(oo(e, s.k || s.key), r ? oo(e, r) : void 0, e.type);
    }
    case 7: {
      const s = t;
      return s.v || s.value;
    }
    case 8: {
      const s = t;
      return s.v || s.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${n}`);
  }
}
const Ah = (e) => e;
let ks = /* @__PURE__ */ Object.create(null);
const Pn = (e) => ae(e) && (e.t === 0 || e.type === 0) && ("b" in e || "body" in e);
function Oh(e, t = {}) {
  let n = !1;
  const s = t.onError || rh;
  return t.onError = (r) => {
    n = !0, s(r);
  }, { ...Ch(e, t), detectError: n };
}
// @__NO_SIDE_EFFECTS__
function Ih(e, t) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && W(e)) {
    ie(t.warnHtmlMessage) && t.warnHtmlMessage;
    const s = (t.onCacheKey || Ah)(e), r = ks[s];
    if (r)
      return r;
    const { ast: o, detectError: i } = Oh(e, {
      ...t,
      location: !1,
      jit: !0
    }), l = Fr(o);
    return i ? l : ks[s] = l;
  } else {
    const n = e.cacheKey;
    if (n) {
      const s = ks[n];
      return s || (ks[n] = Fr(e));
    } else
      return Fr(e);
  }
}
let ls = null;
function Rh(e) {
  ls = e;
}
function Nh(e, t, n) {
  ls && ls.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e,
    version: t,
    meta: n
  });
}
const xh = /* @__PURE__ */ Ph("function:translate");
function Ph(e) {
  return (t) => ls && ls.emit(e, t);
}
const Lt = {
  INVALID_ARGUMENT: sh,
  // 17
  INVALID_DATE_ARGUMENT: 18,
  INVALID_ISO_DATE_ARGUMENT: 19,
  NOT_SUPPORT_NON_STRING_MESSAGE: 20,
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
  NOT_SUPPORT_LOCALE_TYPE: 23
}, Fh = 24;
function kt(e) {
  return dr(e, null, void 0);
}
function qo(e, t) {
  return t.locale != null ? el(t.locale) : el(e.locale);
}
let Dr;
function el(e) {
  if (W(e))
    return e;
  if (pe(e)) {
    if (e.resolvedOnce && Dr != null)
      return Dr;
    if (e.constructor.name === "Function") {
      const t = e();
      if (Qd(t))
        throw kt(Lt.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return Dr = t;
    } else
      throw kt(Lt.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw kt(Lt.NOT_SUPPORT_LOCALE_TYPE);
}
function Dh(e, t, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...be(t) ? t : ae(t) ? Object.keys(t) : W(t) ? [t] : [n]
  ])];
}
function fc(e, t, n) {
  const s = W(n) ? n : as, r = e;
  r.__localeChainCache || (r.__localeChainCache = /* @__PURE__ */ new Map());
  let o = r.__localeChainCache.get(s);
  if (!o) {
    o = [];
    let i = [n];
    for (; be(i); )
      i = tl(o, i, t);
    const l = be(t) || !Z(t) ? t : t.default ? t.default : null;
    i = W(l) ? [l] : l, be(i) && tl(o, i, !1), r.__localeChainCache.set(s, o);
  }
  return o;
}
function tl(e, t, n) {
  let s = !0;
  for (let r = 0; r < t.length && ie(s); r++) {
    const o = t[r];
    W(o) && (s = Mh(e, t[r], n));
  }
  return s;
}
function Mh(e, t, n) {
  let s;
  const r = t.split("-");
  do {
    const o = r.join("-");
    s = $h(e, o, n), r.splice(-1, 1);
  } while (r.length && s === !0);
  return s;
}
function $h(e, t, n) {
  let s = !1;
  if (!e.includes(t) && (s = !0, t)) {
    s = t[t.length - 1] !== "!";
    const r = t.replace(/!/g, "");
    e.push(r), (be(n) || Z(n)) && n[r] && (s = n[r]);
  }
  return s;
}
const Zt = [];
Zt[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Zt[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Zt[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
Zt[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
Zt[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
Zt[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
Zt[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const Uh = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function Hh(e) {
  return Uh.test(e);
}
function Vh(e) {
  const t = e.charCodeAt(0), n = e.charCodeAt(e.length - 1);
  return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e;
}
function Wh(e) {
  if (e == null)
    return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function Bh(e) {
  const t = e.trim();
  return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : Hh(t) ? Vh(t) : "*" + t;
}
function jh(e) {
  const t = [];
  let n = -1, s = 0, r = 0, o, i, l, a, c, u, f;
  const p = [];
  p[
    0
    /* Actions.APPEND */
  ] = () => {
    i === void 0 ? i = l : i += l;
  }, p[
    1
    /* Actions.PUSH */
  ] = () => {
    i !== void 0 && (t.push(i), i = void 0);
  }, p[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    p[
      0
      /* Actions.APPEND */
    ](), r++;
  }, p[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (r > 0)
      r--, s = 4, p[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (r = 0, i === void 0 || (i = Bh(i), i === !1))
        return !1;
      p[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function b() {
    const _ = e[n + 1];
    if (s === 5 && _ === "'" || s === 6 && _ === '"')
      return n++, l = "\\" + _, p[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; s !== null; )
    if (n++, o = e[n], !(o === "\\" && b())) {
      if (a = Wh(o), f = Zt[s], c = f[a] || f.l || 8, c === 8 || (s = c[0], c[1] !== void 0 && (u = p[c[1]], u && (l = o, u() === !1))))
        return;
      if (s === 7)
        return t;
    }
}
const nl = /* @__PURE__ */ new Map();
function Kh(e, t) {
  return ae(e) ? e[t] : null;
}
function Gh(e, t) {
  if (!ae(e))
    return null;
  let n = nl.get(t);
  if (n || (n = jh(t), n && nl.set(t, n)), !n)
    return null;
  const s = n.length;
  let r = e, o = 0;
  for (; o < s; ) {
    const i = r[n[o]];
    if (i === void 0 || pe(r))
      return null;
    r = i, o++;
  }
  return r;
}
const qh = "10.0.4", hr = -1, as = "en-US", sl = "", rl = (e) => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;
function Yh() {
  return {
    upper: (e, t) => t === "text" && W(e) ? e.toUpperCase() : t === "vnode" && ae(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
    lower: (e, t) => t === "text" && W(e) ? e.toLowerCase() : t === "vnode" && ae(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
    capitalize: (e, t) => t === "text" && W(e) ? rl(e) : t === "vnode" && ae(e) && "__v_isVNode" in e ? rl(e.children) : e
  };
}
let dc;
function Jh(e) {
  dc = e;
}
let hc;
function Xh(e) {
  hc = e;
}
let pc;
function zh(e) {
  pc = e;
}
let mc = null;
const Zh = /* @__NO_SIDE_EFFECTS__ */ (e) => {
  mc = e;
}, Qh = /* @__NO_SIDE_EFFECTS__ */ () => mc;
let wallgramGc = null;
const ol = (e) => {
  wallgramGc = e;
}, ep = () => wallgramGc;
let il = 0;
function tp(e = {}) {
  const t = pe(e.onWarn) ? e.onWarn : th, n = W(e.version) ? e.version : qh, s = W(e.locale) || pe(e.locale) ? e.locale : as, r = pe(s) ? as : s, o = be(e.fallbackLocale) || Z(e.fallbackLocale) || W(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : r, i = Z(e.messages) ? e.messages : { [r]: {} }, l = Z(e.datetimeFormats) ? e.datetimeFormats : { [r]: {} }, a = Z(e.numberFormats) ? e.numberFormats : { [r]: {} }, c = Oe({}, e.modifiers || {}, Yh()), u = e.pluralRules || {}, f = pe(e.missing) ? e.missing : null, p = ie(e.missingWarn) || Nn(e.missingWarn) ? e.missingWarn : !0, b = ie(e.fallbackWarn) || Nn(e.fallbackWarn) ? e.fallbackWarn : !0, _ = !!e.fallbackFormat, T = !!e.unresolving, C = pe(e.postTranslation) ? e.postTranslation : null, g = Z(e.processor) ? e.processor : null, v = ie(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, L = !!e.escapeParameter, E = pe(e.messageCompiler) ? e.messageCompiler : dc, O = pe(e.messageResolver) ? e.messageResolver : hc || Kh, F = pe(e.localeFallbacker) ? e.localeFallbacker : pc || Dh, N = ae(e.fallbackContext) ? e.fallbackContext : void 0, H = e, P = ae(H.__datetimeFormatters) ? H.__datetimeFormatters : /* @__PURE__ */ new Map(), B = ae(H.__numberFormatters) ? H.__numberFormatters : /* @__PURE__ */ new Map(), Y = ae(H.__meta) ? H.__meta : {};
  il++;
  const U = {
    version: n,
    cid: il,
    locale: s,
    fallbackLocale: o,
    messages: i,
    modifiers: c,
    pluralRules: u,
    missing: f,
    missingWarn: p,
    fallbackWarn: b,
    fallbackFormat: _,
    unresolving: T,
    postTranslation: C,
    processor: g,
    warnHtmlMessage: v,
    escapeParameter: L,
    messageCompiler: E,
    messageResolver: O,
    localeFallbacker: F,
    fallbackContext: N,
    onWarn: t,
    __meta: Y
  };
  return U.datetimeFormats = l, U.numberFormats = a, U.__datetimeFormatters = P, U.__numberFormatters = B, __INTLIFY_PROD_DEVTOOLS__ && Nh(U, n, Y), U;
}
function Yo(e, t, n, s, r) {
  const { missing: o, onWarn: i } = e;
  if (o !== null) {
    const l = o(e, n, t, r);
    return W(l) ? l : t;
  } else
    return t;
}
function Bn(e, t, n) {
  const s = e;
  s.__localeChainCache = /* @__PURE__ */ new Map(), e.localeFallbacker(e, n, t);
}
function np(e, t) {
  return e === t ? !1 : e.split("-")[0] === t.split("-")[0];
}
function sp(e, t) {
  const n = t.indexOf(e);
  if (n === -1)
    return !1;
  for (let s = n + 1; s < t.length; s++)
    if (np(e, t[s]))
      return !0;
  return !1;
}
function ll(e, ...t) {
  const { datetimeFormats: n, unresolving: s, fallbackLocale: r, onWarn: o, localeFallbacker: i } = e, { __datetimeFormatters: l } = e, [a, c, u, f] = io(...t), p = ie(u.missingWarn) ? u.missingWarn : e.missingWarn;
  ie(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn;
  const b = !!u.part, _ = qo(e, u), T = i(
    e,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    _
  );
  if (!W(a) || a === "")
    return new Intl.DateTimeFormat(_, f).format(c);
  let C = {}, g, v = null;
  const L = "datetime format";
  for (let F = 0; F < T.length && (g = T[F], C = n[g] || {}, v = C[a], !Z(v)); F++)
    Yo(e, a, g, p, L);
  if (!Z(v) || !W(g))
    return s ? hr : a;
  let E = `${g}__${a}`;
  fr(f) || (E = `${E}__${JSON.stringify(f)}`);
  let O = l.get(E);
  return O || (O = new Intl.DateTimeFormat(g, Oe({}, v, f)), l.set(E, O)), b ? O.formatToParts(c) : O.format(c);
}
const _c = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function io(...e) {
  const [t, n, s, r] = e, o = {};
  let i = {}, l;
  if (W(t)) {
    const a = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!a)
      throw kt(Lt.INVALID_ISO_DATE_ARGUMENT);
    const c = a[3] ? a[3].trim().startsWith("T") ? `${a[1].trim()}${a[3].trim()}` : `${a[1].trim()}T${a[3].trim()}` : a[1].trim();
    l = new Date(c);
    try {
      l.toISOString();
    } catch {
      throw kt(Lt.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (zd(t)) {
    if (isNaN(t.getTime()))
      throw kt(Lt.INVALID_DATE_ARGUMENT);
    l = t;
  } else if (ke(t))
    l = t;
  else
    throw kt(Lt.INVALID_ARGUMENT);
  return W(n) ? o.key = n : Z(n) && Object.keys(n).forEach((a) => {
    _c.includes(a) ? i[a] = n[a] : o[a] = n[a];
  }), W(s) ? o.locale = s : Z(s) && (i = s), Z(r) && (i = r), [o.key || "", l, o, i];
}
function al(e, t, n) {
  const s = e;
  for (const r in n) {
    const o = `${t}__${r}`;
    s.__datetimeFormatters.has(o) && s.__datetimeFormatters.delete(o);
  }
}
function cl(e, ...t) {
  const { numberFormats: n, unresolving: s, fallbackLocale: r, onWarn: o, localeFallbacker: i } = e, { __numberFormatters: l } = e, [a, c, u, f] = lo(...t), p = ie(u.missingWarn) ? u.missingWarn : e.missingWarn;
  ie(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn;
  const b = !!u.part, _ = qo(e, u), T = i(
    e,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    r,
    _
  );
  if (!W(a) || a === "")
    return new Intl.NumberFormat(_, f).format(c);
  let C = {}, g, v = null;
  const L = "number format";
  for (let F = 0; F < T.length && (g = T[F], C = n[g] || {}, v = C[a], !Z(v)); F++)
    Yo(e, a, g, p, L);
  if (!Z(v) || !W(g))
    return s ? hr : a;
  let E = `${g}__${a}`;
  fr(f) || (E = `${E}__${JSON.stringify(f)}`);
  let O = l.get(E);
  return O || (O = new Intl.NumberFormat(g, Oe({}, v, f)), l.set(E, O)), b ? O.formatToParts(c) : O.format(c);
}
const bc = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function lo(...e) {
  const [t, n, s, r] = e, o = {};
  let i = {};
  if (!ke(t))
    throw kt(Lt.INVALID_ARGUMENT);
  const l = t;
  return W(n) ? o.key = n : Z(n) && Object.keys(n).forEach((a) => {
    bc.includes(a) ? i[a] = n[a] : o[a] = n[a];
  }), W(s) ? o.locale = s : Z(s) && (i = s), Z(r) && (i = r), [o.key || "", l, o, i];
}
function ul(e, t, n) {
  const s = e;
  for (const r in n) {
    const o = `${t}__${r}`;
    s.__numberFormatters.has(o) && s.__numberFormatters.delete(o);
  }
}
const rp = (e) => e, op = (e) => "", ip = "text", lp = (e) => e.length === 0 ? "" : Ko(e), ap = eh;
function fl(e, t) {
  return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0;
}
function cp(e) {
  const t = ke(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (ke(e.named.count) || ke(e.named.n)) ? ke(e.named.count) ? e.named.count : ke(e.named.n) ? e.named.n : t : t;
}
function up(e, t) {
  t.count || (t.count = e), t.n || (t.n = e);
}
function fp(e = {}) {
  const t = e.locale, n = cp(e), s = ae(e.pluralRules) && W(t) && pe(e.pluralRules[t]) ? e.pluralRules[t] : fl, r = ae(e.pluralRules) && W(t) && pe(e.pluralRules[t]) ? fl : void 0, o = (g) => g[s(n, g.length, r)], i = e.list || [], l = (g) => i[g], a = e.named || {};
  ke(e.pluralIndex) && up(n, a);
  const c = (g) => a[g];
  function u(g, v) {
    const L = pe(e.messages) ? e.messages(g, !!v) : ae(e.messages) ? e.messages[g] : !1;
    return L || (e.parent ? e.parent.message(g) : op);
  }
  const f = (g) => e.modifiers ? e.modifiers[g] : rp, p = Z(e.processor) && pe(e.processor.normalize) ? e.processor.normalize : lp, b = Z(e.processor) && pe(e.processor.interpolate) ? e.processor.interpolate : ap, _ = Z(e.processor) && W(e.processor.type) ? e.processor.type : ip, C = {
    list: l,
    named: c,
    plural: o,
    linked: (g, ...v) => {
      const [L, E] = v;
      let O = "text", F = "";
      v.length === 1 ? ae(L) ? (F = L.modifier || F, O = L.type || O) : W(L) && (F = L || F) : v.length === 2 && (W(L) && (F = L || F), W(E) && (O = E || O));
      const N = u(g, !0)(C), H = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        O === "vnode" && be(N) && F ? N[0] : N
      );
      return F ? f(F)(H, O) : H;
    },
    message: u,
    type: _,
    interpolate: b,
    normalize: p,
    values: Oe({}, i, a)
  };
  return C;
}
const dl = () => "", ot = (e) => pe(e);
function hl(e, ...t) {
  const { fallbackFormat: n, postTranslation: s, unresolving: r, messageCompiler: o, fallbackLocale: i, messages: l } = e, [a, c] = ao(...t), u = ie(c.missingWarn) ? c.missingWarn : e.missingWarn, f = ie(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn, p = ie(c.escapeParameter) ? c.escapeParameter : e.escapeParameter, b = !!c.resolvedMessage, _ = W(c.default) || ie(c.default) ? ie(c.default) ? o ? a : () => a : c.default : n ? o ? a : () => a : null, T = n || _ != null && (W(_) || pe(_)), C = qo(e, c);
  p && dp(c);
  let [g, v, L] = b ? [
    a,
    C,
    l[C] || {}
  ] : wc(e, a, C, i, f, u), E = g, O = a;
  if (!b && !(W(E) || Pn(E) || ot(E)) && T && (E = _, O = E), !b && (!(W(E) || Pn(E) || ot(E)) || !W(v)))
    return r ? hr : a;
  let F = !1;
  const N = () => {
    F = !0;
  }, H = ot(E) ? E : yc(e, a, v, E, O, N);
  if (F)
    return E;
  const P = mp(e, v, L, c), B = fp(P), Y = hp(e, H, B), U = s ? s(Y, a) : Y;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const j = {
      timestamp: Date.now(),
      key: W(a) ? a : ot(E) ? E.key : "",
      locale: v || (ot(E) ? E.locale : ""),
      format: W(E) ? E : ot(E) ? E.source : "",
      message: U
    };
    j.meta = Oe({}, e.__meta, /* @__PURE__ */ Qh() || {}), xh(j);
  }
  return U;
}
function dp(e) {
  be(e.list) ? e.list = e.list.map((t) => W(t) ? Ji(t) : t) : ae(e.named) && Object.keys(e.named).forEach((t) => {
    W(e.named[t]) && (e.named[t] = Ji(e.named[t]));
  });
}
function wc(e, t, n, s, r, o) {
  const { messages: i, onWarn: l, messageResolver: a, localeFallbacker: c } = e, u = c(e, s, n);
  let f = {}, p, b = null;
  const _ = "translate";
  for (let T = 0; T < u.length && (p = u[T], f = i[p] || {}, (b = a(f, t)) === null && (b = f[t]), !(W(b) || Pn(b) || ot(b))); T++)
    if (!sp(p, u)) {
      const C = Yo(
        e,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        t,
        p,
        o,
        _
      );
      C !== t && (b = C);
    }
  return [b, p, f];
}
function yc(e, t, n, s, r, o) {
  const { messageCompiler: i, warnHtmlMessage: l } = e;
  if (ot(s)) {
    const c = s;
    return c.locale = c.locale || n, c.key = c.key || t, c;
  }
  if (i == null) {
    const c = () => s;
    return c.locale = n, c.key = t, c;
  }
  const a = i(s, pp(e, n, r, s, l, o));
  return a.locale = n, a.key = t, a.source = s, a;
}
function hp(e, t, n) {
  return t(n);
}
function ao(...e) {
  const [t, n, s] = e, r = {};
  if (!W(t) && !ke(t) && !ot(t) && !Pn(t))
    throw kt(Lt.INVALID_ARGUMENT);
  const o = ke(t) ? String(t) : (ot(t), t);
  return ke(n) ? r.plural = n : W(n) ? r.default = n : Z(n) && !fr(n) ? r.named = n : be(n) && (r.list = n), ke(s) ? r.plural = s : W(s) ? r.default = s : Z(s) && Oe(r, s), [o, r];
}
function pp(e, t, n, s, r, o) {
  return {
    locale: t,
    key: n,
    warnHtmlMessage: r,
    onError: (i) => {
      throw o && o(i), i;
    },
    onCacheKey: (i) => Jd(t, n, i)
  };
}
function mp(e, t, n, s) {
  const { modifiers: r, pluralRules: o, messageResolver: i, fallbackLocale: l, fallbackWarn: a, missingWarn: c, fallbackContext: u } = e, p = {
    locale: t,
    modifiers: r,
    pluralRules: o,
    messages: (b, _) => {
      let T = i(n, b);
      if (T == null && (u || _)) {
        const [, , C] = wc(
          u || e,
          // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
          b,
          t,
          l,
          a,
          c
        );
        T = i(C, b);
      }
      if (W(T) || Pn(T)) {
        let C = !1;
        const v = yc(e, b, t, T, b, () => {
          C = !0;
        });
        return C ? dl : v;
      } else return ot(T) ? T : dl;
    }
  };
  return e.processor && (p.processor = e.processor), s.list && (p.list = s.list), s.named && (p.named = s.named), ke(s.plural) && (p.pluralIndex = s.plural), p;
}
Lh();
/*!
  * vue-i18n v10.0.4
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const gp = "10.0.4";
function _p() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (an().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (an().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (an().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (an().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const Ve = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: Fh,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: 25,
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  // directive module errors
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  // unexpected error
  UNEXPECTED_ERROR: 32,
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34
};
function Xe(e, ...t) {
  return dr(e, null, void 0);
}
const co = /* @__PURE__ */ zt("__translateVNode"), uo = /* @__PURE__ */ zt("__datetimeParts"), fo = /* @__PURE__ */ zt("__numberParts"), Ec = zt("__setPluralRules"), Tc = /* @__PURE__ */ zt("__injectWithOption"), ho = /* @__PURE__ */ zt("__dispose");
function cs(e) {
  if (!ae(e))
    return e;
  for (const t in e)
    if (qs(e, t))
      if (!t.includes("."))
        ae(e[t]) && cs(e[t]);
      else {
        const n = t.split("."), s = n.length - 1;
        let r = e, o = !1;
        for (let i = 0; i < s; i++) {
          if (n[i] in r || (r[n[i]] = {}), !ae(r[n[i]])) {
            o = !0;
            break;
          }
          r = r[n[i]];
        }
        o || (r[n[s]] = e[t], delete e[t]), ae(r[n[s]]) && cs(r[n[s]]);
      }
  return e;
}
function Jo(e, t) {
  const { messages: n, __i18n: s, messageResolver: r, flatJson: o } = t, i = Z(n) ? n : be(s) ? {} : { [e]: {} };
  if (be(s) && s.forEach((l) => {
    if ("locale" in l && "resource" in l) {
      const { locale: a, resource: c } = l;
      a ? (i[a] = i[a] || {}, Ps(c, i[a])) : Ps(c, i);
    } else
      W(l) && Ps(JSON.parse(l), i);
  }), r == null && o)
    for (const l in i)
      qs(i, l) && cs(i[l]);
  return i;
}
function Sc(e) {
  return e.type;
}
function vc(e, t, n) {
  let s = ae(t.messages) ? t.messages : {};
  "__i18nGlobal" in n && (s = Jo(e.locale.value, {
    messages: s,
    __i18n: n.__i18nGlobal
  }));
  const r = Object.keys(s);
  r.length && r.forEach((o) => {
    e.mergeLocaleMessage(o, s[o]);
  });
  {
    if (ae(t.datetimeFormats)) {
      const o = Object.keys(t.datetimeFormats);
      o.length && o.forEach((i) => {
        e.mergeDateTimeFormat(i, t.datetimeFormats[i]);
      });
    }
    if (ae(t.numberFormats)) {
      const o = Object.keys(t.numberFormats);
      o.length && o.forEach((i) => {
        e.mergeNumberFormat(i, t.numberFormats[i]);
      });
    }
  }
}
function pl(e) {
  return de(hs, null, e, 0);
}
const ml = "__INTLIFY_META__", gl = () => [], bp = () => !1;
let _l = 0;
function bl(e) {
  return (t, n, s, r) => e(n, s, At() || void 0, r);
}
const wp = /* @__NO_SIDE_EFFECTS__ */ () => {
  const e = At();
  let t = null;
  return e && (t = Sc(e)[ml]) ? { [ml]: t } : null;
};
function Xo(e = {}) {
  const { __root: t, __injectWithOption: n } = e, s = t === void 0, r = e.flatJson, o = Gs ? ue : ha;
  let i = ie(e.inheritLocale) ? e.inheritLocale : !0;
  const l = o(
    // prettier-ignore
    t && i ? t.locale.value : W(e.locale) ? e.locale : as
  ), a = o(
    // prettier-ignore
    t && i ? t.fallbackLocale.value : W(e.fallbackLocale) || be(e.fallbackLocale) || Z(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : l.value
  ), c = o(Jo(l.value, e)), u = o(Z(e.datetimeFormats) ? e.datetimeFormats : { [l.value]: {} }), f = o(Z(e.numberFormats) ? e.numberFormats : { [l.value]: {} });
  let p = t ? t.missingWarn : ie(e.missingWarn) || Nn(e.missingWarn) ? e.missingWarn : !0, b = t ? t.fallbackWarn : ie(e.fallbackWarn) || Nn(e.fallbackWarn) ? e.fallbackWarn : !0, _ = t ? t.fallbackRoot : ie(e.fallbackRoot) ? e.fallbackRoot : !0, T = !!e.fallbackFormat, C = pe(e.missing) ? e.missing : null, g = pe(e.missing) ? bl(e.missing) : null, v = pe(e.postTranslation) ? e.postTranslation : null, L = t ? t.warnHtmlMessage : ie(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, E = !!e.escapeParameter;
  const O = t ? t.modifiers : Z(e.modifiers) ? e.modifiers : {};
  let F = e.pluralRules || t && t.pluralRules, N;
  N = (() => {
    s && ol(null);
    const y = {
      version: gp,
      locale: l.value,
      fallbackLocale: a.value,
      messages: c.value,
      modifiers: O,
      pluralRules: F,
      missing: g === null ? void 0 : g,
      missingWarn: p,
      fallbackWarn: b,
      fallbackFormat: T,
      unresolving: !0,
      postTranslation: v === null ? void 0 : v,
      warnHtmlMessage: L,
      escapeParameter: E,
      messageResolver: e.messageResolver,
      messageCompiler: e.messageCompiler,
      __meta: { framework: "vue" }
    };
    y.datetimeFormats = u.value, y.numberFormats = f.value, y.__datetimeFormatters = Z(N) ? N.__datetimeFormatters : void 0, y.__numberFormatters = Z(N) ? N.__numberFormatters : void 0;
    const k = tp(y);
    return s && ol(k), k;
  })(), Bn(N, l.value, a.value);
  function P() {
    return [
      l.value,
      a.value,
      c.value,
      u.value,
      f.value
    ];
  }
  const B = Ge({
    get: () => l.value,
    set: (y) => {
      l.value = y, N.locale = l.value;
    }
  }), Y = Ge({
    get: () => a.value,
    set: (y) => {
      a.value = y, N.fallbackLocale = a.value, Bn(N, l.value, y);
    }
  }), U = Ge(() => c.value), j = /* @__PURE__ */ Ge(() => u.value), ee = /* @__PURE__ */ Ge(() => f.value);
  function _e() {
    return pe(v) ? v : null;
  }
  function le(y) {
    v = y, N.postTranslation = y;
  }
  function X() {
    return C;
  }
  function se(y) {
    y !== null && (g = bl(y)), C = y, N.missing = g;
  }
  const ve = (y, k, V, K, te, ne) => {
    P();
    let Te;
    try {
      __INTLIFY_PROD_DEVTOOLS__, s || (N.fallbackContext = t ? ep() : void 0), Te = y(N);
    } finally {
      __INTLIFY_PROD_DEVTOOLS__, s || (N.fallbackContext = void 0);
    }
    if (V !== "translate exists" && // for not `te` (e.g `t`)
    ke(Te) && Te === hr || V === "translate exists" && !Te) {
      const [Ie, st] = k();
      return t && _ ? K(t) : te(Ie);
    } else {
      if (ne(Te))
        return Te;
      throw Xe(Ve.UNEXPECTED_RETURN_TYPE);
    }
  };
  function _t(...y) {
    return ve((k) => Reflect.apply(hl, null, [k, ...y]), () => ao(...y), "translate", (k) => Reflect.apply(k.t, k, [...y]), (k) => k, (k) => W(k));
  }
  function nt(...y) {
    const [k, V, K] = y;
    if (K && !ae(K))
      throw Xe(Ve.INVALID_ARGUMENT);
    return _t(k, V, Oe({ resolvedMessage: !0 }, K || {}));
  }
  function We(...y) {
    return ve((k) => Reflect.apply(ll, null, [k, ...y]), () => io(...y), "datetime format", (k) => Reflect.apply(k.d, k, [...y]), () => sl, (k) => W(k));
  }
  function mn(...y) {
    return ve((k) => Reflect.apply(cl, null, [k, ...y]), () => lo(...y), "number format", (k) => Reflect.apply(k.n, k, [...y]), () => sl, (k) => W(k));
  }
  function $n(y) {
    return y.map((k) => W(k) || ke(k) || ie(k) ? pl(String(k)) : k);
  }
  const bt = {
    normalize: $n,
    interpolate: (y) => y,
    type: "vnode"
  };
  function Rt(...y) {
    return ve((k) => {
      let V;
      const K = k;
      try {
        K.processor = bt, V = Reflect.apply(hl, null, [K, ...y]);
      } finally {
        K.processor = null;
      }
      return V;
    }, () => ao(...y), "translate", (k) => k[co](...y), (k) => [pl(k)], (k) => be(k));
  }
  function Nt(...y) {
    return ve((k) => Reflect.apply(cl, null, [k, ...y]), () => lo(...y), "number format", (k) => k[fo](...y), gl, (k) => W(k) || be(k));
  }
  function gn(...y) {
    return ve((k) => Reflect.apply(ll, null, [k, ...y]), () => io(...y), "datetime format", (k) => k[uo](...y), gl, (k) => W(k) || be(k));
  }
  function wt(y) {
    F = y, N.pluralRules = F;
  }
  function _n(y, k) {
    return ve(() => {
      if (!y)
        return !1;
      const V = W(k) ? k : l.value, K = w(V), te = N.messageResolver(K, y);
      return Pn(te) || ot(te) || W(te);
    }, () => [y], "translate exists", (V) => Reflect.apply(V.te, V, [y, k]), bp, (V) => ie(V));
  }
  function bn(y) {
    let k = null;
    const V = fc(N, a.value, l.value);
    for (let K = 0; K < V.length; K++) {
      const te = c.value[V[K]] || {}, ne = N.messageResolver(te, y);
      if (ne != null) {
        k = ne;
        break;
      }
    }
    return k;
  }
  function m(y) {
    const k = bn(y);
    return k ?? (t ? t.tm(y) || {} : {});
  }
  function w(y) {
    return c.value[y] || {};
  }
  function R(y, k) {
    if (r) {
      const V = { [y]: k };
      for (const K in V)
        qs(V, K) && cs(V[K]);
      k = V[y];
    }
    c.value[y] = k, N.messages = c.value;
  }
  function M(y, k) {
    c.value[y] = c.value[y] || {};
    const V = { [y]: k };
    if (r)
      for (const K in V)
        qs(V, K) && cs(V[K]);
    k = V[y], Ps(k, c.value[y]), N.messages = c.value;
  }
  function D(y) {
    return u.value[y] || {};
  }
  function d(y, k) {
    u.value[y] = k, N.datetimeFormats = u.value, al(N, y, k);
  }
  function h(y, k) {
    u.value[y] = Oe(u.value[y] || {}, k), N.datetimeFormats = u.value, al(N, y, k);
  }
  function S(y) {
    return f.value[y] || {};
  }
  function A(y, k) {
    f.value[y] = k, N.numberFormats = f.value, ul(N, y, k);
  }
  function x(y, k) {
    f.value[y] = Oe(f.value[y] || {}, k), N.numberFormats = f.value, ul(N, y, k);
  }
  _l++, t && Gs && (Bt(t.locale, (y) => {
    i && (l.value = y, N.locale = y, Bn(N, l.value, a.value));
  }), Bt(t.fallbackLocale, (y) => {
    i && (a.value = y, N.fallbackLocale = y, Bn(N, l.value, a.value));
  }));
  const $ = {
    id: _l,
    locale: B,
    fallbackLocale: Y,
    get inheritLocale() {
      return i;
    },
    set inheritLocale(y) {
      i = y, y && t && (l.value = t.locale.value, a.value = t.fallbackLocale.value, Bn(N, l.value, a.value));
    },
    get availableLocales() {
      return Object.keys(c.value).sort();
    },
    messages: U,
    get modifiers() {
      return O;
    },
    get pluralRules() {
      return F || {};
    },
    get isGlobal() {
      return s;
    },
    get missingWarn() {
      return p;
    },
    set missingWarn(y) {
      p = y, N.missingWarn = p;
    },
    get fallbackWarn() {
      return b;
    },
    set fallbackWarn(y) {
      b = y, N.fallbackWarn = b;
    },
    get fallbackRoot() {
      return _;
    },
    set fallbackRoot(y) {
      _ = y;
    },
    get fallbackFormat() {
      return T;
    },
    set fallbackFormat(y) {
      T = y, N.fallbackFormat = T;
    },
    get warnHtmlMessage() {
      return L;
    },
    set warnHtmlMessage(y) {
      L = y, N.warnHtmlMessage = y;
    },
    get escapeParameter() {
      return E;
    },
    set escapeParameter(y) {
      E = y, N.escapeParameter = y;
    },
    t: _t,
    getLocaleMessage: w,
    setLocaleMessage: R,
    mergeLocaleMessage: M,
    getPostTranslationHandler: _e,
    setPostTranslationHandler: le,
    getMissingHandler: X,
    setMissingHandler: se,
    [Ec]: wt
  };
  return $.datetimeFormats = j, $.numberFormats = ee, $.rt = nt, $.te = _n, $.tm = m, $.d = We, $.n = mn, $.getDateTimeFormat = D, $.setDateTimeFormat = d, $.mergeDateTimeFormat = h, $.getNumberFormat = S, $.setNumberFormat = A, $.mergeNumberFormat = x, $[Tc] = n, $[co] = Rt, $[uo] = gn, $[fo] = Nt, $;
}
function yp(e) {
  const t = W(e.locale) ? e.locale : as, n = W(e.fallbackLocale) || be(e.fallbackLocale) || Z(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : t, s = pe(e.missing) ? e.missing : void 0, r = ie(e.silentTranslationWarn) || Nn(e.silentTranslationWarn) ? !e.silentTranslationWarn : !0, o = ie(e.silentFallbackWarn) || Nn(e.silentFallbackWarn) ? !e.silentFallbackWarn : !0, i = ie(e.fallbackRoot) ? e.fallbackRoot : !0, l = !!e.formatFallbackMessages, a = Z(e.modifiers) ? e.modifiers : {}, c = e.pluralizationRules, u = pe(e.postTranslation) ? e.postTranslation : void 0, f = W(e.warnHtmlInMessage) ? e.warnHtmlInMessage !== "off" : !0, p = !!e.escapeParameterHtml, b = ie(e.sync) ? e.sync : !0;
  let _ = e.messages;
  if (Z(e.sharedMessages)) {
    const O = e.sharedMessages;
    _ = Object.keys(O).reduce((N, H) => {
      const P = N[H] || (N[H] = {});
      return Oe(P, O[H]), N;
    }, _ || {});
  }
  const { __i18n: T, __root: C, __injectWithOption: g } = e, v = e.datetimeFormats, L = e.numberFormats, E = e.flatJson;
  return {
    locale: t,
    fallbackLocale: n,
    messages: _,
    flatJson: E,
    datetimeFormats: v,
    numberFormats: L,
    missing: s,
    missingWarn: r,
    fallbackWarn: o,
    fallbackRoot: i,
    fallbackFormat: l,
    modifiers: a,
    pluralRules: c,
    postTranslation: u,
    warnHtmlMessage: f,
    escapeParameter: p,
    messageResolver: e.messageResolver,
    inheritLocale: b,
    __i18n: T,
    __root: C,
    __injectWithOption: g
  };
}
function po(e = {}) {
  const t = Xo(yp(e)), { __extender: n } = e, s = {
    // id
    id: t.id,
    // locale
    get locale() {
      return t.locale.value;
    },
    set locale(r) {
      t.locale.value = r;
    },
    // fallbackLocale
    get fallbackLocale() {
      return t.fallbackLocale.value;
    },
    set fallbackLocale(r) {
      t.fallbackLocale.value = r;
    },
    // messages
    get messages() {
      return t.messages.value;
    },
    // datetimeFormats
    get datetimeFormats() {
      return t.datetimeFormats.value;
    },
    // numberFormats
    get numberFormats() {
      return t.numberFormats.value;
    },
    // availableLocales
    get availableLocales() {
      return t.availableLocales;
    },
    // missing
    get missing() {
      return t.getMissingHandler();
    },
    set missing(r) {
      t.setMissingHandler(r);
    },
    // silentTranslationWarn
    get silentTranslationWarn() {
      return ie(t.missingWarn) ? !t.missingWarn : t.missingWarn;
    },
    set silentTranslationWarn(r) {
      t.missingWarn = ie(r) ? !r : r;
    },
    // silentFallbackWarn
    get silentFallbackWarn() {
      return ie(t.fallbackWarn) ? !t.fallbackWarn : t.fallbackWarn;
    },
    set silentFallbackWarn(r) {
      t.fallbackWarn = ie(r) ? !r : r;
    },
    // modifiers
    get modifiers() {
      return t.modifiers;
    },
    // formatFallbackMessages
    get formatFallbackMessages() {
      return t.fallbackFormat;
    },
    set formatFallbackMessages(r) {
      t.fallbackFormat = r;
    },
    // postTranslation
    get postTranslation() {
      return t.getPostTranslationHandler();
    },
    set postTranslation(r) {
      t.setPostTranslationHandler(r);
    },
    // sync
    get sync() {
      return t.inheritLocale;
    },
    set sync(r) {
      t.inheritLocale = r;
    },
    // warnInHtmlMessage
    get warnHtmlInMessage() {
      return t.warnHtmlMessage ? "warn" : "off";
    },
    set warnHtmlInMessage(r) {
      t.warnHtmlMessage = r !== "off";
    },
    // escapeParameterHtml
    get escapeParameterHtml() {
      return t.escapeParameter;
    },
    set escapeParameterHtml(r) {
      t.escapeParameter = r;
    },
    // pluralizationRules
    get pluralizationRules() {
      return t.pluralRules || {};
    },
    // for internal
    __composer: t,
    // t
    t(...r) {
      return Reflect.apply(t.t, t, [...r]);
    },
    // rt
    rt(...r) {
      return Reflect.apply(t.rt, t, [...r]);
    },
    // tc
    tc(...r) {
      const [o, i, l] = r, a = { plural: 1 };
      let c = null, u = null;
      if (!W(o))
        throw Xe(Ve.INVALID_ARGUMENT);
      const f = o;
      return W(i) ? a.locale = i : ke(i) ? a.plural = i : be(i) ? c = i : Z(i) && (u = i), W(l) ? a.locale = l : be(l) ? c = l : Z(l) && (u = l), Reflect.apply(t.t, t, [
        f,
        c || u || {},
        a
      ]);
    },
    // te
    te(r, o) {
      return t.te(r, o);
    },
    // tm
    tm(r) {
      return t.tm(r);
    },
    // getLocaleMessage
    getLocaleMessage(r) {
      return t.getLocaleMessage(r);
    },
    // setLocaleMessage
    setLocaleMessage(r, o) {
      t.setLocaleMessage(r, o);
    },
    // mergeLocaleMessage
    mergeLocaleMessage(r, o) {
      t.mergeLocaleMessage(r, o);
    },
    // d
    d(...r) {
      return Reflect.apply(t.d, t, [...r]);
    },
    // getDateTimeFormat
    getDateTimeFormat(r) {
      return t.getDateTimeFormat(r);
    },
    // setDateTimeFormat
    setDateTimeFormat(r, o) {
      t.setDateTimeFormat(r, o);
    },
    // mergeDateTimeFormat
    mergeDateTimeFormat(r, o) {
      t.mergeDateTimeFormat(r, o);
    },
    // n
    n(...r) {
      return Reflect.apply(t.n, t, [...r]);
    },
    // getNumberFormat
    getNumberFormat(r) {
      return t.getNumberFormat(r);
    },
    // setNumberFormat
    setNumberFormat(r, o) {
      t.setNumberFormat(r, o);
    },
    // mergeNumberFormat
    mergeNumberFormat(r, o) {
      t.mergeNumberFormat(r, o);
    }
  };
  return s.__extender = n, s;
}
function Ep(e, t, n) {
  return {
    beforeCreate() {
      const s = At();
      if (!s)
        throw Xe(Ve.UNEXPECTED_ERROR);
      const r = this.$options;
      if (r.i18n) {
        const o = r.i18n;
        if (r.__i18n && (o.__i18n = r.__i18n), o.__root = t, this === this.$root)
          this.$i18n = wl(e, o);
        else {
          o.__injectWithOption = !0, o.__extender = n.__vueI18nExtend, this.$i18n = po(o);
          const i = this.$i18n;
          i.__extender && (i.__disposer = i.__extender(this.$i18n));
        }
      } else if (r.__i18n)
        if (this === this.$root)
          this.$i18n = wl(e, r);
        else {
          this.$i18n = po({
            __i18n: r.__i18n,
            __injectWithOption: !0,
            __extender: n.__vueI18nExtend,
            __root: t
          });
          const o = this.$i18n;
          o.__extender && (o.__disposer = o.__extender(this.$i18n));
        }
      else
        this.$i18n = e;
      r.__i18nGlobal && vc(t, r, r), this.$t = (...o) => this.$i18n.t(...o), this.$rt = (...o) => this.$i18n.rt(...o), this.$tc = (...o) => this.$i18n.tc(...o), this.$te = (o, i) => this.$i18n.te(o, i), this.$d = (...o) => this.$i18n.d(...o), this.$n = (...o) => this.$i18n.n(...o), this.$tm = (o) => this.$i18n.tm(o), n.__setInstance(s, this.$i18n);
    },
    mounted() {
    },
    unmounted() {
      const s = At();
      if (!s)
        throw Xe(Ve.UNEXPECTED_ERROR);
      const r = this.$i18n;
      delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, r.__disposer && (r.__disposer(), delete r.__disposer, delete r.__extender), n.__deleteInstance(s), delete this.$i18n;
    }
  };
}
function wl(e, t) {
  e.locale = t.locale || e.locale, e.fallbackLocale = t.fallbackLocale || e.fallbackLocale, e.missing = t.missing || e.missing, e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn, e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn, e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages, e.postTranslation = t.postTranslation || e.postTranslation, e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage, e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml, e.sync = t.sync || e.sync, e.__composer[Ec](t.pluralizationRules || e.pluralizationRules);
  const n = Jo(e.locale, {
    messages: t.messages,
    __i18n: t.__i18n
  });
  return Object.keys(n).forEach((s) => e.mergeLocaleMessage(s, n[s])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((s) => e.mergeDateTimeFormat(s, t.datetimeFormats[s])), t.numberFormats && Object.keys(t.numberFormats).forEach((s) => e.mergeNumberFormat(s, t.numberFormats[s])), e;
}
const zo = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (e) => e === "parent" || e === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function Tp({ slots: e }, t) {
  return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((s, r) => [
    ...s,
    // prettier-ignore
    ...r.type === Le ? r.children : [r]
  ], []) : t.reduce((n, s) => {
    const r = e[s];
    return r && (n[s] = r()), n;
  }, {});
}
function Cc() {
  return Le;
}
const Sp = /* @__PURE__ */ lt({
  /* eslint-disable */
  name: "i18n-t",
  props: Oe({
    keypath: {
      type: String,
      required: !0
    },
    plural: {
      type: [Number, String],
      validator: (e) => ke(e) || !isNaN(e)
    }
  }, zo),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const { slots: n, attrs: s } = t, r = e.i18n || gs({
      useScope: e.scope,
      __useComponent: !0
    });
    return () => {
      const o = Object.keys(n).filter((f) => f !== "_"), i = {};
      e.locale && (i.locale = e.locale), e.plural !== void 0 && (i.plural = W(e.plural) ? +e.plural : e.plural);
      const l = Tp(t, o), a = r[co](e.keypath, l, i), c = Oe({}, s), u = W(e.tag) || ae(e.tag) ? e.tag : Cc();
      return Wo(u, c, a);
    };
  }
}), yl = Sp;
function vp(e) {
  return be(e) && !W(e[0]);
}
function Lc(e, t, n, s) {
  const { slots: r, attrs: o } = t;
  return () => {
    const i = { part: !0 };
    let l = {};
    e.locale && (i.locale = e.locale), W(e.format) ? i.key = e.format : ae(e.format) && (W(e.format.key) && (i.key = e.format.key), l = Object.keys(e.format).reduce((p, b) => n.includes(b) ? Oe({}, p, { [b]: e.format[b] }) : p, {}));
    const a = s(e.value, i, l);
    let c = [i.key];
    be(a) ? c = a.map((p, b) => {
      const _ = r[p.type], T = _ ? _({ [p.type]: p.value, index: b, parts: a }) : [p.value];
      return vp(T) && (T[0].key = `${p.type}-${b}`), T;
    }) : W(a) && (c = [a]);
    const u = Oe({}, o), f = W(e.tag) || ae(e.tag) ? e.tag : Cc();
    return Wo(f, u, c);
  };
}
const Cp = /* @__PURE__ */ lt({
  /* eslint-disable */
  name: "i18n-n",
  props: Oe({
    value: {
      type: Number,
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, zo),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const n = e.i18n || gs({
      useScope: e.scope,
      __useComponent: !0
    });
    return Lc(e, t, bc, (...s) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[fo](...s)
    ));
  }
}), El = Cp, Lp = /* @__PURE__ */ lt({
  /* eslint-disable */
  name: "i18n-d",
  props: Oe({
    value: {
      type: [Number, Date],
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, zo),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const n = e.i18n || gs({
      useScope: e.scope,
      __useComponent: !0
    });
    return Lc(e, t, _c, (...s) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[uo](...s)
    ));
  }
}), Tl = Lp;
function kp(e, t) {
  const n = e;
  if (e.mode === "composition")
    return n.__getInstance(t) || e.global;
  {
    const s = n.__getInstance(t);
    return s != null ? s.__composer : e.global.__composer;
  }
}
function Ap(e) {
  const t = (i) => {
    const { instance: l, value: a } = i;
    if (!l || !l.$)
      throw Xe(Ve.UNEXPECTED_ERROR);
    const c = kp(e, l.$), u = Sl(a);
    return [
      Reflect.apply(c.t, c, [...vl(u)]),
      c
    ];
  };
  return {
    created: (i, l) => {
      const [a, c] = t(l);
      Gs && e.global === c && (i.__i18nWatcher = Bt(c.locale, () => {
        l.instance && l.instance.$forceUpdate();
      })), i.__composer = c, i.textContent = a;
    },
    unmounted: (i) => {
      Gs && i.__i18nWatcher && (i.__i18nWatcher(), i.__i18nWatcher = void 0, delete i.__i18nWatcher), i.__composer && (i.__composer = void 0, delete i.__composer);
    },
    beforeUpdate: (i, { value: l }) => {
      if (i.__composer) {
        const a = i.__composer, c = Sl(l);
        i.textContent = Reflect.apply(a.t, a, [
          ...vl(c)
        ]);
      }
    },
    getSSRProps: (i) => {
      const [l] = t(i);
      return { textContent: l };
    }
  };
}
function Sl(e) {
  if (W(e))
    return { path: e };
  if (Z(e)) {
    if (!("path" in e))
      throw Xe(Ve.REQUIRED_VALUE, "path");
    return e;
  } else
    throw Xe(Ve.INVALID_VALUE);
}
function vl(e) {
  const { path: t, locale: n, args: s, choice: r, plural: o } = e, i = {}, l = s || {};
  return W(n) && (i.locale = n), ke(r) && (i.plural = r), ke(o) && (i.plural = o), [t, l, i];
}
function Op(e, t, ...n) {
  const s = Z(n[0]) ? n[0] : {};
  (ie(s.globalInstall) ? s.globalInstall : !0) && ([yl.name, "I18nT"].forEach((o) => e.component(o, yl)), [El.name, "I18nN"].forEach((o) => e.component(o, El)), [Tl.name, "I18nD"].forEach((o) => e.component(o, Tl))), e.directive("t", Ap(t));
}
const Ip = /* @__PURE__ */ zt("global-vue-i18n");
function Rp(e = {}, t) {
  const n = __VUE_I18N_LEGACY_API__ && ie(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__, s = ie(e.globalInjection) ? e.globalInjection : !0, r = /* @__PURE__ */ new Map(), [o, i] = Np(e, n), l = /* @__PURE__ */ zt("");
  function a(p) {
    return r.get(p) || null;
  }
  function c(p, b) {
    r.set(p, b);
  }
  function u(p) {
    r.delete(p);
  }
  const f = {
    // mode
    get mode() {
      return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition";
    },
    // install plugin
    async install(p, ...b) {
      if (p.__VUE_I18N_SYMBOL__ = l, p.provide(p.__VUE_I18N_SYMBOL__, f), Z(b[0])) {
        const C = b[0];
        f.__composerExtend = C.__composerExtend, f.__vueI18nExtend = C.__vueI18nExtend;
      }
      let _ = null;
      !n && s && (_ = Hp(p, f.global)), __VUE_I18N_FULL_INSTALL__ && Op(p, f, ...b), __VUE_I18N_LEGACY_API__ && n && p.mixin(Ep(i, i.__composer, f));
      const T = p.unmount;
      p.unmount = () => {
        _ && _(), f.dispose(), T();
      };
    },
    // global accessor
    get global() {
      return i;
    },
    dispose() {
      o.stop();
    },
    // @internal
    __instances: r,
    // @internal
    __getInstance: a,
    // @internal
    __setInstance: c,
    // @internal
    __deleteInstance: u
  };
  return f;
}
function gs(e = {}) {
  const t = At();
  if (t == null)
    throw Xe(Ve.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__)
    throw Xe(Ve.NOT_INSTALLED);
  const n = xp(t), s = Fp(n), r = Sc(t), o = Pp(e, r);
  if (o === "global")
    return vc(s, e, r), s;
  if (o === "parent") {
    let a = Dp(n, t, e.__useComponent);
    return a == null && (a = s), a;
  }
  const i = n;
  let l = i.__getInstance(t);
  if (l == null) {
    const a = Oe({}, e);
    "__i18n" in r && (a.__i18n = r.__i18n), s && (a.__root = s), l = Xo(a), i.__composerExtend && (l[ho] = i.__composerExtend(l)), $p(i, t, l), i.__setInstance(t, l);
  }
  return l;
}
function Np(e, t, n) {
  const s = Ao(), r = __VUE_I18N_LEGACY_API__ && t ? s.run(() => po(e)) : s.run(() => Xo(e));
  if (r == null)
    throw Xe(Ve.UNEXPECTED_ERROR);
  return [s, r];
}
function xp(e) {
  const t = Rn(e.isCE ? Ip : e.appContext.app.__VUE_I18N_SYMBOL__);
  if (!t)
    throw Xe(e.isCE ? Ve.NOT_INSTALLED_WITH_PROVIDE : Ve.UNEXPECTED_ERROR);
  return t;
}
function Pp(e, t) {
  return fr(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local";
}
function Fp(e) {
  return e.mode === "composition" ? e.global : e.global.__composer;
}
function Dp(e, t, n = !1) {
  let s = null;
  const r = t.root;
  let o = Mp(t, n);
  for (; o != null; ) {
    const i = e;
    if (e.mode === "composition")
      s = i.__getInstance(o);
    else if (__VUE_I18N_LEGACY_API__) {
      const l = i.__getInstance(o);
      l != null && (s = l.__composer, n && s && !s[Tc] && (s = null));
    }
    if (s != null || r === o)
      break;
    o = o.parent;
  }
  return s;
}
function Mp(e, t = !1) {
  return e == null ? null : t && e.vnode.ctx || e.parent;
}
function $p(e, t, n) {
  Jt(() => {
  }, t), Fn(() => {
    const s = n;
    e.__deleteInstance(t);
    const r = s[ho];
    r && (r(), delete s[ho]);
  }, t);
}
const Up = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], Cl = ["t", "rt", "d", "n", "tm", "te"];
function Hp(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  return Up.forEach((r) => {
    const o = Object.getOwnPropertyDescriptor(t, r);
    if (!o)
      throw Xe(Ve.UNEXPECTED_ERROR);
    const i = we(o.value) ? {
      get() {
        return o.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(l) {
        o.value.value = l;
      }
    } : {
      get() {
        return o.get && o.get();
      }
    };
    Object.defineProperty(n, r, i);
  }), e.config.globalProperties.$i18n = n, Cl.forEach((r) => {
    const o = Object.getOwnPropertyDescriptor(t, r);
    if (!o || !o.value)
      throw Xe(Ve.UNEXPECTED_ERROR);
    Object.defineProperty(e.config.globalProperties, `$${r}`, o);
  }), () => {
    delete e.config.globalProperties.$i18n, Cl.forEach((r) => {
      delete e.config.globalProperties[`$${r}`];
    });
  };
}
_p();
Jh(Ih);
Xh(Gh);
zh(fc);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const e = an();
  e.__INTLIFY__ = !0, Rh(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const Vp = /* @__PURE__ */ lt({
  props: { seconds: { default: 0 }, separator: { default: "" }, zerofill: { default: !1 } },
  setup(e) {
    let { t } = gs(), n = function(r, o) {
      var i = Math.floor(r / 86400), l = Math.floor(r % 86400 / 3600), a = Math.floor(r % 3600 / 60), c = Math.floor(r % 3600 % 60), u = i > 0 ? i + `${o || `${t("time.d")} `}` : "", f = l > 0 ? (l >= 10 ? l : (e.zerofill ? "0" : "") + l) + `${o || `${t("time.h")} `}` : "", p = a > 0 || e.zerofill ? (a >= 10 ? a : (e.zerofill ? "0" : "") + a) + `${o || `${t("time.m")} `}` : "", b = c >= 0 ? (c >= 10 ? c : (e.zerofill ? "0" : "") + c) + `${o ? "" : `${t("time.s")} `}` : "";
      return u ? u + f : f ? (o == ":" && (p = p.replace(":", "")), f + p) : p + b;
    };
    return {
      formattedTime: Ge(() => n(e.seconds, e.separator))
    };
  }
});
function Wp(e, t, n, s, r, o) {
  return Ce(e.formattedTime);
}
const Bp = /* @__PURE__ */ Xt(Vp, [["render", Wp]]), jp = /* @__PURE__ */ lt({
  name: "TaskCard",
  components: {
    SecondsTimerTwoItems: Bp,
    CustomButtonFlat: Bo
  },
  props: ["task", "taskNumber", "class"],
  emits: ["click"],
  setup(e, { emit: t }) {
    const n = ue(null), s = ue(null), r = ms(), o = jt(new Yd()), i = function() {
      t("click", e.task.id);
    }, l = function() {
      r.loadPlatformAndTasks();
    }, a = (c) => {
      if (!c)
        return 0;
      const u = Math.ceil((new Date(c).getTime() - (/* @__PURE__ */ new Date()).getTime()) / 1e3);
      return u > 0 ? u : 0;
    };
    return Jt(() => {
      var u;
      const c = a((u = e.task.status) == null ? void 0 : u.expiredAt);
      c && o.start(c, l);
    }), Bt(
      () => {
        var c;
        return (c = e.task.status) == null ? void 0 : c.expiredAt;
      },
      (c) => {
        const u = a(c);
        u && o.start(u, l);
      }
    ), {
      taskBottomSheet: n,
      taskCardRef: s,
      clickTask: i,
      timer: o
    };
  }
}), Kp = ["src"], Gp = { class: "wg-flex wg-flex-col wg-gap-[4px] wg-grow wg-text-left" }, qp = { class: "wg-text-16-reg wg-font-medium wg-text-black dark:wg-text-white" }, Yp = {
  key: 0,
  class: "wg-flex wg-text-13-medium wg-text-gray-700 dark:wg-text-gray-500 wg-gap-[8px] wg-gap-y-1 wg-flex-wrap"
}, Jp = ["src"], Xp = { class: "" }, zp = { class: "fill-accent-green" }, Zp = { class: "wg-w-min-content" }, Qp = { key: 1 };
function em(e, t, n, s, r, o) {
  const i = In("SecondsTimerTwoItems"), l = In("CustomButtonFlat");
  return Q(), ge("div", {
    class: He(["wg-flex wg-items-center wg-py-[16px] wg-gap-[12px] wg-w-full", e.$props.class]),
    ref: "taskCardRef",
    onClick: t[0] || (t[0] = (...a) => e.clickTask && e.clickTask(...a))
  }, [
    e.$props.task.logo ? (Q(), ge("img", {
      key: 0,
      src: e.$props.task.logo,
      class: "wg-size-[44px] wg-rounded-full"
    }, null, 8, Kp)) : Ue("", !0),
    q("div", Gp, [
      q("div", qp, Ce(e.$props.task.title), 1),
      e.$props.task.rewards ? (Q(), ge("div", Yp, [
        (Q(!0), ge(Le, null, Mo(e.$props.task.rewards, (a) => (Q(), ge("div", {
          class: "wg-flex wg-items-center",
          key: a.id
        }, [
          q("img", {
            src: a.logo,
            class: "wg-size-[14px] wg-mr-[4px]"
          }, null, 8, Jp),
          q("span", Xp, "+" + Ce((+a.value).toLocaleString("ru-RU")), 1)
        ]))), 128))
      ])) : Ue("", !0)
    ]),
    q("div", zp, [
      q("div", Zp, [
        de(l, { class: "wg-text-14-reg wg-font-semibold !wg-h-[40px] wg-px-[16px] btn-wgs-black" }, {
          default: Ke(() => [
            e.timer.seconds ? (Q(), qe(i, {
              key: 0,
              seconds: e.timer.seconds,
              separator: ":",
              zerofill: !0
            }, null, 8, ["seconds"])) : Ue("", !0),
            e.timer.seconds ? Ue("", !0) : (Q(), ge("span", Qp, Ce(e.$t("claim")), 1))
          ]),
          _: 1
        })
      ])
    ])
  ], 2);
}
const tm = /* @__PURE__ */ Xt(jp, [["render", em]]), Zo = /* @__PURE__ */ lt({
  name: "BottomSheet",
  props: {
    overlay: { default: !0 },
    overlayColor: { default: "rgba(0,0,0,0.8)" },
    maxWidth: { default: 2048 },
    transitionDuration: { default: 0.7 },
    overlayClickClose: { default: !0 },
    canSwipe: { default: !0 },
    showDraggable: { default: !1 },
    class: { default: "" },
    escClose: { default: !0 },
    bottomPadding: { default: 32 },
    padding: 0
  },
  emits: ["opened", "closed", "dragging-up", "dragging-down"],
  setup(e, { emit: t }) {
    const n = ue(!1), s = ue(0), r = ue(120), o = ue(!1), i = ue(0), l = ue(null), a = ue(null), c = ue(null), u = ue(null), f = ue(null), p = ue(null), b = (j) => document.activeElement === j;
    window.addEventListener("keyup", (j) => {
      var _e;
      const ee = ((_e = l.value) == null ? void 0 : _e.contains(j.target)) && b(j.target);
      j.key === "Escape" && !ee && e.escClose && P();
    });
    const _ = Ge(() => [
      "wgs-bottom-sheet__content",
      {
        "wgs-bottom-sheet__content--fullscreen": s.value >= window.innerHeight,
        "wgs-bottom-sheet__content--dragging": o.value
      }
    ]), T = Ge(() => `${e.transitionDuration}s`), C = Ge(() => "auto"), g = Ge(() => e.maxHeight ? `${e.maxHeight}px` : "inherit"), v = Ge(() => `${r.value}%`), L = Ge(() => `${e.maxWidth}px`), E = async () => {
      var j, ee, _e;
      await ln(), s.value = ((j = a.value) == null ? void 0 : j.offsetHeight) + ((ee = c.value) == null ? void 0 : ee.clientHeight) + ((_e = u.value) == null ? void 0 : _e.offsetHeight);
    }, O = (j, ee) => {
      var _e, le, X;
      if (e.canSwipe) {
        o.value = !0;
        const se = (ve) => {
          ve.preventDefault();
        };
        j.deltaY > 0 && (ee === "main" && j.type === "panup" && (r.value = Y(j.deltaY), j.cancelable && ((_e = c.value) == null || _e.addEventListener("touchmove", se))), ee === "main" && j.type === "pandown" && i.value === 0 && (r.value = Y(j.deltaY)), ee === "area" && (r.value = Y(j.deltaY)), j.type === "panup" && t("dragging-up"), j.type === "pandown" && t("dragging-down")), j.isFinal && ((le = c.value) == null || le.removeEventListener("touchmove", se), ee === "main" && (i.value = (X = c.value) == null ? void 0 : X.scrollTop), o.value = !1, r.value >= 10 ? P() : r.value = 0);
      }
    };
    ln(() => {
      E();
    });
    let F = document.documentElement.style.overflowY, N = document.documentElement.style.overscrollBehavior;
    const H = () => {
      r.value = 0, F = document.documentElement.style.overflowY, N = document.documentElement.style.overscrollBehavior, document.documentElement.style.overflowY = "hidden", document.documentElement.style.overscrollBehavior = "none", n.value = !0, t("opened"), ln(() => {
        ln(() => {
          var j;
          (j = c == null ? void 0 : c.value) != null && j.scrollTop && (c.value.scrollTop = 0);
        });
      });
    }, P = async () => {
      n.value = !1, r.value = 120, setTimeout(() => {
        document.documentElement.style.overflowY = F, document.documentElement.style.overscrollBehavior = N, t("closed");
      }, e.transitionDuration * 1e3);
    }, B = () => {
      e.overlayClickClose && P();
    }, Y = (j) => {
      const ee = e.maxHeight && e.maxHeight <= s.value ? e.maxHeight : s.value;
      return j / ee * 100;
    };
    let U = e.padding;
    return {
      open: H,
      close: P,
      sheetContentClasses: _,
      transitionDurationString: T,
      sheetHeightString: C,
      maxHeightString: g,
      translateValueString: v,
      maxWidthString: L,
      clickOnOverlayHandler: B,
      props: e,
      showSheet: n,
      sheetHeight: s,
      translateValue: r,
      isDragging: o,
      contentScroll: i,
      bottomSheet: l,
      bottomSheetHeader: a,
      bottomSheetMain: c,
      bottomSheetFooter: u,
      bottomSheetContent: f,
      bottomSheetDraggableArea: p,
      isFocused: b,
      dragHandler: O,
      padding: U
    };
  }
}), Ll = () => {
  _d((e) => ({
    "247448d8": e.transitionDurationString,
    "313bdcb7": e.padding,
    "10f7dbce": e.translateValueString,
    "0071483d": e.sheetHeightString,
    "85c8fbe6": e.maxWidthString
  }));
}, kl = Zo.setup;
Zo.setup = kl ? (e, t) => (Ll(), kl(e, t)) : Ll;
const nm = ["aria-hidden"], sm = {
  ref: "bottomSheetHeader",
  class: "wgs-bottom-sheet__header"
}, rm = {
  key: 0,
  class: "wgs-bottom-sheet__draggable-area",
  ref: "bottomSheetDraggableArea"
}, om = {
  ref: "bottomSheetMain",
  class: "wgs-bottom-sheet__main grow"
}, im = {
  ref: "bottomSheetFooter",
  class: "wgs-bottom-sheet__footer"
};
function lm(e, t, n, s, r, o) {
  return Q(), ge("div", {
    class: He(["wgs-bottom-sheet WGS_BS", e.props.class]),
    ref: "bottomSheet",
    "aria-hidden": !e.showSheet,
    role: "dialog"
  }, [
    de(cd, null, {
      default: Ke(() => [
        Ea(q("div", {
          onClick: t[0] || (t[0] = (...i) => e.clickOnOverlayHandler && e.clickOnOverlayHandler(...i)),
          class: "wgs-bottom-sheet__overlay"
        }, null, 512), [
          [gd, e.overlay && e.showSheet]
        ])
      ]),
      _: 1
    }),
    q("div", {
      ref: "bottomSheetContent",
      class: He(e.sheetContentClasses)
    }, [
      q("header", sm, [
        e.showDraggable ? (Q(), ge("div", rm, t[1] || (t[1] = [
          q("div", { class: "wgs-bottom-sheet__draggable-thumb" }, null, -1)
        ]), 512)) : Ue("", !0),
        Is(e.$slots, "header", {}, void 0, !0)
      ], 512),
      q("main", om, [
        Is(e.$slots, "default", {}, void 0, !0)
      ], 512),
      q("footer", im, [
        Is(e.$slots, "footer", {}, void 0, !0)
      ], 512)
    ], 2)
  ], 10, nm);
}
const Qo = /* @__PURE__ */ Xt(Zo, [["render", lm], ["__scopeId", "data-v-b01d37cb"]]);
class kc {
  static openLink(t) {
    var n;
    (n = window == null ? void 0 : window.Telegram) != null && n.WebApp && (t.includes("t.me") ? (console.log("openTelegramLink", t), window.Telegram.WebApp.openTelegramLink(t)) : (console.log("openLink", t), window.Telegram.WebApp.openLink(t)));
  }
  static haptic(t) {
    var n, s, r;
    (r = (s = (n = window == null ? void 0 : window.Telegram) == null ? void 0 : n.WebApp) == null ? void 0 : s.HapticFeedback) != null && r.notificationOccurred && window.Telegram.WebApp.HapticFeedback.notificationOccurred(t);
  }
}
const am = {}, cm = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none"
};
function um(e, t) {
  return Q(), ge("svg", cm, t[0] || (t[0] = [
    q("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.46967 5.46967C5.76256 5.17678 6.23744 5.17678 6.53033 5.46967L12 10.9393L17.4697 5.46967C17.7626 5.17678 18.2374 5.17678 18.5303 5.46967C18.8232 5.76256 18.8232 6.23744 18.5303 6.53033L13.0607 12L18.5303 17.4697C18.8232 17.7626 18.8232 18.2374 18.5303 18.5303C18.2374 18.8232 17.7626 18.8232 17.4697 18.5303L12 13.0607L6.53033 18.5303C6.23744 18.8232 5.76256 18.8232 5.46967 18.5303C5.17678 18.2374 5.17678 17.7626 5.46967 17.4697L10.9393 12L5.46967 6.53033C5.17678 6.23744 5.17678 5.76256 5.46967 5.46967Z",
      class: "dark:wg-fill-gray-500 wg-fill-gray-900"
    }, null, -1)
  ]));
}
const _s = /* @__PURE__ */ Xt(am, [["render", um], ["__scopeId", "data-v-479a6fc7"]]), fm = /* @__PURE__ */ lt({
  components: { CustomButtonFlat: Bo, CloseIcon: _s, BottomSheet: Qo },
  props: ["task", "tabNumber"],
  emits: ["check", "openLink", "error", "openReport"],
  setup(e, { emit: t }) {
    const n = ms(), s = ue(null), r = ue(!0), o = ue(!1), i = ue(!1);
    Jt(() => {
      localStorage.getItem("clickedOnLink") && (o.value = !0);
    });
    const l = function() {
      var p, b;
      i.value = !1, r.value = !((p = e.task.status) != null && p.createdAt), o.value = (b = e.task.status) == null ? void 0 : b.createdAt, s.value.open();
    }, a = function() {
      s.value.close(), setTimeout(() => {
        o.value = !1, localStorage.removeItem("clickedOnLink"), localStorage.removeItem("lastVisitedTask");
      }, 400);
    };
    return r.value = !1, {
      open: l,
      close: a,
      taskBottomSheet: s,
      checkDisabled: r,
      clickCheck: async function() {
        try {
          await n.finishTask(e.task.id, e.task.campaignId);
        } catch (p) {
          t("error", p.message);
          return;
        }
        a();
      },
      clickLink: async function() {
        i.value = !0;
        try {
          await n.startTask(e.task.id, e.task.campaignId);
        } catch (p) {
          t("error", p.message);
          return;
        } finally {
          i.value = !1;
        }
        kc.openLink(e.task.url), o.value = !0, localStorage.setItem("lastVisitedTask", e.task.id), localStorage.setItem("clickedOnLink", !0), setTimeout(() => {
          r.value = !1;
        }, 2e3);
      },
      sendReport: async () => {
        t("openReport");
      },
      hasActiveLink: o,
      linkDisabled: i
    };
  }
}), dm = { class: "wg-w-full wg-flex wg-justify-end wg-px-[16px] wg-pt-[16px]" }, hm = { class: "wg-flex wg-flex-col wg-text-center wg-items-center wg-px-[16px] wg-pb-[40px]" }, pm = ["src"], mm = { class: "wg-text-h2 wg-text-gray-900 dark:wg-text-white wg-text-20 wg-font-bold wg-mt-[16px]" }, gm = { class: "wg-text-gray-700 dark:wg-text-gray-300 wg-text-17 wg-mt-[8px] wg-overflow-y-scroll wg-max-h-[110px]" }, _m = {
  key: 1,
  class: "wg-mt-[16px] wg-flex wg-justify-center wg-gap-[24px]"
}, bm = ["src"], wm = { class: "wg-text-h2 wg-font-bold wg-dark:text-white" }, ym = { class: "wg-flex wg-flex-col wg-gap-[16px] wg-mb-[6px] wg-px-[16px] wg-pb-[32px] wg-mt-[24px]" };
function Em(e, t, n, s, r, o) {
  const i = In("CloseIcon"), l = In("CustomButtonFlat"), a = In("BottomSheet");
  return Q(), qe(a, {
    class: "custom-wgs-bottom-sheet",
    ref: "taskBottomSheet"
  }, {
    header: Ke(() => [
      q("div", dm, [
        q("div", {
          class: "wg-cursor-pointer",
          onClick: t[0] || (t[0] = (c) => e.close())
        }, [
          de(i)
        ])
      ])
    ]),
    default: Ke(() => {
      var c, u, f, p, b, _;
      return [
        q("div", hm, [
          e.$props.task.logo ? (Q(), ge("img", {
            key: 0,
            src: e.$props.task.logo,
            class: "wg-size-[64px] wg-rounded-full"
          }, null, 8, pm)) : Ue("", !0),
          q("div", mm, Ce(e.$props.task.title), 1),
          q("div", gm, Ce(e.$props.task.description), 1),
          e.$props.task.rewards ? (Q(), ge("div", _m, [
            (Q(!0), ge(Le, null, Mo(e.$props.task.rewards, (T) => (Q(), ge("div", {
              key: T.id,
              class: "wg-flex wg-items-center wg-gap-[6px]"
            }, [
              q("img", {
                src: T.logo,
                class: "wg-size-[24px]"
              }, null, 8, bm),
              q("span", wm, "+" + Ce((+T.value).toLocaleString("ru-RU")), 1)
            ]))), 128))
          ])) : Ue("", !0)
        ]),
        q("div", ym, [
          ((u = (c = e.$props.task) == null ? void 0 : c.status) == null ? void 0 : u.hasReceivedReport) === !1 ? (Q(), qe(l, {
            key: 0,
            class: He(["wg-w-full btn-wgs-lg", e.hasActiveLink ? "btn-wgs-black" : "btn-wgs-gray"]),
            disabled: e.checkDisabled,
            onClick: t[1] || (t[1] = (T) => e.sendReport())
          }, {
            default: Ke(() => [
              Cn(Ce(e.$props.task.reportBtn), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])) : ((p = (f = e.$props.task) == null ? void 0 : f.status) == null ? void 0 : p.hasReceivedReport) === !0 && !((_ = (b = e.$props.task) == null ? void 0 : b.status) != null && _.isCompleted) ? (Q(), qe(l, {
            key: 1,
            class: "wg-w-full btn-wgs-lg btn-wgs-black",
            disabled: !0
          }, {
            default: Ke(() => [
              Cn(Ce(e.$props.task.awaitingText), 1)
            ]),
            _: 1
          })) : (Q(), qe(l, {
            key: 2,
            class: He(["wg-w-full btn-wgs-lg", e.hasActiveLink ? "btn-wgs-black" : "btn-wgs-gray"]),
            disabled: e.checkDisabled,
            onClick: t[2] || (t[2] = (T) => e.clickCheck())
          }, {
            default: Ke(() => [
              Cn(Ce(e.$props.task.doneBtn), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])),
          de(l, {
            class: He(["wg-w-full btn-wgs-lg", e.hasActiveLink ? "btn-wgs-gray" : "btn-wgs-black"]),
            disabled: e.linkDisabled,
            onClick: t[3] || (t[3] = (T) => e.clickLink())
          }, {
            default: Ke(() => [
              Cn(Ce(e.$props.task.startBtn), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])
        ])
      ];
    }),
    _: 1
  }, 512);
}
const Tm = /* @__PURE__ */ Xt(fm, [["render", Em]]), Sm = /* @__PURE__ */ lt({
  name: "TopNotification",
  components: { CloseIcon: _s },
  setup() {
    let e = ue(!1), t = ue(null), n = ue(""), s = ue(""), r = ue("error");
    Jt(() => {
      window.addEventListener("WallgramShowcase_TopNotification", o);
    }), Fn(() => {
      window.removeEventListener("WallgramShowcase_TopNotification", o);
    });
    let o = function(i) {
      var l;
      console.log("notif", i), (l = i == null ? void 0 : i.detail) != null && l.title && (n.value = i.detail.title, s.value = i.detail.description ?? "", r.value = i.detail.type === "success" ? "success" : "error", e.value = !0, setTimeout(() => {
        kc.haptic("success");
      }, 100), setTimeout(() => {
        e.value = !1;
      }, 3e3));
    };
    return { isVisible: e, image: t, title: n, description: s, type: r };
  }
}), vm = { class: "wg-w-8 wg-shrink-0" }, Cm = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  fill: "none"
}, Lm = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  fill: "none"
}, km = { class: "wg-flex wg-flex-col wg-gap-[6px] wg-text-white wg-grow" }, Am = { class: "wg-font-medium wg-text-16-reg wg-leading-[20px] wg-text-white" };
function Om(e, t, n, s, r, o) {
  const i = In("CloseIcon");
  return Q(), ge("div", {
    id: "WGS_top_alert_wrapper",
    class: He(["wg-fixed wg-bg-red wg-w-full", { "wg-top-0": e.isVisible, "wg-top-[-500px]": !e.isVisible }]),
    onClick: t[0] || (t[0] = (l) => e.isVisible = !1)
  }, [
    q("div", {
      class: He(["alert wg-flex wg-gap-[16px] wg-items-center", {
        "alert-success": e.type == "success",
        "alert-error": e.type == "error"
      }])
    }, [
      q("div", vm, [
        e.type == "error" ? (Q(), ge("svg", Cm, t[1] || (t[1] = [
          q("path", {
            d: "M16 31C7.71549 31 1 24.2845 1 16C1 7.71549 7.71549 1 16 1C24.2845 1 31 7.71549 31 16C31 24.2845 24.2845 31 16 31Z",
            stroke: "white",
            "stroke-width": "2"
          }, null, -1),
          q("path", {
            d: "M16 9L16 18",
            stroke: "white",
            "stroke-width": "2",
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
          }, null, -1),
          q("circle", {
            cx: "16",
            cy: "22",
            r: "1",
            fill: "white"
          }, null, -1)
        ]))) : Ue("", !0),
        e.type == "success" ? (Q(), ge("svg", Lm, t[2] || (t[2] = [
          q("path", {
            d: "M16 31C7.71549 31 1 24.2845 1 16C1 7.71549 7.71549 1 16 1C24.2845 1 31 7.71549 31 16C31 24.2845 24.2845 31 16 31Z",
            stroke: "white",
            "stroke-width": "2"
          }, null, -1),
          q("path", {
            d: "M22.1659 13.7071L14.9741 21.2421C14.5802 21.6549 13.9213 21.6549 13.5274 21.2422L9.83428 17.3733C9.36738 16.8842 9.36738 16.1145 9.83428 15.6254C10.3329 15.103 11.1668 15.103 11.6654 15.6254L14.2508 18.3338L20.3346 11.9593C20.8332 11.4369 21.6671 11.4368 22.1658 11.9592C22.6327 12.4483 22.6327 13.218 22.1659 13.7071Z",
            fill: "white"
          }, null, -1)
        ]))) : Ue("", !0)
      ]),
      q("div", km, [
        q("div", Am, Ce(e.title), 1)
      ]),
      de(i, { class: "wg-shrink-0 white" })
    ], 2)
  ], 2);
}
const Im = /* @__PURE__ */ Xt(Sm, [["render", Om]]), Rm = {}, Nm = { class: "loader" };
function xm(e, t) {
  return Q(), ge("span", Nm);
}
const Pm = /* @__PURE__ */ Xt(Rm, [["render", xm], ["__scopeId", "data-v-88f0cbdc"]]), Fm = { class: "wg-relative" }, Dm = ["placeholder"], Mm = { class: "wg-relative" }, $m = {
  key: 0,
  class: "wg-absolute -wg-top-1 -wg-right-1 wg-text-[10px] wg-bg-black wg-text-white wg-rounded-full wg-w-[12px] wg-h-[12px] wg-flex wg-items-center wg-justify-center"
}, Um = /* @__PURE__ */ lt({
  __name: "CustomInput",
  props: /* @__PURE__ */ _i({
    class: {},
    placeholder: {}
  }, {
    modelValue: { required: !0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ _i(["upload", "focusin", "focusout"], ["update:modelValue"]),
  setup(e, { emit: t }) {
    const n = Mf(e, "modelValue"), s = t, r = jt({ totalFiles: 0 }), o = Ra("fileInput"), i = () => {
      o.value.click();
    }, l = (a) => {
      r.totalFiles = a.target.files.length, s("upload", a.target.files);
    };
    return (a, c) => (Q(), ge("div", Fm, [
      Ea(q("input", {
        "onUpdate:modelValue": c[0] || (c[0] = (u) => n.value = u),
        class: "wg-input wg-w-full !wg-pr-10",
        placeholder: a.placeholder,
        onFocusin: c[1] || (c[1] = (u) => s("focusin")),
        onFocusout: c[2] || (c[2] = (u) => s("focusout"))
      }, null, 40, Dm), [
        [Rd, n.value]
      ]),
      q("div", {
        class: "wg-absolute wg-top-0 wg-right-4 wg-h-[52px] wg-flex wg-items-center wg-cursor-pointer",
        onClick: i
      }, [
        q("div", Mm, [
          r.totalFiles ? (Q(), ge("div", $m, Ce(r.totalFiles), 1)) : Ue("", !0),
          de(_s, { class: "wg-rotate-45" })
        ]),
        q("input", {
          id: "fileInputId",
          type: "file",
          ref_key: "fileInput",
          ref: o,
          class: "wg-hidden",
          accept: "image/*",
          onChange: l
        }, null, 544)
      ])
    ]));
  }
}), Hm = { class: "wg-w-full wg-flex wg-justify-end wg-px-[16px] wg-pt-[16px]" }, Vm = { class: "wg-flex wg-flex-col wg-text-center wg-items-center wg-px-[16px] wg-pb-[40px] wg-overflow-y-scroll wg-max-h-[190px]" }, Wm = { class: "wg-text-gray-700 dark:wg-text-gray-300 wg-text-17 wg-mt-[8px]" }, Bm = { class: "wg-whitespace-break-spaces" }, jm = { class: "wg-flex wg-flex-col wg-gap-[16px] wg-mb-[6px] wg-px-[16px] wg-pb-[32px] wg-mt-[24px]" }, Km = /* @__PURE__ */ lt({
  __name: "ReportBottomSheet",
  props: {
    task: {}
  },
  emits: ["close", "error"],
  setup(e, { expose: t, emit: n }) {
    const s = e, r = n, o = Ra("reportBottomSheet"), i = () => {
      o.value.open();
    }, l = () => {
      o.value.close(), Object.assign(a, { message: "", files: [] }), r("close");
    }, a = jt({ message: "", files: [] }), c = jt({ isLoading: !1 }), u = (L) => {
      a.files = [...L];
    }, f = ms(), { t: p } = gs(), b = async () => {
      var L, E;
      try {
        if (!a.message && !a.files.length)
          throw new Error(p("error.FORM_VALIDATION.title"));
        if ((E = (L = a.files) == null ? void 0 : L[0]) != null && E.size && (a.files[0].size / 1048576 || 0) > 1)
          throw new Error(p("error.IMAGE_SIZE_VALIDATION.title", { size: 1 }));
        c.isLoading = !0, await f.sendReport(s.task.id, a), l();
      } catch (O) {
        r("error", O.message);
        return;
      } finally {
        c.isLoading = !1;
      }
    }, _ = (L) => {
      L.target.closest("#WGS_report") || L.preventDefault();
    }, T = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    let C = 0;
    const g = () => {
      T && (C = document.documentElement.scrollTop, document.body.classList.add("wg-body-lock"), document.querySelectorAll(".WGS_BS").forEach((L) => {
        L.classList.add("wg-fix-ios-bs");
      }), document.addEventListener("touchmove", _, { passive: !1 }), setTimeout(() => {
        console.log("set scrollTop to 0"), document.documentElement.scrollTop = 0;
      }, 800));
    }, v = () => {
      T && (document.body.classList.remove("wg-body-lock"), document.querySelectorAll(".WGS_BS").forEach((L) => {
        L.classList.remove("wg-fix-ios-bs");
      }), document.removeEventListener("touchmove", _), document.documentElement.scrollTop = C);
    };
    return t({
      open: i,
      close: l
    }), (L, E) => (Q(), qe(Qo, {
      class: "custom-wgs-bottom-sheet",
      ref_key: "reportBottomSheet",
      ref: o,
      id: "WGS_report"
    }, {
      header: Ke(() => [
        q("div", Hm, [
          q("div", {
            class: "wg-cursor-pointer",
            onClick: E[0] || (E[0] = (O) => l())
          }, [
            de(_s)
          ])
        ])
      ]),
      default: Ke(() => [
        q("div", Vm, [
          q("div", Wm, [
            q("div", Bm, Ce(L.task.description), 1)
          ])
        ]),
        q("div", jm, [
          de(Um, {
            modelValue: a.message,
            "onUpdate:modelValue": E[1] || (E[1] = (O) => a.message = O),
            placeholder: "Enter message",
            onUpload: u,
            onFocusin: g,
            onFocusout: v
          }, null, 8, ["modelValue"]),
          de(Bo, {
            class: "wg-w-full btn-wgs-lg btn-wgs-black",
            disabled: c.isLoading,
            onClick: b
          }, {
            default: Ke(() => [
              Cn(Ce(L.$props.task.reportBtn), 1)
            ]),
            _: 1
          }, 8, ["disabled"])
        ])
      ]),
      _: 1
    }, 512));
  }
}), Gm = { class: "wg-w-full wg-flex wg-justify-between wg-px-[16px] wg-py-[16px]" }, qm = { class: "wg-flex wg-flex-col wg-gap-[8px]" }, Ym = { class: "wg-text-h2 wg-text-gray-900 dark:wg-text-white" }, Jm = { class: "wg-text-13-reg wg-text-gray-700 dark:wg-text-gray-500" }, Xm = { class: "wg-flex wg-flex-col wg-w-full wg-bg-white dark:!wg-bg-black wg-px-[16px]" }, zm = {
  key: 0,
  class: "wg-w-full wg-flex wg-flex-col"
}, Zm = {
  key: 0,
  class: "wg-text-16 wg-bg-white dark:!wg-bg-black wg-text-black dark:!wg-text-white"
}, Qm = /* @__PURE__ */ lt({
  __name: "App",
  setup(e) {
    const t = ms(), n = ue(null), s = ue(null), r = ue(null), o = ue(null);
    Jt(() => {
      window.addEventListener("WallgramShowcase_init", a), window.addEventListener("WallgramShowcase_show", i);
    });
    const i = () => {
      t.loadPlatformAndTasks(), o.value.open();
    }, l = () => {
      o.value.close();
    };
    Fn(() => {
      window.removeEventListener("WallgramShowcase_init", a);
    });
    const a = () => {
      const _ = localStorage.getItem("lastVisitedTask");
      _ && (f(_), localStorage.removeItem("lastVisitedTask"));
    }, c = (_) => {
      u("error", _);
    }, u = (_, T, C = "") => {
      window.dispatchEvent(
        new CustomEvent("WallgramShowcase_TopNotification", {
          detail: { title: T, description: C, type: _ }
        })
      );
    }, f = (_) => {
      n.value = t.tasks.find((T) => T.id === _), n.value && ln(() => {
        s.value.open();
      });
    }, p = () => {
      s.value.close(), r.value.open();
    }, b = () => {
      s.value.open();
    };
    return (_, T) => (Q(), qe(Ju, { to: "body" }, [
      q("div", {
        id: "WGS",
        class: He({ dark: sn(t).isDarkTheme })
      }, [
        de(Qo, {
          id: "",
          class: "custom-wgs-bottom-sheet-full",
          ref_key: "appBottomSheetRef",
          ref: o
        }, {
          header: Ke(() => [
            q("div", Gm, [
              q("div", qm, [
                q("div", Ym, Ce(_.$t("tasks_title")), 1),
                q("div", Jm, Ce(_.$t("tasks_description")), 1)
              ]),
              q("div", {
                class: "wg-cursor-pointer wg-rounded-full wg-flex wg-items-center wg-justify-center",
                onClick: T[0] || (T[0] = (C) => l())
              }, [
                de(_s)
              ])
            ])
          ]),
          default: Ke(() => [
            q("div", Xm, [
              sn(t).showLoader ? Ue("", !0) : (Q(), ge("div", zm, [
                (Q(!0), ge(Le, null, Mo(sn(t).tasks, (C, g) => (Q(), qe(tm, {
                  key: "wg_task" + g,
                  task: C,
                  class: He({ "bordered-bottom": g < sn(t).tasks.length - 1 }),
                  onClick: f
                }, null, 8, ["task", "class"]))), 128)),
                sn(t).tasks.length == 0 ? (Q(), ge("span", Zm, Ce(_.$t("tasks_not_found")), 1)) : Ue("", !0)
              ])),
              sn(t).showLoader ? (Q(), qe(Pm, { key: 1 })) : Ue("", !0)
            ])
          ]),
          _: 1
        }, 512),
        n.value ? (Q(), qe(Tm, {
          key: 0,
          ref_key: "taskBottomSheetRef",
          ref: s,
          task: n.value,
          onError: c,
          onOpenReport: p
        }, null, 8, ["task"])) : Ue("", !0),
        n.value ? (Q(), qe(Km, {
          key: 1,
          ref_key: "reportBottomSheetRef",
          ref: r,
          task: n.value,
          onError: c,
          onClose: b
        }, null, 8, ["task"])) : Ue("", !0),
        de(Im)
      ], 2)
    ]));
  }
}), eg = "$repository";
function Ac(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: tg } = Object.prototype, { getPrototypeOf: ei } = Object, pr = /* @__PURE__ */ ((e) => (t) => {
  const n = tg.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), ut = (e) => (e = e.toLowerCase(), (t) => pr(t) === e), mr = (e) => (t) => typeof t === e, { isArray: Dn } = Array, us = mr("undefined");
function ng(e) {
  return e !== null && !us(e) && e.constructor !== null && !us(e.constructor) && et(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const Oc = ut("ArrayBuffer");
function sg(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Oc(e.buffer), t;
}
const rg = mr("string"), et = mr("function"), Ic = mr("number"), gr = (e) => e !== null && typeof e == "object", og = (e) => e === !0 || e === !1, Fs = (e) => {
  if (pr(e) !== "object")
    return !1;
  const t = ei(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, ig = ut("Date"), lg = ut("File"), ag = ut("Blob"), cg = ut("FileList"), ug = (e) => gr(e) && et(e.pipe), fg = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || et(e.append) && ((t = pr(e)) === "formdata" || // detect form-data instance
  t === "object" && et(e.toString) && e.toString() === "[object FormData]"));
}, dg = ut("URLSearchParams"), [hg, pg, mg, gg] = ["ReadableStream", "Request", "Response", "Headers"].map(ut), _g = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function bs(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let s, r;
  if (typeof e != "object" && (e = [e]), Dn(e))
    for (s = 0, r = e.length; s < r; s++)
      t.call(null, e[s], s, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), i = o.length;
    let l;
    for (s = 0; s < i; s++)
      l = o[s], t.call(null, e[l], l, e);
  }
}
function Rc(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let s = n.length, r;
  for (; s-- > 0; )
    if (r = n[s], t === r.toLowerCase())
      return r;
  return null;
}
const cn = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Nc = (e) => !us(e) && e !== cn;
function mo() {
  const { caseless: e } = Nc(this) && this || {}, t = {}, n = (s, r) => {
    const o = e && Rc(t, r) || r;
    Fs(t[o]) && Fs(s) ? t[o] = mo(t[o], s) : Fs(s) ? t[o] = mo({}, s) : Dn(s) ? t[o] = s.slice() : t[o] = s;
  };
  for (let s = 0, r = arguments.length; s < r; s++)
    arguments[s] && bs(arguments[s], n);
  return t;
}
const bg = (e, t, n, { allOwnKeys: s } = {}) => (bs(t, (r, o) => {
  n && et(r) ? e[o] = Ac(r, n) : e[o] = r;
}, { allOwnKeys: s }), e), wg = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), yg = (e, t, n, s) => {
  e.prototype = Object.create(t.prototype, s), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, Eg = (e, t, n, s) => {
  let r, o, i;
  const l = {};
  if (t = t || {}, e == null) return t;
  do {
    for (r = Object.getOwnPropertyNames(e), o = r.length; o-- > 0; )
      i = r[o], (!s || s(i, e, t)) && !l[i] && (t[i] = e[i], l[i] = !0);
    e = n !== !1 && ei(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Tg = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const s = e.indexOf(t, n);
  return s !== -1 && s === n;
}, Sg = (e) => {
  if (!e) return null;
  if (Dn(e)) return e;
  let t = e.length;
  if (!Ic(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, vg = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && ei(Uint8Array)), Cg = (e, t) => {
  const s = (e && e[Symbol.iterator]).call(e);
  let r;
  for (; (r = s.next()) && !r.done; ) {
    const o = r.value;
    t.call(e, o[0], o[1]);
  }
}, Lg = (e, t) => {
  let n;
  const s = [];
  for (; (n = e.exec(t)) !== null; )
    s.push(n);
  return s;
}, kg = ut("HTMLFormElement"), Ag = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, s, r) {
    return s.toUpperCase() + r;
  }
), Al = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Og = ut("RegExp"), xc = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), s = {};
  bs(n, (r, o) => {
    let i;
    (i = t(r, o, e)) !== !1 && (s[o] = i || r);
  }), Object.defineProperties(e, s);
}, Ig = (e) => {
  xc(e, (t, n) => {
    if (et(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const s = e[n];
    if (et(s)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, Rg = (e, t) => {
  const n = {}, s = (r) => {
    r.forEach((o) => {
      n[o] = !0;
    });
  };
  return Dn(e) ? s(e) : s(String(e).split(t)), n;
}, Ng = () => {
}, xg = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, Mr = "abcdefghijklmnopqrstuvwxyz", Ol = "0123456789", Pc = {
  DIGIT: Ol,
  ALPHA: Mr,
  ALPHA_DIGIT: Mr + Mr.toUpperCase() + Ol
}, Pg = (e = 16, t = Pc.ALPHA_DIGIT) => {
  let n = "";
  const { length: s } = t;
  for (; e--; )
    n += t[Math.random() * s | 0];
  return n;
};
function Fg(e) {
  return !!(e && et(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const Dg = (e) => {
  const t = new Array(10), n = (s, r) => {
    if (gr(s)) {
      if (t.indexOf(s) >= 0)
        return;
      if (!("toJSON" in s)) {
        t[r] = s;
        const o = Dn(s) ? [] : {};
        return bs(s, (i, l) => {
          const a = n(i, r + 1);
          !us(a) && (o[l] = a);
        }), t[r] = void 0, o;
      }
    }
    return s;
  };
  return n(e, 0);
}, Mg = ut("AsyncFunction"), $g = (e) => e && (gr(e) || et(e)) && et(e.then) && et(e.catch), Fc = ((e, t) => e ? setImmediate : t ? ((n, s) => (cn.addEventListener("message", ({ source: r, data: o }) => {
  r === cn && o === n && s.length && s.shift()();
}, !1), (r) => {
  s.push(r), cn.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  et(cn.postMessage)
), Ug = typeof queueMicrotask < "u" ? queueMicrotask.bind(cn) : typeof process < "u" && process.nextTick || Fc, I = {
  isArray: Dn,
  isArrayBuffer: Oc,
  isBuffer: ng,
  isFormData: fg,
  isArrayBufferView: sg,
  isString: rg,
  isNumber: Ic,
  isBoolean: og,
  isObject: gr,
  isPlainObject: Fs,
  isReadableStream: hg,
  isRequest: pg,
  isResponse: mg,
  isHeaders: gg,
  isUndefined: us,
  isDate: ig,
  isFile: lg,
  isBlob: ag,
  isRegExp: Og,
  isFunction: et,
  isStream: ug,
  isURLSearchParams: dg,
  isTypedArray: vg,
  isFileList: cg,
  forEach: bs,
  merge: mo,
  extend: bg,
  trim: _g,
  stripBOM: wg,
  inherits: yg,
  toFlatObject: Eg,
  kindOf: pr,
  kindOfTest: ut,
  endsWith: Tg,
  toArray: Sg,
  forEachEntry: Cg,
  matchAll: Lg,
  isHTMLForm: kg,
  hasOwnProperty: Al,
  hasOwnProp: Al,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: xc,
  freezeMethods: Ig,
  toObjectSet: Rg,
  toCamelCase: Ag,
  noop: Ng,
  toFiniteNumber: xg,
  findKey: Rc,
  global: cn,
  isContextDefined: Nc,
  ALPHABET: Pc,
  generateString: Pg,
  isSpecCompliantForm: Fg,
  toJSONObject: Dg,
  isAsyncFn: Mg,
  isThenable: $g,
  setImmediate: Fc,
  asap: Ug
};
function z(e, t, n, s, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), s && (this.request = s), r && (this.response = r, this.status = r.status ? r.status : null);
}
I.inherits(z, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: I.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Dc = z.prototype, Mc = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  Mc[e] = { value: e };
});
Object.defineProperties(z, Mc);
Object.defineProperty(Dc, "isAxiosError", { value: !0 });
z.from = (e, t, n, s, r, o) => {
  const i = Object.create(Dc);
  return I.toFlatObject(e, i, function(a) {
    return a !== Error.prototype;
  }, (l) => l !== "isAxiosError"), z.call(i, e.message, t, n, s, r), i.cause = e, i.name = e.name, o && Object.assign(i, o), i;
};
const Hg = null;
function go(e) {
  return I.isPlainObject(e) || I.isArray(e);
}
function $c(e) {
  return I.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Il(e, t, n) {
  return e ? e.concat(t).map(function(r, o) {
    return r = $c(r), !n && o ? "[" + r + "]" : r;
  }).join(n ? "." : "") : t;
}
function Vg(e) {
  return I.isArray(e) && !e.some(go);
}
const Wg = I.toFlatObject(I, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function _r(e, t, n) {
  if (!I.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = I.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(T, C) {
    return !I.isUndefined(C[T]);
  });
  const s = n.metaTokens, r = n.visitor || u, o = n.dots, i = n.indexes, a = (n.Blob || typeof Blob < "u" && Blob) && I.isSpecCompliantForm(t);
  if (!I.isFunction(r))
    throw new TypeError("visitor must be a function");
  function c(_) {
    if (_ === null) return "";
    if (I.isDate(_))
      return _.toISOString();
    if (!a && I.isBlob(_))
      throw new z("Blob is not supported. Use a Buffer instead.");
    return I.isArrayBuffer(_) || I.isTypedArray(_) ? a && typeof Blob == "function" ? new Blob([_]) : Buffer.from(_) : _;
  }
  function u(_, T, C) {
    let g = _;
    if (_ && !C && typeof _ == "object") {
      if (I.endsWith(T, "{}"))
        T = s ? T : T.slice(0, -2), _ = JSON.stringify(_);
      else if (I.isArray(_) && Vg(_) || (I.isFileList(_) || I.endsWith(T, "[]")) && (g = I.toArray(_)))
        return T = $c(T), g.forEach(function(L, E) {
          !(I.isUndefined(L) || L === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? Il([T], E, o) : i === null ? T : T + "[]",
            c(L)
          );
        }), !1;
    }
    return go(_) ? !0 : (t.append(Il(C, T, o), c(_)), !1);
  }
  const f = [], p = Object.assign(Wg, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: go
  });
  function b(_, T) {
    if (!I.isUndefined(_)) {
      if (f.indexOf(_) !== -1)
        throw Error("Circular reference detected in " + T.join("."));
      f.push(_), I.forEach(_, function(g, v) {
        (!(I.isUndefined(g) || g === null) && r.call(
          t,
          g,
          I.isString(v) ? v.trim() : v,
          T,
          p
        )) === !0 && b(g, T ? T.concat(v) : [v]);
      }), f.pop();
    }
  }
  if (!I.isObject(e))
    throw new TypeError("data must be an object");
  return b(e), t;
}
function Rl(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(s) {
    return t[s];
  });
}
function ti(e, t) {
  this._pairs = [], e && _r(e, this, t);
}
const Uc = ti.prototype;
Uc.append = function(t, n) {
  this._pairs.push([t, n]);
};
Uc.toString = function(t) {
  const n = t ? function(s) {
    return t.call(this, s, Rl);
  } : Rl;
  return this._pairs.map(function(r) {
    return n(r[0]) + "=" + n(r[1]);
  }, "").join("&");
};
function Bg(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Hc(e, t, n) {
  if (!t)
    return e;
  const s = n && n.encode || Bg, r = n && n.serialize;
  let o;
  if (r ? o = r(t, n) : o = I.isURLSearchParams(t) ? t.toString() : new ti(t, n).toString(s), o) {
    const i = e.indexOf("#");
    i !== -1 && (e = e.slice(0, i)), e += (e.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return e;
}
class Nl {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, s) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: s ? s.synchronous : !1,
      runWhen: s ? s.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    I.forEach(this.handlers, function(s) {
      s !== null && t(s);
    });
  }
}
const Vc = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, jg = typeof URLSearchParams < "u" ? URLSearchParams : ti, Kg = typeof FormData < "u" ? FormData : null, Gg = typeof Blob < "u" ? Blob : null, qg = {
  isBrowser: !0,
  classes: {
    URLSearchParams: jg,
    FormData: Kg,
    Blob: Gg
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, ni = typeof window < "u" && typeof document < "u", _o = typeof navigator == "object" && navigator || void 0, Yg = ni && (!_o || ["ReactNative", "NativeScript", "NS"].indexOf(_o.product) < 0), Jg = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Xg = ni && window.location.href || "http://localhost", zg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ni,
  hasStandardBrowserEnv: Yg,
  hasStandardBrowserWebWorkerEnv: Jg,
  navigator: _o,
  origin: Xg
}, Symbol.toStringTag, { value: "Module" })), Ye = {
  ...zg,
  ...qg
};
function Zg(e, t) {
  return _r(e, new Ye.classes.URLSearchParams(), Object.assign({
    visitor: function(n, s, r, o) {
      return Ye.isNode && I.isBuffer(n) ? (this.append(s, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Qg(e) {
  return I.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function e_(e) {
  const t = {}, n = Object.keys(e);
  let s;
  const r = n.length;
  let o;
  for (s = 0; s < r; s++)
    o = n[s], t[o] = e[o];
  return t;
}
function Wc(e) {
  function t(n, s, r, o) {
    let i = n[o++];
    if (i === "__proto__") return !0;
    const l = Number.isFinite(+i), a = o >= n.length;
    return i = !i && I.isArray(r) ? r.length : i, a ? (I.hasOwnProp(r, i) ? r[i] = [r[i], s] : r[i] = s, !l) : ((!r[i] || !I.isObject(r[i])) && (r[i] = []), t(n, s, r[i], o) && I.isArray(r[i]) && (r[i] = e_(r[i])), !l);
  }
  if (I.isFormData(e) && I.isFunction(e.entries)) {
    const n = {};
    return I.forEachEntry(e, (s, r) => {
      t(Qg(s), r, n, 0);
    }), n;
  }
  return null;
}
function t_(e, t, n) {
  if (I.isString(e))
    try {
      return (t || JSON.parse)(e), I.trim(e);
    } catch (s) {
      if (s.name !== "SyntaxError")
        throw s;
    }
  return (0, JSON.stringify)(e);
}
const ws = {
  transitional: Vc,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const s = n.getContentType() || "", r = s.indexOf("application/json") > -1, o = I.isObject(t);
    if (o && I.isHTMLForm(t) && (t = new FormData(t)), I.isFormData(t))
      return r ? JSON.stringify(Wc(t)) : t;
    if (I.isArrayBuffer(t) || I.isBuffer(t) || I.isStream(t) || I.isFile(t) || I.isBlob(t) || I.isReadableStream(t))
      return t;
    if (I.isArrayBufferView(t))
      return t.buffer;
    if (I.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let l;
    if (o) {
      if (s.indexOf("application/x-www-form-urlencoded") > -1)
        return Zg(t, this.formSerializer).toString();
      if ((l = I.isFileList(t)) || s.indexOf("multipart/form-data") > -1) {
        const a = this.env && this.env.FormData;
        return _r(
          l ? { "files[]": t } : t,
          a && new a(),
          this.formSerializer
        );
      }
    }
    return o || r ? (n.setContentType("application/json", !1), t_(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || ws.transitional, s = n && n.forcedJSONParsing, r = this.responseType === "json";
    if (I.isResponse(t) || I.isReadableStream(t))
      return t;
    if (t && I.isString(t) && (s && !this.responseType || r)) {
      const i = !(n && n.silentJSONParsing) && r;
      try {
        return JSON.parse(t);
      } catch (l) {
        if (i)
          throw l.name === "SyntaxError" ? z.from(l, z.ERR_BAD_RESPONSE, this, null, this.response) : l;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ye.classes.FormData,
    Blob: Ye.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
I.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  ws.headers[e] = {};
});
const n_ = I.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), s_ = (e) => {
  const t = {};
  let n, s, r;
  return e && e.split(`
`).forEach(function(i) {
    r = i.indexOf(":"), n = i.substring(0, r).trim().toLowerCase(), s = i.substring(r + 1).trim(), !(!n || t[n] && n_[n]) && (n === "set-cookie" ? t[n] ? t[n].push(s) : t[n] = [s] : t[n] = t[n] ? t[n] + ", " + s : s);
  }), t;
}, xl = Symbol("internals");
function jn(e) {
  return e && String(e).trim().toLowerCase();
}
function Ds(e) {
  return e === !1 || e == null ? e : I.isArray(e) ? e.map(Ds) : String(e);
}
function r_(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let s;
  for (; s = n.exec(e); )
    t[s[1]] = s[2];
  return t;
}
const o_ = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function $r(e, t, n, s, r) {
  if (I.isFunction(s))
    return s.call(this, t, n);
  if (r && (t = n), !!I.isString(t)) {
    if (I.isString(s))
      return t.indexOf(s) !== -1;
    if (I.isRegExp(s))
      return s.test(t);
  }
}
function i_(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, s) => n.toUpperCase() + s);
}
function l_(e, t) {
  const n = I.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((s) => {
    Object.defineProperty(e, s + n, {
      value: function(r, o, i) {
        return this[s].call(this, t, r, o, i);
      },
      configurable: !0
    });
  });
}
class Je {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, s) {
    const r = this;
    function o(l, a, c) {
      const u = jn(a);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const f = I.findKey(r, u);
      (!f || r[f] === void 0 || c === !0 || c === void 0 && r[f] !== !1) && (r[f || a] = Ds(l));
    }
    const i = (l, a) => I.forEach(l, (c, u) => o(c, u, a));
    if (I.isPlainObject(t) || t instanceof this.constructor)
      i(t, n);
    else if (I.isString(t) && (t = t.trim()) && !o_(t))
      i(s_(t), n);
    else if (I.isHeaders(t))
      for (const [l, a] of t.entries())
        o(a, l, s);
    else
      t != null && o(n, t, s);
    return this;
  }
  get(t, n) {
    if (t = jn(t), t) {
      const s = I.findKey(this, t);
      if (s) {
        const r = this[s];
        if (!n)
          return r;
        if (n === !0)
          return r_(r);
        if (I.isFunction(n))
          return n.call(this, r, s);
        if (I.isRegExp(n))
          return n.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = jn(t), t) {
      const s = I.findKey(this, t);
      return !!(s && this[s] !== void 0 && (!n || $r(this, this[s], s, n)));
    }
    return !1;
  }
  delete(t, n) {
    const s = this;
    let r = !1;
    function o(i) {
      if (i = jn(i), i) {
        const l = I.findKey(s, i);
        l && (!n || $r(s, s[l], l, n)) && (delete s[l], r = !0);
      }
    }
    return I.isArray(t) ? t.forEach(o) : o(t), r;
  }
  clear(t) {
    const n = Object.keys(this);
    let s = n.length, r = !1;
    for (; s--; ) {
      const o = n[s];
      (!t || $r(this, this[o], o, t, !0)) && (delete this[o], r = !0);
    }
    return r;
  }
  normalize(t) {
    const n = this, s = {};
    return I.forEach(this, (r, o) => {
      const i = I.findKey(s, o);
      if (i) {
        n[i] = Ds(r), delete n[o];
        return;
      }
      const l = t ? i_(o) : String(o).trim();
      l !== o && delete n[o], n[l] = Ds(r), s[l] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return I.forEach(this, (s, r) => {
      s != null && s !== !1 && (n[r] = t && I.isArray(s) ? s.join(", ") : s);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const s = new this(t);
    return n.forEach((r) => s.set(r)), s;
  }
  static accessor(t) {
    const s = (this[xl] = this[xl] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function o(i) {
      const l = jn(i);
      s[l] || (l_(r, i), s[l] = !0);
    }
    return I.isArray(t) ? t.forEach(o) : o(t), this;
  }
}
Je.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
I.reduceDescriptors(Je.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(s) {
      this[n] = s;
    }
  };
});
I.freezeMethods(Je);
function Ur(e, t) {
  const n = this || ws, s = t || n, r = Je.from(s.headers);
  let o = s.data;
  return I.forEach(e, function(l) {
    o = l.call(n, o, r.normalize(), t ? t.status : void 0);
  }), r.normalize(), o;
}
function Bc(e) {
  return !!(e && e.__CANCEL__);
}
function Mn(e, t, n) {
  z.call(this, e ?? "canceled", z.ERR_CANCELED, t, n), this.name = "CanceledError";
}
I.inherits(Mn, z, {
  __CANCEL__: !0
});
function jc(e, t, n) {
  const s = n.config.validateStatus;
  !n.status || !s || s(n.status) ? e(n) : t(new z(
    "Request failed with status code " + n.status,
    [z.ERR_BAD_REQUEST, z.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function a_(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function c_(e, t) {
  e = e || 10;
  const n = new Array(e), s = new Array(e);
  let r = 0, o = 0, i;
  return t = t !== void 0 ? t : 1e3, function(a) {
    const c = Date.now(), u = s[o];
    i || (i = c), n[r] = a, s[r] = c;
    let f = o, p = 0;
    for (; f !== r; )
      p += n[f++], f = f % e;
    if (r = (r + 1) % e, r === o && (o = (o + 1) % e), c - i < t)
      return;
    const b = u && c - u;
    return b ? Math.round(p * 1e3 / b) : void 0;
  };
}
function u_(e, t) {
  let n = 0, s = 1e3 / t, r, o;
  const i = (c, u = Date.now()) => {
    n = u, r = null, o && (clearTimeout(o), o = null), e.apply(null, c);
  };
  return [(...c) => {
    const u = Date.now(), f = u - n;
    f >= s ? i(c, u) : (r = c, o || (o = setTimeout(() => {
      o = null, i(r);
    }, s - f)));
  }, () => r && i(r)];
}
const Ys = (e, t, n = 3) => {
  let s = 0;
  const r = c_(50, 250);
  return u_((o) => {
    const i = o.loaded, l = o.lengthComputable ? o.total : void 0, a = i - s, c = r(a), u = i <= l;
    s = i;
    const f = {
      loaded: i,
      total: l,
      progress: l ? i / l : void 0,
      bytes: a,
      rate: c || void 0,
      estimated: c && l && u ? (l - i) / c : void 0,
      event: o,
      lengthComputable: l != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, n);
}, Pl = (e, t) => {
  const n = e != null;
  return [(s) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: s
  }), t[1]];
}, Fl = (e) => (...t) => I.asap(() => e(...t)), f_ = Ye.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = Ye.navigator && /(msie|trident)/i.test(Ye.navigator.userAgent), n = document.createElement("a");
    let s;
    function r(o) {
      let i = o;
      return t && (n.setAttribute("href", i), i = n.href), n.setAttribute("href", i), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return s = r(window.location.href), function(i) {
      const l = I.isString(i) ? r(i) : i;
      return l.protocol === s.protocol && l.host === s.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
), d_ = Ye.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, s, r, o) {
      const i = [e + "=" + encodeURIComponent(t)];
      I.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()), I.isString(s) && i.push("path=" + s), I.isString(r) && i.push("domain=" + r), o === !0 && i.push("secure"), document.cookie = i.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function h_(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function p_(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Kc(e, t) {
  return e && !h_(t) ? p_(e, t) : t;
}
const Dl = (e) => e instanceof Je ? { ...e } : e;
function pn(e, t) {
  t = t || {};
  const n = {};
  function s(c, u, f) {
    return I.isPlainObject(c) && I.isPlainObject(u) ? I.merge.call({ caseless: f }, c, u) : I.isPlainObject(u) ? I.merge({}, u) : I.isArray(u) ? u.slice() : u;
  }
  function r(c, u, f) {
    if (I.isUndefined(u)) {
      if (!I.isUndefined(c))
        return s(void 0, c, f);
    } else return s(c, u, f);
  }
  function o(c, u) {
    if (!I.isUndefined(u))
      return s(void 0, u);
  }
  function i(c, u) {
    if (I.isUndefined(u)) {
      if (!I.isUndefined(c))
        return s(void 0, c);
    } else return s(void 0, u);
  }
  function l(c, u, f) {
    if (f in t)
      return s(c, u);
    if (f in e)
      return s(void 0, c);
  }
  const a = {
    url: o,
    method: o,
    data: o,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    withXSRFToken: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: l,
    headers: (c, u) => r(Dl(c), Dl(u), !0)
  };
  return I.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const f = a[u] || r, p = f(e[u], t[u], u);
    I.isUndefined(p) && f !== l || (n[u] = p);
  }), n;
}
const Gc = (e) => {
  const t = pn({}, e);
  let { data: n, withXSRFToken: s, xsrfHeaderName: r, xsrfCookieName: o, headers: i, auth: l } = t;
  t.headers = i = Je.from(i), t.url = Hc(Kc(t.baseURL, t.url), e.params, e.paramsSerializer), l && i.set(
    "Authorization",
    "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))
  );
  let a;
  if (I.isFormData(n)) {
    if (Ye.hasStandardBrowserEnv || Ye.hasStandardBrowserWebWorkerEnv)
      i.setContentType(void 0);
    else if ((a = i.getContentType()) !== !1) {
      const [c, ...u] = a ? a.split(";").map((f) => f.trim()).filter(Boolean) : [];
      i.setContentType([c || "multipart/form-data", ...u].join("; "));
    }
  }
  if (Ye.hasStandardBrowserEnv && (s && I.isFunction(s) && (s = s(t)), s || s !== !1 && f_(t.url))) {
    const c = r && o && d_.read(o);
    c && i.set(r, c);
  }
  return t;
}, m_ = typeof XMLHttpRequest < "u", g_ = m_ && function(e) {
  return new Promise(function(n, s) {
    const r = Gc(e);
    let o = r.data;
    const i = Je.from(r.headers).normalize();
    let { responseType: l, onUploadProgress: a, onDownloadProgress: c } = r, u, f, p, b, _;
    function T() {
      b && b(), _ && _(), r.cancelToken && r.cancelToken.unsubscribe(u), r.signal && r.signal.removeEventListener("abort", u);
    }
    let C = new XMLHttpRequest();
    C.open(r.method.toUpperCase(), r.url, !0), C.timeout = r.timeout;
    function g() {
      if (!C)
        return;
      const L = Je.from(
        "getAllResponseHeaders" in C && C.getAllResponseHeaders()
      ), O = {
        data: !l || l === "text" || l === "json" ? C.responseText : C.response,
        status: C.status,
        statusText: C.statusText,
        headers: L,
        config: e,
        request: C
      };
      jc(function(N) {
        n(N), T();
      }, function(N) {
        s(N), T();
      }, O), C = null;
    }
    "onloadend" in C ? C.onloadend = g : C.onreadystatechange = function() {
      !C || C.readyState !== 4 || C.status === 0 && !(C.responseURL && C.responseURL.indexOf("file:") === 0) || setTimeout(g);
    }, C.onabort = function() {
      C && (s(new z("Request aborted", z.ECONNABORTED, e, C)), C = null);
    }, C.onerror = function() {
      s(new z("Network Error", z.ERR_NETWORK, e, C)), C = null;
    }, C.ontimeout = function() {
      let E = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const O = r.transitional || Vc;
      r.timeoutErrorMessage && (E = r.timeoutErrorMessage), s(new z(
        E,
        O.clarifyTimeoutError ? z.ETIMEDOUT : z.ECONNABORTED,
        e,
        C
      )), C = null;
    }, o === void 0 && i.setContentType(null), "setRequestHeader" in C && I.forEach(i.toJSON(), function(E, O) {
      C.setRequestHeader(O, E);
    }), I.isUndefined(r.withCredentials) || (C.withCredentials = !!r.withCredentials), l && l !== "json" && (C.responseType = r.responseType), c && ([p, _] = Ys(c, !0), C.addEventListener("progress", p)), a && C.upload && ([f, b] = Ys(a), C.upload.addEventListener("progress", f), C.upload.addEventListener("loadend", b)), (r.cancelToken || r.signal) && (u = (L) => {
      C && (s(!L || L.type ? new Mn(null, e, C) : L), C.abort(), C = null);
    }, r.cancelToken && r.cancelToken.subscribe(u), r.signal && (r.signal.aborted ? u() : r.signal.addEventListener("abort", u)));
    const v = a_(r.url);
    if (v && Ye.protocols.indexOf(v) === -1) {
      s(new z("Unsupported protocol " + v + ":", z.ERR_BAD_REQUEST, e));
      return;
    }
    C.send(o || null);
  });
}, __ = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let s = new AbortController(), r;
    const o = function(c) {
      if (!r) {
        r = !0, l();
        const u = c instanceof Error ? c : this.reason;
        s.abort(u instanceof z ? u : new Mn(u instanceof Error ? u.message : u));
      }
    };
    let i = t && setTimeout(() => {
      i = null, o(new z(`timeout ${t} of ms exceeded`, z.ETIMEDOUT));
    }, t);
    const l = () => {
      e && (i && clearTimeout(i), i = null, e.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(o) : c.removeEventListener("abort", o);
      }), e = null);
    };
    e.forEach((c) => c.addEventListener("abort", o));
    const { signal: a } = s;
    return a.unsubscribe = () => I.asap(l), a;
  }
}, b_ = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let s = 0, r;
  for (; s < n; )
    r = s + t, yield e.slice(s, r), s = r;
}, w_ = async function* (e, t) {
  for await (const n of y_(e))
    yield* b_(n, t);
}, y_ = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: s } = await t.read();
      if (n)
        break;
      yield s;
    }
  } finally {
    await t.cancel();
  }
}, Ml = (e, t, n, s) => {
  const r = w_(e, t);
  let o = 0, i, l = (a) => {
    i || (i = !0, s && s(a));
  };
  return new ReadableStream({
    async pull(a) {
      try {
        const { done: c, value: u } = await r.next();
        if (c) {
          l(), a.close();
          return;
        }
        let f = u.byteLength;
        if (n) {
          let p = o += f;
          n(p);
        }
        a.enqueue(new Uint8Array(u));
      } catch (c) {
        throw l(c), c;
      }
    },
    cancel(a) {
      return l(a), r.return();
    }
  }, {
    highWaterMark: 2
  });
}, br = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", qc = br && typeof ReadableStream == "function", E_ = br && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), Yc = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, T_ = qc && Yc(() => {
  let e = !1;
  const t = new Request(Ye.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), $l = 64 * 1024, bo = qc && Yc(() => I.isReadableStream(new Response("").body)), Js = {
  stream: bo && ((e) => e.body)
};
br && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Js[t] && (Js[t] = I.isFunction(e[t]) ? (n) => n[t]() : (n, s) => {
      throw new z(`Response type '${t}' is not supported`, z.ERR_NOT_SUPPORT, s);
    });
  });
})(new Response());
const S_ = async (e) => {
  if (e == null)
    return 0;
  if (I.isBlob(e))
    return e.size;
  if (I.isSpecCompliantForm(e))
    return (await new Request(Ye.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (I.isArrayBufferView(e) || I.isArrayBuffer(e))
    return e.byteLength;
  if (I.isURLSearchParams(e) && (e = e + ""), I.isString(e))
    return (await E_(e)).byteLength;
}, v_ = async (e, t) => {
  const n = I.toFiniteNumber(e.getContentLength());
  return n ?? S_(t);
}, C_ = br && (async (e) => {
  let {
    url: t,
    method: n,
    data: s,
    signal: r,
    cancelToken: o,
    timeout: i,
    onDownloadProgress: l,
    onUploadProgress: a,
    responseType: c,
    headers: u,
    withCredentials: f = "same-origin",
    fetchOptions: p
  } = Gc(e);
  c = c ? (c + "").toLowerCase() : "text";
  let b = __([r, o && o.toAbortSignal()], i), _;
  const T = b && b.unsubscribe && (() => {
    b.unsubscribe();
  });
  let C;
  try {
    if (a && T_ && n !== "get" && n !== "head" && (C = await v_(u, s)) !== 0) {
      let O = new Request(t, {
        method: "POST",
        body: s,
        duplex: "half"
      }), F;
      if (I.isFormData(s) && (F = O.headers.get("content-type")) && u.setContentType(F), O.body) {
        const [N, H] = Pl(
          C,
          Ys(Fl(a))
        );
        s = Ml(O.body, $l, N, H);
      }
    }
    I.isString(f) || (f = f ? "include" : "omit");
    const g = "credentials" in Request.prototype;
    _ = new Request(t, {
      ...p,
      signal: b,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: s,
      duplex: "half",
      credentials: g ? f : void 0
    });
    let v = await fetch(_);
    const L = bo && (c === "stream" || c === "response");
    if (bo && (l || L && T)) {
      const O = {};
      ["status", "statusText", "headers"].forEach((P) => {
        O[P] = v[P];
      });
      const F = I.toFiniteNumber(v.headers.get("content-length")), [N, H] = l && Pl(
        F,
        Ys(Fl(l), !0)
      ) || [];
      v = new Response(
        Ml(v.body, $l, N, () => {
          H && H(), T && T();
        }),
        O
      );
    }
    c = c || "text";
    let E = await Js[I.findKey(Js, c) || "text"](v, e);
    return !L && T && T(), await new Promise((O, F) => {
      jc(O, F, {
        data: E,
        headers: Je.from(v.headers),
        status: v.status,
        statusText: v.statusText,
        config: e,
        request: _
      });
    });
  } catch (g) {
    throw T && T(), g && g.name === "TypeError" && /fetch/i.test(g.message) ? Object.assign(
      new z("Network Error", z.ERR_NETWORK, e, _),
      {
        cause: g.cause || g
      }
    ) : z.from(g, g && g.code, e, _);
  }
}), wo = {
  http: Hg,
  xhr: g_,
  fetch: C_
};
I.forEach(wo, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Ul = (e) => `- ${e}`, L_ = (e) => I.isFunction(e) || e === null || e === !1, Jc = {
  getAdapter: (e) => {
    e = I.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, s;
    const r = {};
    for (let o = 0; o < t; o++) {
      n = e[o];
      let i;
      if (s = n, !L_(n) && (s = wo[(i = String(n)).toLowerCase()], s === void 0))
        throw new z(`Unknown adapter '${i}'`);
      if (s)
        break;
      r[i || "#" + o] = s;
    }
    if (!s) {
      const o = Object.entries(r).map(
        ([l, a]) => `adapter ${l} ` + (a === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let i = t ? o.length > 1 ? `since :
` + o.map(Ul).join(`
`) : " " + Ul(o[0]) : "as no adapter specified";
      throw new z(
        "There is no suitable adapter to dispatch the request " + i,
        "ERR_NOT_SUPPORT"
      );
    }
    return s;
  },
  adapters: wo
};
function Hr(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Mn(null, e);
}
function Hl(e) {
  return Hr(e), e.headers = Je.from(e.headers), e.data = Ur.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Jc.getAdapter(e.adapter || ws.adapter)(e).then(function(s) {
    return Hr(e), s.data = Ur.call(
      e,
      e.transformResponse,
      s
    ), s.headers = Je.from(s.headers), s;
  }, function(s) {
    return Bc(s) || (Hr(e), s && s.response && (s.response.data = Ur.call(
      e,
      e.transformResponse,
      s.response
    ), s.response.headers = Je.from(s.response.headers))), Promise.reject(s);
  });
}
const Xc = "1.7.7", si = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  si[e] = function(s) {
    return typeof s === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Vl = {};
si.transitional = function(t, n, s) {
  function r(o, i) {
    return "[Axios v" + Xc + "] Transitional option '" + o + "'" + i + (s ? ". " + s : "");
  }
  return (o, i, l) => {
    if (t === !1)
      throw new z(
        r(i, " has been removed" + (n ? " in " + n : "")),
        z.ERR_DEPRECATED
      );
    return n && !Vl[i] && (Vl[i] = !0, console.warn(
      r(
        i,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(o, i, l) : !0;
  };
};
function k_(e, t, n) {
  if (typeof e != "object")
    throw new z("options must be an object", z.ERR_BAD_OPTION_VALUE);
  const s = Object.keys(e);
  let r = s.length;
  for (; r-- > 0; ) {
    const o = s[r], i = t[o];
    if (i) {
      const l = e[o], a = l === void 0 || i(l, o, e);
      if (a !== !0)
        throw new z("option " + o + " must be " + a, z.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new z("Unknown option " + o, z.ERR_BAD_OPTION);
  }
}
const yo = {
  assertOptions: k_,
  validators: si
}, Dt = yo.validators;
class dn {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Nl(),
      response: new Nl()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (s) {
      if (s instanceof Error) {
        let r;
        Error.captureStackTrace ? Error.captureStackTrace(r = {}) : r = new Error();
        const o = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          s.stack ? o && !String(s.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (s.stack += `
` + o) : s.stack = o;
        } catch {
        }
      }
      throw s;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = pn(this.defaults, n);
    const { transitional: s, paramsSerializer: r, headers: o } = n;
    s !== void 0 && yo.assertOptions(s, {
      silentJSONParsing: Dt.transitional(Dt.boolean),
      forcedJSONParsing: Dt.transitional(Dt.boolean),
      clarifyTimeoutError: Dt.transitional(Dt.boolean)
    }, !1), r != null && (I.isFunction(r) ? n.paramsSerializer = {
      serialize: r
    } : yo.assertOptions(r, {
      encode: Dt.function,
      serialize: Dt.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let i = o && I.merge(
      o.common,
      o[n.method]
    );
    o && I.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (_) => {
        delete o[_];
      }
    ), n.headers = Je.concat(i, o);
    const l = [];
    let a = !0;
    this.interceptors.request.forEach(function(T) {
      typeof T.runWhen == "function" && T.runWhen(n) === !1 || (a = a && T.synchronous, l.unshift(T.fulfilled, T.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(T) {
      c.push(T.fulfilled, T.rejected);
    });
    let u, f = 0, p;
    if (!a) {
      const _ = [Hl.bind(this), void 0];
      for (_.unshift.apply(_, l), _.push.apply(_, c), p = _.length, u = Promise.resolve(n); f < p; )
        u = u.then(_[f++], _[f++]);
      return u;
    }
    p = l.length;
    let b = n;
    for (f = 0; f < p; ) {
      const _ = l[f++], T = l[f++];
      try {
        b = _(b);
      } catch (C) {
        T.call(this, C);
        break;
      }
    }
    try {
      u = Hl.call(this, b);
    } catch (_) {
      return Promise.reject(_);
    }
    for (f = 0, p = c.length; f < p; )
      u = u.then(c[f++], c[f++]);
    return u;
  }
  getUri(t) {
    t = pn(this.defaults, t);
    const n = Kc(t.baseURL, t.url);
    return Hc(n, t.params, t.paramsSerializer);
  }
}
I.forEach(["delete", "get", "head", "options"], function(t) {
  dn.prototype[t] = function(n, s) {
    return this.request(pn(s || {}, {
      method: t,
      url: n,
      data: (s || {}).data
    }));
  };
});
I.forEach(["post", "put", "patch"], function(t) {
  function n(s) {
    return function(o, i, l) {
      return this.request(pn(l || {}, {
        method: t,
        headers: s ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: i
      }));
    };
  }
  dn.prototype[t] = n(), dn.prototype[t + "Form"] = n(!0);
});
class ri {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(o) {
      n = o;
    });
    const s = this;
    this.promise.then((r) => {
      if (!s._listeners) return;
      let o = s._listeners.length;
      for (; o-- > 0; )
        s._listeners[o](r);
      s._listeners = null;
    }), this.promise.then = (r) => {
      let o;
      const i = new Promise((l) => {
        s.subscribe(l), o = l;
      }).then(r);
      return i.cancel = function() {
        s.unsubscribe(o);
      }, i;
    }, t(function(o, i, l) {
      s.reason || (s.reason = new Mn(o, i, l), n(s.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (s) => {
      t.abort(s);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new ri(function(r) {
        t = r;
      }),
      cancel: t
    };
  }
}
function A_(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function O_(e) {
  return I.isObject(e) && e.isAxiosError === !0;
}
const Eo = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Eo).forEach(([e, t]) => {
  Eo[t] = e;
});
function zc(e) {
  const t = new dn(e), n = Ac(dn.prototype.request, t);
  return I.extend(n, dn.prototype, t, { allOwnKeys: !0 }), I.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(r) {
    return zc(pn(e, r));
  }, n;
}
const Se = zc(ws);
Se.Axios = dn;
Se.CanceledError = Mn;
Se.CancelToken = ri;
Se.isCancel = Bc;
Se.VERSION = Xc;
Se.toFormData = _r;
Se.AxiosError = z;
Se.Cancel = Se.CanceledError;
Se.all = function(t) {
  return Promise.all(t);
};
Se.spread = A_;
Se.isAxiosError = O_;
Se.mergeConfig = pn;
Se.AxiosHeaders = Je;
Se.formToJSON = (e) => Wc(I.isHTMLForm(e) ? new FormData(e) : e);
Se.getAdapter = Jc.getAdapter;
Se.HttpStatusCode = Eo;
Se.default = Se;
class I_ {
  constructor() {
    this.conn = Se.create({
      baseURL: "https://wallgram.app/api"
    });
  }
}
var Vt;
class R_ {
  constructor(t) {
    wr(this, Vt);
    this.startTask = async (n) => {
      var s, r;
      try {
        return {
          value: (await wn(this, Vt).conn.post(`/v3/players/${n.tgId}/platforms/${n.platformId}/tasks/${n.taskId}`, n, {
            params: { language: n.language }
          })).data.value,
          error: null
        };
      } catch (o) {
        return {
          value: null,
          error: new Error(((r = (s = o == null ? void 0 : o.response) == null ? void 0 : s.data) == null ? void 0 : r.message) || "Network error, try again late")
        };
      }
    }, this.finishTask = async (n) => {
      var s, r;
      try {
        return {
          value: (await wn(this, Vt).conn.delete(
            `/v3/players/${n.tgId}/platforms/${n.platformId}/tasks/${n.taskId}`,
            { params: { language: n.language } }
          )).data.value,
          error: null
        };
      } catch (o) {
        return {
          value: null,
          error: new Error(((r = (s = o == null ? void 0 : o.response) == null ? void 0 : s.data) == null ? void 0 : r.message) || "Network error, try again late")
        };
      }
    }, this.getPlatformAndTasks = async (n) => {
      var s, r;
      try {
        return {
          value: (await wn(this, Vt).conn.get(`/v3/players/${n.tgId}/platforms/${n.platformId}/tasks`, {
            params: {
              language: n.language,
              isPremium: n.isPremium
            }
          })).data.value,
          error: null
        };
      } catch (o) {
        return {
          value: null,
          error: new Error(((r = (s = o == null ? void 0 : o.response) == null ? void 0 : s.data) == null ? void 0 : r.code) || "Network error, try again late")
        };
      }
    }, this.sendReport = async (n) => {
      var s, r;
      try {
        const o = new FormData();
        return o.append("message", n.message), n.files.forEach((l) => o.append("screenshots", l)), {
          value: !!(await wn(this, Vt).conn.post(
            `/v3/players/${n.tgId}/platforms/${n.platformId}/tasks/${n.taskId}/report`,
            o,
            { params: { language: n.language } }
          )).data.value.createdAt,
          error: null
        };
      } catch (o) {
        return console.log(o), {
          value: null,
          error: new Error(((r = (s = o == null ? void 0 : o.response) == null ? void 0 : s.data) == null ? void 0 : r.message) || "Network error, try again late")
        };
      }
    }, yr(this, Vt, t);
  }
}
Vt = new WeakMap();
var fs;
class N_ {
  constructor() {
    wr(this, fs);
    yr(this, fs, new I_()), this.ShowcaseActions = new R_(wn(this, fs));
  }
}
fs = new WeakMap();
class x_ {
  constructor() {
    console.log("new cs"), this.CS = new N_();
  }
}
function P_(e, t) {
  if (e === 0)
    return 0;
  const n = e > 10 && e < 20, s = e % 10 === 1;
  return t < 4 ? !n && s ? 1 : 2 : !n && s ? 1 : !n && e % 10 >= 2 && e % 10 <= 4 || t < 4 ? 2 : 3;
}
const F_ = {
  ru: P_
}, D_ = "Tasks", M_ = "Complete tasks and get rewards", $_ = "Claim", U_ = "There are currently no available tasks. Please try again later.", H_ = {
  title: "Join channel {name}",
  description: "Subscribe channel and don't leave it.",
  check_btn_text: "Check",
  go_to_btn_text: "Join"
}, V_ = {
  title: "Launch bot {name}",
  description: "Start bot and play",
  check_btn_text: "Check",
  go_to_btn_text: "Launch"
}, W_ = {
  title: "Join chat {name}",
  description: "Join the chat and don't leave it.",
  check_btn_text: "Check",
  go_to_btn_text: "Join"
}, B_ = {
  title: "Visit website",
  description: "Visit the website for 15 seconds",
  check_btn_text: "Check",
  go_to_btn_text: "Go"
}, j_ = {
  DEFAULT_ERROR: {
    title: "Something went wrong"
  },
  PT_COMPLETED_EXIST: {
    title: "You have already completed this task"
  },
  PT_DUPLICATED: {
    title: "You have already started this task"
  },
  PT_NON_EXIST_ACTIVE: {
    title: "Unable to start the task"
  },
  PT_NOT_VERIFIED: {
    title: "Make sure you have completed the task"
  },
  PT_INVALID_TG_MEMBER: {
    title: "You cannot complete this task because you have already participated."
  },
  FORM_VALIDATION: {
    title: "Make sure you fill out the fields correctly"
  },
  IMAGE_SIZE_VALIDATION: {
    title: "Make sure you file size does not exceed {size}mb"
  }
}, K_ = {
  sec: "sec",
  h: "h",
  min: "min",
  d: "d",
  m: "m",
  s: "s"
}, G_ = {
  tasks_title: D_,
  tasks_description: M_,
  claim: $_,
  tasks_not_found: U_,
  CHANNEL: H_,
  BOT: V_,
  CHAT: W_,
  SMART_LINK: B_,
  error: j_,
  time: K_
}, q_ = "Задания", Y_ = "Выполняйте задания и получайте награды", J_ = "Забрать", X_ = "В данный момент доступных заданий нет. Попробуйте зайти позже", z_ = {
  title: "Подписаться на канал {name}",
  description: "Подпишись на канал и не выходи из него.",
  check_btn_text: "Проверить",
  go_to_btn_text: "Подписаться"
}, Z_ = {
  title: "Запустить бота {name}",
  description: "Запусти бота и играй",
  check_btn_text: "Проверить",
  go_to_btn_text: "Запустить"
}, Q_ = {
  title: "Вступить в чат {name}",
  description: "Присоединяйся к чату и не покидай его",
  check_btn_text: "Проверить",
  go_to_btn_text: "Вступить"
}, eb = {
  title: "Перейти на сайт",
  description: "Посетите сайт в течение 15 секунд",
  check_btn_text: "Проверить",
  go_to_btn_text: "Перейти"
}, tb = {
  DEFAULT_ERROR: {
    title: "Что-то пошло не так"
  },
  PT_COMPLETED_EXIST: {
    title: "Вы уже выполняли это задание"
  },
  PT_DUPLICATED: {
    title: "Вы уже начали выполнять это задание"
  },
  PT_NON_EXIST_ACTIVE: {
    title: "Невозможно начать выполнение задания"
  },
  PT_NOT_VERIFIED: {
    title: "Убедитесь, что вы выполнили задание"
  },
  PT_INVALID_TG_MEMBER: {
    title: "Вы не можете выполнить это задание, так как вы уже были участником"
  },
  FORM_VALIDATION: {
    title: "Убедитесь, что вы правильно заполнили поля"
  },
  IMAGE_SIZE_VALIDATION: {
    title: "Убедитесь, что вы размер файла не превышает {size}mb"
  }
}, nb = {
  sec: "сек",
  h: "ч",
  min: "мин",
  d: "д",
  m: "м",
  s: "с"
}, sb = {
  tasks_title: q_,
  tasks_description: Y_,
  claim: J_,
  tasks_not_found: X_,
  CHANNEL: z_,
  BOT: Z_,
  CHAT: Q_,
  SMART_LINK: eb,
  error: tb,
  time: nb
}, Xs = Rp({
  locale: void 0,
  fallbackLocale: void 0,
  legacy: !1,
  globalInjection: !0,
  warnHtmlMessage: !1,
  messages: {
    en: G_,
    ru: sb
  },
  pluralRules: F_
});
Xs.global;
const Zc = {
  get supportedLocales() {
    return (void 0).split(",");
  },
  set currentLocale(e) {
    Xs.global.locale.value = e;
  },
  get currentLocale() {
    return Xs.global.locale.value;
  },
  async switchLanguage(e) {
    Zc.currentLocale = e, document.querySelector("html").setAttribute("lang", e);
  }
}, St = class St {
  static onStartTask(t) {
  }
  static onFinishTask(t) {
  }
  static onLoad() {
  }
  static init(t, n = {
    container: "body",
    onLoad: () => {
    },
    onStartTask: (s) => {
    },
    onFinishTask: (s) => {
    }
  }) {
    var r, o, i, l, a;
    const s = document.querySelector(n.container ?? "wallgram_showcase");
    if (s) {
      const c = Pd(Qm), u = $d(), f = new x_(), p = Xs;
      u.use(() => ({ repo: f })), c.use(u), c.provide(eg, f), c.use(p);
      let b = (i = (o = (r = window == null ? void 0 : window.Telegram) == null ? void 0 : r.WebApp.initDataUnsafe) == null ? void 0 : o.user) != null && i.language_code ? (a = (l = window.Telegram.WebApp.initDataUnsafe) == null ? void 0 : l.user) == null ? void 0 : a.language_code : "en";
      Zc.switchLanguage(b);
      let _ = ms(u);
      _.setPlatformId(t), c.mount(s);
      try {
        _.init();
      } catch {
        console.log("Wallgram showcase init error.");
      }
    } else
      console.error(`Container '${n.container}' not found.`);
    typeof n.onStartTask == "function" && (St.onStartTask = n.onStartTask), typeof n.onFinishTask == "function" && (St.onFinishTask = n.onFinishTask), typeof n.onLoad == "function" && (St.onLoad = n.onLoad), St.isInit = !0;
  }
  static show() {
    St.isInit ? window.dispatchEvent(new CustomEvent("WallgramShowcase_show")) : console.log("Wallgram showcase not init");
  }
};
St.isInit = !1, St.topNotification = function(t, n, s = "") {
  window.dispatchEvent(
    new CustomEvent("WallgramShowcase_TopNotification", {
      detail: { title: n, description: s, type: t }
    })
  );
};
let To = St;
window.WallgramShowcase = To;
